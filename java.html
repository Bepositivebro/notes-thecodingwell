<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="logo.png">
    <title>Python Course</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="stylesheet1.css">
    <style>



    </style>
</head>

<body>
    <div class="navbar">

         <!-----for desktop view------------>
         <div class="logo">
            <img src="logo.png" alt="Logo" style="height: 70px; width: auto; margin-left: 20px; ">
        </div>
        

        <!--------------for mobile view---------------->
        <div class="logo1">
            <img src="logo1.png" alt="Logo" style="height: 30px; width: 130px; margin-left: 100px; margin-top: 14px;">
        </div>
        <!-- Menu Button for Mobile View -->
        <button class="menu-btn2" aria-label="Open menu">&#x27A1;</button>

        <!-- Desktop Navbar -->
        <div class="desktop-navbar">
            <button><a href="index.html" style="color: white;">Home</a></button>
            <button><a href="python.html" style="color: white;">Python</a></button>
            <button><a href="cpp.html" style="color: white;">C++</a></button>
            <button><a href="c.html" style="color: white;">C</a></button>
            <button><a href="html.html" style="color: white;">HTML</a></button>
            <button><a href="css.html" style="color: white;">CSS</a></button>
            <button><a href="javascript.html" style="color: white;">JS</a></button>
            <button><a href="java.html" style="color: white;">Java</a></button>
            <button><a href="php.html" style="color: white;">PHP</a></button>
            <button><a href="dsa.html" style="color: white;">DSA</a></button>
        </div>

        <!-- Dropdown Menu for Mobile View -->
        <div class="topic-buttons">
            <a href="index.html"><button>Home</button></a>
            <a href="python.html"><button>Python</button></a>
            <a href="cpp.html"><button>C++</button></a>
            <a href="c.html"><button>C</button></a>
            <a href="html.html"><button>HTML</button></a>
            <a href="css.html"><button>CSS</button></a>
            <a href="javascript.html"><button>JS</button></a>
            <a href="java.html"><button>Java</button></a>
            <a href="php.html"><button>PHP</button></a>
            <a href="dsa.html"><button>DSA</button></a>
        </div>

        
        <!-- Mobile menu button -->
        <div class="menu-btn" id="menuBtn">
            &#9776;
        </div>


    </div>

    <div class="content">
        <!-- Sidebar for Java Topics -->
        <div class="sidebar" id="sidebar">
            <h2>Introduction</h2>
            <ul>
                <li><a href="#java-overview">What is Java?</a></li>
                <li><a href="#java-history">History and Evolution</a></li>
                <li><a href="#java-setup">Setting Up Environment</a></li>
            </ul>

            <h2>Java Basics</h2>
            <ul>
                <li><a href="#syntax">Syntax and Structure</a></li>
                <li><a href="#variables">Variables and Data Types</a></li>
                <li><a href="#operators">Operators</a></li>
                <li><a href="#control-flow">Control Flow Statements</a></li>
                <li><a href="#arrays">Arrays</a></li>
            </ul>

            <h2>Object-Oriented Programming</h2>
            <ul>
                <li><a href="#oop-concepts">OOP Concepts</a></li>
                <li><a href="#classes-objects">Classes and Objects</a></li>
                <li><a href="#inheritance">Inheritance</a></li>
                <li><a href="#polymorphism">Polymorphism</a></li>
                <li><a href="#encapsulation">Encapsulation</a></li>
                <li><a href="#abstraction">Abstraction</a></li>
            </ul>

            <h2>Advanced Topics</h2>
            <ul>
                <li><a href="#collections">Collections Framework</a></li>
                <li><a href="#generics">Generics</a></li>
                <li><a href="#streams">Streams and File Handling</a></li>
                <li><a href="#multithreading">Multithreading</a></li>
                <li><a href="#networking">Networking</a></li>
            </ul>

            <h2>Java APIs and Libraries</h2>
            <ul>
                <li><a href="#javafx">JavaFX</a></li>
                <li><a href="#swing">Swing</a></li>
                <li><a href="#jdbc">JDBC (Database Connectivity)</a></li>
                <li><a href="#json-apis">Working with JSON</a></li>
            </ul>

            <h2>Best Practices</h2>
            <ul>
                <li><a href="#code-readability">Code Readability</a></li>
                <li><a href="#exception-handling">Effective Exception Handling</a></li>
                <li><a href="#testing">Unit Testing</a></li>
                <li><a href="#performance">Performance Optimization</a></li>
                <li><a href="#performance">Performance Optimization</a></li>
            </ul>
        </div>

        <!-- Main Content -->
        <div class="main" id="java-overview">
            <h1>What is Java?</h1>
            <h3>Definition</h3>
            <p>
                Java is a high-level, object-oriented programming language developed by <strong>Sun Microsystems</strong> in 1995. It is widely used for building cross-platform applications due to its "Write Once, Run Anywhere" philosophy.
            </p>
            <h3>Features of Java</h3>
            <ul>
                <li><strong>Platform Independence:</strong> Java code runs on any platform with a Java Virtual Machine (JVM).</li>
                <li><strong>Object-Oriented:</strong> Emphasizes concepts like inheritance, encapsulation, and polymorphism.</li>
                <li><strong>Robust:</strong> Includes strong memory management and exception handling.</li>
                <li><strong>Multithreading:</strong> Supports concurrent execution of multiple threads.</li>
                <li><strong>Secure:</strong> Provides built-in security features like bytecode verification and sandboxing.</li>
            </ul>
            <h3>Applications</h3>
            <ul>
                <li>Desktop Applications</li>
                <li>Web Development</li>
                <li>Mobile Applications (via Android)</li>
                <li>Enterprise Software</li>
                <li>Scientific and Big Data Applications</li>
            </ul>
        </div>

        <!-- Java History and Evolution -->
<div class="main" id="java-history">
    <h1>History and Evolution of Java</h1>

    <h3>Introduction</h3>
    <p>
        Java, a widely-used programming language, has undergone significant evolution since its inception. Developed by Sun Microsystems in the mid-1990s, it has grown to become one of the most popular and versatile programming languages today, primarily known for its platform independence and "write once, run anywhere" philosophy.
    </p>

    <h3>Early Beginnings</h3>
    <p>
        Java's development started in 1991 by James Gosling and Mike Sheridan at Sun Microsystems, initially under the project name <strong>Oak</strong>. The goal was to create a language that could be used for developing software for consumer electronics like set-top boxes and to address the issues of portability.
    </p>

    <h3>Key Milestones in Java's Evolution</h3>
    <ul>
        <li><strong>1995 - Oak becomes Java:</strong> The name Oak was changed to Java after a trademark issue. Java was officially introduced by Sun Microsystems with the release of Java 1.0.</li>
        <li><strong>1996 - Java 1.0:</strong> The first official version of Java, which included features like the Java Virtual Machine (JVM), providing platform independence.</li>
        <li><strong>1997 - Java 1.1:</strong> Introduced features like inner classes, the event-handling model, and JDBC (Java Database Connectivity) for database interaction.</li>
        <li><strong>1999 - Java 2:</strong> Java was divided into three editions: J2SE (Standard Edition), J2EE (Enterprise Edition), and J2ME (Micro Edition). The introduction of Swing for graphical user interfaces was a notable enhancement.</li>
        <li><strong>2004 - Java 5 (J2SE 5.0):</strong> Java introduced major language changes like generics, metadata annotations, enumerated types, and the enhanced for loop.</li>
        <li><strong>2009 - Java 7:</strong> The introduction of the try-with-resources statement, and other improvements, along with better exception handling.</li>
        <li><strong>2014 - Java 8:</strong> A significant release introducing lambdas, the Stream API, and the new java.time package for date-time handling.</li>
        <li><strong>2017 - Java 9:</strong> The introduction of the module system, making it easier to modularize large applications.</li>
        <li><strong>2018 - Java 10 and onwards:</strong> The introduction of a new release cadence with major feature updates every six months, leading to improvements in performance, security, and syntax.</li>
    </ul>

    <h3>Java's Philosophy: "Write Once, Run Anywhere"</h3>
    <p>
        One of the key design goals of Java was to create a platform-independent language. The introduction of the <strong>Java Virtual Machine (JVM)</strong> allowed developers to write Java applications that could run on any platform without modification, leading to Java's widespread adoption for both web and enterprise applications.
    </p>

    <h3>Java in the Modern Era</h3>
    <p>
        Java has continued to evolve and remain relevant in the world of modern software development. With the rise of cloud computing, microservices, and big data, Java continues to play a central role in many enterprise systems and applications.
    </p>

    <h3>Summary</h3>
    <p>
        From its origins in the 1990s to the present, Java has experienced continuous evolution, introducing important features and capabilities that have shaped it into one of the most powerful and versatile programming languages in the world. Its platform independence, vast ecosystem, and strong community support have helped Java maintain its place as a leading language for developing a wide range of applications.
    </p>
</div>

<!-- Java Setting Up Environment -->
<div class="main" id="java-setup">
    <h1>Setting Up the Java Development Environment</h1>

    <h3>Introduction</h3>
    <p>
        Before you start writing Java programs, you need to set up the Java Development Environment (JDE) on your machine. This includes installing the Java Development Kit (JDK) and setting up an Integrated Development Environment (IDE) for writing and running your Java code.
    </p>

    <h3>Steps to Set Up Java Environment</h3>
    <ul>
        <li><strong>1. Install JDK (Java Development Kit):</strong> The JDK is the core development kit that includes the JRE (Java Runtime Environment) and all necessary tools to develop Java applications, including the Java compiler.</li>
        <li><strong>2. Install an IDE (Integrated Development Environment):</strong> An IDE provides tools for writing, debugging, and running Java code. Popular choices for Java development include <strong>IntelliJ IDEA</strong>, <strong>Eclipse</strong>, and <strong>NetBeans</strong>.</li>
        <li><strong>3. Set Up PATH Environment Variable:</strong> After installing the JDK, you need to set the <code>PATH</code> environment variable to point to the JDK’s bin directory. This allows you to run Java commands from the command line.</li>
        <li><strong>4. Verify Java Installation:</strong> Once the JDK is installed and the PATH is set, you can verify the installation by running <code>java -version</code> and <code>javac -version</code> in the command prompt or terminal to check if the Java Runtime and Compiler are installed correctly.</li>
    </ul>

    <h3>Step 1: Install JDK</h3>
    <p>
        - Go to the official Oracle website to download the latest JDK version: <a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html" target="_blank">JDK Download</a>.
        - Choose the version appropriate for your operating system (Windows, macOS, or Linux).
        - Follow the installation instructions provided on the website.
    </p>

    <h3>Step 2: Install an IDE</h3>
    <p>
        Popular Java IDEs include:
    </p>
    <ul>
        <li><strong>IntelliJ IDEA:</strong> Known for its smart code completion and user-friendly interface. Available at <a href="https://www.jetbrains.com/idea/" target="_blank">IntelliJ IDEA</a>.</li>
        <li><strong>Eclipse:</strong> A popular open-source IDE with robust Java development features. Available at <a href="https://www.eclipse.org/downloads/" target="_blank">Eclipse Downloads</a>.</li>
        <li><strong>NetBeans:</strong> Another open-source IDE supported by Oracle, available at <a href="https://netbeans.apache.org/" target="_blank">NetBeans Downloads</a>.</li>
    </ul>

    <h3>Step 3: Set the PATH Variable</h3>
    <p>
        Once the JDK is installed, you need to add the <code>bin</code> directory of your JDK installation to the system’s PATH environment variable. This ensures that Java commands such as <code>java</code> and <code>javac</code> can be run from any command line interface.
    </p>
    <pre>
        <code>
            On Windows:
            1. Open System Properties &gt; Advanced &gt; Environment Variables.
            2. Under "System variables," select <code>Path</code> and click "Edit."
            3. Add the path to the JDK's bin folder (e.g., <code>C:\Program Files\Java\jdk-14\bin</code>).

            On macOS/Linux:
            1. Open Terminal.
            2. Edit the <code>.bash_profile</code> or <code>.bashrc</code> file and add the following line:
            <code>export PATH=$PATH:/path/to/jdk/bin</code>.
        </code>
    </pre>

    <h3>Step 4: Verify Installation</h3>
    <p>
        After setting up the JDK and PATH, you can verify your Java installation by opening a terminal or command prompt and typing the following commands:
    </p>
    <pre>
        <code>
            java -version
            javac -version
        </code>
    </pre>
    <p>
        These commands should output the installed Java version. If you see an error message, ensure the JDK is correctly installed and the PATH is set properly.
    </p>

    <h3>Conclusion</h3>
    <p>
        Setting up the Java development environment is the first step towards becoming a Java developer. By installing the JDK, setting the PATH variable, and choosing the right IDE, you will be ready to start writing and running Java applications.
    </p>
</div>

<!-- Java Syntax and Structure -->
<div class="main" id="syntax">
    <h1>Syntax and Structure</h1>

    <h3>Introduction</h3>
    <p>
        Java is a statically-typed, object-oriented programming language with a specific syntax. Understanding the syntax and structure is essential for writing Java programs. The structure of a Java program is designed to be simple and logical, making it easy for developers to write and maintain code.
    </p>

    <h3>Java Program Structure</h3>
    <p>
        A basic Java program consists of the following elements:
    </p>
    <ul>
        <li><strong>Class Declaration:</strong> Java code is written inside classes. A class is defined using the <code>class</code> keyword.</li>
        <li><strong>Method Declaration:</strong> Code execution begins with a <code>main</code> method in Java. This method is defined as <code>public static void main(String[] args)</code>.</li>
        <li><strong>Statements:</strong> Statements are the individual instructions that perform specific actions, such as printing text or assigning values to variables.</li>
    </ul>

    <h3>Basic Java Program Example</h3>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class HelloWorld {
                public static void main(String[] args) {
                    System.out.println("Hello, World!");
                }
            }
        </code>
    </pre>

    <h3>Explanation</h3>
    <p>
        - <code>public class HelloWorld</code>: Defines a class named <code>HelloWorld</code>.
        - <code>public static void main(String[] args)</code>: The <code>main</code> method that serves as the entry point for the program.
        - <code>System.out.println("Hello, World!");</code>: This is a statement that prints "Hello, World!" to the console.
    </p>

    <h3>Key Syntax Rules</h3>
    <ul>
        <li><strong>Case Sensitivity:</strong> Java is case-sensitive. For example, <code>myVariable</code> and <code>MyVariable</code> are different identifiers.</li>
        <li><strong>Semicolons:</strong> Every statement must end with a semicolon (<code>;</code>).</li>
        <li><strong>Curly Braces:</strong> Java uses curly braces (<code>{ }</code>) to define code blocks, such as the body of a class or method.</li>
        <li><strong>Comments:</strong> Comments are used to explain code. There are two types of comments in Java:
            <ul>
                <li><strong>Single-line comment:</strong> <code>// This is a comment</code></li>
                <li><strong>Multi-line comment:</strong> <code>/* This is a multi-line comment */</code></li>
            </ul>
        </li>
    </ul>

    <h3>Whitespace</h3>
    <p>
        Java ignores extra spaces, tabs, and line breaks. They are only used for formatting and making the code readable. You can use them to separate tokens (keywords, variables, operators) in the code.
    </p>

    <h3>Indentation</h3>
    <p>
        While indentation is not required for the Java compiler, it is crucial for code readability. Developers typically use four spaces or a tab for indentation.
    </p>

    <h3>Code Structure in Practice</h3>
    <p>
        The Java program structure typically follows this outline:
    </p>
    <pre>
        <code>
            public class ClassName {
                // Class body

                public static void main(String[] args) {
                    // Method body
                }
            }
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        The syntax and structure of Java are fundamental to writing programs. A clear understanding of class declaration, method structure, statement syntax, and indentation ensures that Java code is both functional and maintainable.
    </p>
</div>

<!-- Java Variables and Data Types -->
<div class="main" id="variables">
    <h1>Variables and Data Types</h1>

    <h3>Introduction</h3>
    <p>
        In Java, variables are used to store data. Each variable has a specific data type, which defines what kind of data it can store. Understanding variables and data types is fundamental for working with Java, as they are essential for managing and manipulating data within your program.
    </p>

    <h3>What is a Variable?</h3>
    <p>
        A variable is a container for storing data values. It is defined by a type and a name, and it can hold different values during the program's execution.
    </p>

    <h4>Declaring a Variable</h4>
    <p>
        A variable is declared by specifying its type followed by its name. Optionally, you can initialize a variable with a value at the time of declaration.
    </p>
    <pre>
        <code>
            int age = 25;  // Declaration with initialization
            String name;   // Declaration without initialization
        </code>
    </pre>

    <h3>Data Types in Java</h3>
    <p>
        Java has two types of data types:
    </p>
    <ul>
        <li><strong>Primitive Data Types:</strong> These are predefined in Java and represent basic types of data.</li>
        <li><strong>Reference Data Types:</strong> These refer to objects and arrays, which are more complex structures.</li>
    </ul>

    <h3>Primitive Data Types</h3>
    <p>
        There are 8 primitive data types in Java:
    </p>
    <table>
        <thead>
            <tr>
                <th>Data Type</th>
                <th>Size</th>
                <th>Default Value</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>byte</strong></td>
                <td>1 byte</td>
                <td>0</td>
                <td>Used for storing integers in the range -128 to 127.</td>
            </tr>
            <tr>
                <td><strong>short</strong></td>
                <td>2 bytes</td>
                <td>0</td>
                <td>Used for storing integers in the range -32,768 to 32,767.</td>
            </tr>
            <tr>
                <td><strong>int</strong></td>
                <td>4 bytes</td>
                <td>0</td>
                <td>Used for storing integers in the range -2^31 to 2^31-1.</td>
            </tr>
            <tr>
                <td><strong>long</strong></td>
                <td>8 bytes</td>
                <td>0L</td>
                <td>Used for storing large integers in the range -2^63 to 2^63-1.</td>
            </tr>
            <tr>
                <td><strong>float</strong></td>
                <td>4 bytes</td>
                <td>0.0f</td>
                <td>Used for storing floating-point numbers (decimal values) with single precision.</td>
            </tr>
            <tr>
                <td><strong>double</strong></td>
                <td>8 bytes</td>
                <td>0.0d</td>
                <td>Used for storing floating-point numbers (decimal values) with double precision.</td>
            </tr>
            <tr>
                <td><strong>char</strong></td>
                <td>2 bytes</td>
                <td>'\u0000'</td>
                <td>Used for storing single characters (e.g., 'A', 'b').</td>
            </tr>
            <tr>
                <td><strong>boolean</strong></td>
                <td>1 bit</td>
                <td>false</td>
                <td>Used for storing true or false values.</td>
            </tr>
        </tbody>
    </table>

    <h3>Reference Data Types</h3>
    <p>
        Reference data types are more complex than primitive types and can store references to objects and arrays. Common reference types in Java include:
    </p>
    <ul>
        <li><strong>Objects:</strong> Instances of classes that can store multiple values and behaviors.</li>
        <li><strong>Arrays:</strong> Used to store multiple values of the same type in a single variable.</li>
    </ul>

    <h3>Type Casting</h3>
    <p>
        Type casting refers to converting a variable from one type to another. There are two types of casting:
    </p>
    <ul>
        <li><strong>Implicit Casting (Widening):</strong> Java automatically converts smaller data types to larger ones (e.g., from <code>int</code> to <code>long</code>).</li>
        <li><strong>Explicit Casting (Narrowing):</strong> The programmer manually converts a larger data type to a smaller one (e.g., from <code>double</code> to <code>int</code>).</li>
    </ul>
    <pre>
        <code>
            // Implicit casting (Widening)
            int num = 100;
            long largeNum = num;  // Implicit conversion from int to long

            // Explicit casting (Narrowing)
            double pi = 3.14159;
            int intPi = (int) pi;  // Explicit conversion from double to int
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        Variables and data types are the foundation of Java programming. Understanding how to declare and use variables, as well as how to work with primitive and reference data types, is essential for building functional Java applications.
    </p>
</div>

<!-- Java Operators -->
<div class="main" id="operators">
    <h1>Operators</h1>

    <h3>Introduction</h3>
    <p>
        Operators in Java are special symbols or keywords that are used to perform operations on variables and values. Java supports a wide variety of operators that perform different operations such as arithmetic, comparison, logical, and bitwise operations.
    </p>

    <h3>Types of Operators in Java</h3>
    <p>
        Java operators can be categorized into several types:
    </p>
    <ul>
        <li><strong>Arithmetic Operators:</strong> Used to perform mathematical operations.</li>
        <li><strong>Relational (Comparison) Operators:</strong> Used to compare two values.</li>
        <li><strong>Logical Operators:</strong> Used to perform logical operations (AND, OR, NOT).</li>
        <li><strong>Bitwise Operators:</strong> Used to perform bit-level operations.</li>
        <li><strong>Assignment Operators:</strong> Used to assign values to variables.</li>
        <li><strong>Unary Operators:</strong> Used with a single operand.</li>
        <li><strong>Conditional (Ternary) Operator:</strong> A shorthand for simple if-else statements.</li>
    </ul>

    <h3>Arithmetic Operators</h3>
    <p>
        Arithmetic operators are used to perform basic mathematical operations. These include addition, subtraction, multiplication, division, and modulus.
    </p>
    <pre>
        <code>
            int a = 10;
            int b = 5;
            
            System.out.println("Addition: " + (a + b));   // 15
            System.out.println("Subtraction: " + (a - b)); // 5
            System.out.println("Multiplication: " + (a * b)); // 50
            System.out.println("Division: " + (a / b));    // 2
            System.out.println("Modulus: " + (a % b));     // 0
        </code>
    </pre>

    <h3>Relational (Comparison) Operators</h3>
    <p>
        Relational operators are used to compare two values. These operators return a boolean value (true or false).
    </p>
    <pre>
        <code>
            int a = 10;
            int b = 5;
            
            System.out.println("a > b: " + (a > b));  // true
            System.out.println("a < b: " + (a < b));  // false
            System.out.println("a == b: " + (a == b)); // false
            System.out.println("a != b: " + (a != b)); // true
        </code>
    </pre>

    <h3>Logical Operators</h3>
    <p>
        Logical operators are used to combine conditional statements. These include AND, OR, and NOT.
    </p>
    <pre>
        <code>
            boolean x = true;
            boolean y = false;
            
            System.out.println("x AND y: " + (x && y));  // false
            System.out.println("x OR y: " + (x || y));   // true
            System.out.println("NOT x: " + !x);           // false
        </code>
    </pre>

    <h3>Bitwise Operators</h3>
    <p>
        Bitwise operators perform operations on the bits of integers. These include AND, OR, XOR, complement, left shift, and right shift operators.
    </p>
    <pre>
        <code>
            int a = 5;  // binary: 0101
            int b = 3;  // binary: 0011
            
            System.out.println("a & b: " + (a & b));  // 1 (binary: 0001)
            System.out.println("a | b: " + (a | b));  // 7 (binary: 0111)
            System.out.println("a ^ b: " + (a ^ b));  // 6 (binary: 0110)
            System.out.println("~a: " + (~a));        // -6 (binary: 1010)
            System.out.println("a << 1: " + (a << 1)); // 10 (binary: 1010)
            System.out.println("a >> 1: " + (a >> 1)); // 2 (binary: 0010)
        </code>
    </pre>

    <h3>Assignment Operators</h3>
    <p>
        Assignment operators are used to assign values to variables. The basic assignment operator is "=". However, there are also compound assignment operators such as "+=", "-=", "*=", "/=", and "%=".
    </p>
    <pre>
        <code>
            int a = 10;
            a += 5; // Equivalent to a = a + 5
            System.out.println("a += 5: " + a); // 15
            
            a -= 3; // Equivalent to a = a - 3
            System.out.println("a -= 3: " + a); // 12
        </code>
    </pre>

    <h3>Unary Operators</h3>
    <p>
        Unary operators are used with a single operand. These include increment (++) and decrement (--) operators, as well as the unary minus (-) and plus (+).
    </p>
    <pre>
        <code>
            int a = 5;
            System.out.println("a++: " + a++); // 5 (Post-increment)
            System.out.println("++a: " + ++a); // 7 (Pre-increment)
            
            System.out.println("a--: " + a--); // 7 (Post-decrement)
            System.out.println("--a: " + --a); // 5 (Pre-decrement)
        </code>
    </pre>

    <h3>Conditional (Ternary) Operator</h3>
    <p>
        The ternary operator is a shorthand for simple if-else statements. It takes three operands: a condition, a value if true, and a value if false.
    </p>
    <pre>
        <code>
            int a = 10;
            String result = (a > 5) ? "Greater than 5" : "Less than or equal to 5";
            System.out.println(result); // "Greater than 5"
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        Operators in Java are used to perform various operations on variables and values. Understanding the different types of operators and how they work is crucial for writing efficient and effective Java programs.
    </p>
</div>

<!-- Control Flow Statements -->
<div class="main" id="control-flow">
    <h1>Control Flow Statements</h1>

    <h3>Introduction</h3>
    <p>
        Control flow statements in Java determine the order in which individual statements, instructions, or function calls are executed. These statements allow the program to make decisions, repeat operations, and control the flow of execution based on different conditions.
    </p>

    <h3>Types of Control Flow Statements</h3>
    <ul>
        <li><strong>If-Else Statements:</strong> Used to execute a block of code based on a condition.</li>
        <li><strong>Switch-Case:</strong> Used to select one of many code blocks to be executed.</li>
        <li><strong>Loops:</strong> Used to repeat a block of code multiple times (for, while, do-while).</li>
    </ul>

    <h3>If-Else Statements</h3>
    <p>
        The <code>if</code> statement is used to test a condition, and the block of code inside the <code>if</code> is executed if the condition is true. If the condition is false, the code inside the <code>else</code> block is executed.
    </p>
    <pre>
        <code>
            int a = 10;
            if (a > 5) {
                System.out.println("a is greater than 5");
            } else {
                System.out.println("a is less than or equal to 5");
            }
        </code>
    </pre>

    <h3>If-Else If-Else Statements</h3>
    <p>
        You can chain multiple conditions using <code>else if</code> to test several conditions in sequence. If one condition is true, the corresponding block will be executed.
    </p>
    <pre>
        <code>
            int a = 10;
            if (a > 10) {
                System.out.println("a is greater than 10");
            } else if (a == 10) {
                System.out.println("a is equal to 10");
            } else {
                System.out.println("a is less than 10");
            }
        </code>
    </pre>

    <h3>Switch-Case Statement</h3>
    <p>
        The <code>switch</code> statement is used to execute one of many blocks of code based on the value of an expression. It is an alternative to using multiple <code>if-else if</code> statements.
    </p>
    <pre>
        <code>
            int day = 3;
            switch (day) {
                case 1:
                    System.out.println("Monday");
                    break;
                case 2:
                    System.out.println("Tuesday");
                    break;
                case 3:
                    System.out.println("Wednesday");
                    break;
                case 4:
                    System.out.println("Thursday");
                    break;
                default:
                    System.out.println("Invalid day");
            }
        </code>
    </pre>

    <h3>For Loop</h3>
    <p>
        The <code>for</code> loop is used when you know the number of iterations beforehand. It includes three components: initialization, condition, and increment/decrement.
    </p>
    <pre>
        <code>
            for (int i = 0; i < 5; i++) {
                System.out.println(i);
            }
        </code>
    </pre>

    <h3>While Loop</h3>
    <p>
        The <code>while</code> loop repeats a block of code as long as the condition is true. It checks the condition before each iteration.
    </p>
    <pre>
        <code>
            int i = 0;
            while (i < 5) {
                System.out.println(i);
                i++;
            }
        </code>
    </pre>

    <h3>Do-While Loop</h3>
    <p>
        The <code>do-while</code> loop is similar to the <code>while</code> loop, but it checks the condition after executing the code block, ensuring that the code is executed at least once.
    </p>
    <pre>
        <code>
            int i = 0;
            do {
                System.out.println(i);
                i++;
            } while (i < 5);
        </code>
    </pre>

    <h3>Break and Continue</h3>
    <p>
        <code>break</code> is used to exit the loop or switch statement immediately, while <code>continue</code> skips the current iteration and proceeds to the next iteration of the loop.
    </p>
    <pre>
        <code>
            for (int i = 0; i < 5; i++) {
                if (i == 3) {
                    break; // Exit the loop when i equals 3
                }
                System.out.println(i);
            }

            for (int i = 0; i < 5; i++) {
                if (i == 2) {
                    continue; // Skip the iteration when i equals 2
                }
                System.out.println(i);
            }
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        Control flow statements are fundamental to programming as they allow you to control the flow of execution based on certain conditions and repeat certain operations. Mastering these concepts is essential for writing effective Java programs.
    </p>
</div>

<!-- Arrays -->
<div class="main" id="arrays">
    <h1>Arrays</h1>

    <h3>Introduction</h3>
    <p>
        An array in Java is a data structure that allows you to store multiple values in a single variable. Arrays are useful when you need to store a collection of similar items, such as integers, strings, or objects.
    </p>

    <h3>Declaring and Initializing Arrays</h3>
    <p>
        To declare an array in Java, you specify the type of elements the array will hold, followed by square brackets (<code>[]</code>) and the array name. You can then initialize the array with values.
    </p>
    <pre>
        <code>
            // Declaring an array
            int[] numbers;
            // Initializing the array
            numbers = new int[5]; // Array of size 5

            // Declaring and initializing an array
            int[] numbers = {1, 2, 3, 4, 5};
        </code>
    </pre>

    <h3>Accessing Array Elements</h3>
    <p>
        You can access elements of an array using the index. Array indices in Java start from 0, so the first element is at index 0, the second at index 1, and so on.
    </p>
    <pre>
        <code>
            int[] numbers = {1, 2, 3, 4, 5};
            System.out.println(numbers[0]); // Output: 1
            System.out.println(numbers[3]); // Output: 4
        </code>
    </pre>

    <h3>Array Length</h3>
    <p>
        You can obtain the length of an array using the <code>length</code> property, which returns the number of elements in the array.
    </p>
    <pre>
        <code>
            int[] numbers = {1, 2, 3, 4, 5};
            System.out.println("Length of the array: " + numbers.length); // Output: 5
        </code>
    </pre>

    <h3>Multidimensional Arrays</h3>
    <p>
        Java also supports multidimensional arrays, which are arrays of arrays. A common type is the two-dimensional array, which is often used to represent matrices or grids.
    </p>
    <pre>
        <code>
            int[][] matrix = {
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9}
            };
            System.out.println(matrix[1][1]); // Output: 5
        </code>
    </pre>

    <h3>Array Iteration</h3>
    <p>
        You can iterate through an array using a <code>for</code> loop or an enhanced <code>for</code> loop (also known as a "for-each" loop) to process all its elements.
    </p>
    <pre>
        <code>
            int[] numbers = {1, 2, 3, 4, 5};
            
            // Using regular for loop
            for (int i = 0; i < numbers.length; i++) {
                System.out.println(numbers[i]);
            }

            // Using enhanced for loop (for-each loop)
            for (int number : numbers) {
                System.out.println(number);
            }
        </code>
    </pre>

    <h3>Common Array Operations</h3>
    <ul>
        <li><strong>Copying an Array:</strong> You can copy an array using methods like <code>System.arraycopy()</code> or <code>Arrays.copyOf()</code>.</li>
        <li><strong>Sorting an Array:</strong> The <code>Arrays.sort()</code> method can be used to sort arrays in ascending order.</li>
        <li><strong>Searching in an Array:</strong> You can use <code>Arrays.binarySearch()</code> to search for an element in a sorted array.</li>
    </ul>

    <h3>Example: Copying, Sorting, and Searching</h3>
    <pre>
        <code>
            int[] numbers = {5, 3, 8, 1, 4};

            // Copying the array
            int[] copiedArray = Arrays.copyOf(numbers, numbers.length);
            
            // Sorting the array
            Arrays.sort(copiedArray);

            // Searching for an element
            int index = Arrays.binarySearch(copiedArray, 4); // Output: 2

            System.out.println("Index of 4: " + index);
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        Arrays in Java are a powerful tool for storing and manipulating collections of data. By understanding how to declare, initialize, access, and manipulate arrays, you can efficiently work with large amounts of data in your programs.
    </p>
</div>

<!-- OOP Concepts -->
<div class="main" id="oop-concepts">
    <h1>OOP Concepts</h1>

    <h3>Introduction</h3>
    <p>
        Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects," which are instances of classes. OOP allows for better organization of code, reusability, and modularity. The four fundamental OOP concepts are Encapsulation, Inheritance, Polymorphism, and Abstraction.
    </p>

    <h3>1. Encapsulation</h3>
    <p>
        Encapsulation is the concept of wrapping data (variables) and code (methods) together as a single unit. This helps in restricting access to certain details of an object's implementation and protecting the internal state from unwanted modifications.
    </p>
    <p>
        In Java, encapsulation is achieved using <code>private</code> variables and <code>public</code> getter and setter methods.
    </p>
    <pre>
        <code>
            public class Person {
                private String name;  // private variable

                // Getter method
                public String getName() {
                    return name;
                }

                // Setter method
                public void setName(String name) {
                    this.name = name;
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>name</code> variable is encapsulated and accessed through the getter and setter methods.
    </p>

    <h3>2. Inheritance</h3>
    <p>
        Inheritance is a mechanism in Java that allows a class to inherit properties and behaviors (fields and methods) from another class. This promotes code reuse and helps in creating hierarchical relationships between classes.
    </p>
    <p>
        In Java, inheritance is implemented using the <code>extends</code> keyword.
    </p>
    <pre>
        <code>
            // Parent class
            public class Animal {
                public void sound() {
                    System.out.println("Animal makes a sound");
                }
            }

            // Child class inheriting Animal class
            public class Dog extends Animal {
                public void sound() {
                    System.out.println("Dog barks");
                }
            }

            public class TestInheritance {
                public static void main(String[] args) {
                    Dog dog = new Dog();
                    dog.sound();  // Output: Dog barks
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>Dog</code> class inherits the <code>sound()</code> method from the <code>Animal</code> class and overrides it to provide its own implementation.
    </p>

    <h3>3. Polymorphism</h3>
    <p>
        Polymorphism is the ability of a single function, method, or operator to work in different ways depending on the context. There are two types of polymorphism in Java: compile-time (method overloading) and runtime (method overriding).
    </p>
    
    <h4>Method Overloading (Compile-time Polymorphism)</h4>
    <p>
        Method overloading allows you to define multiple methods with the same name but different parameter lists.
    </p>
    <pre>
        <code>
            public class MathOperations {
                public int add(int a, int b) {
                    return a + b;
                }

                public double add(double a, double b) {
                    return a + b;
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>add</code> method is overloaded to accept either integers or doubles.
    </p>

    <h4>Method Overriding (Runtime Polymorphism)</h4>
    <p>
        Method overriding occurs when a subclass provides a specific implementation of a method already defined in its superclass.
    </p>
    <pre>
        <code>
            // Parent class
            public class Animal {
                public void sound() {
                    System.out.println("Animal makes a sound");
                }
            }

            // Child class
            public class Dog extends Animal {
                @Override
                public void sound() {
                    System.out.println("Dog barks");
                }
            }

            public class TestPolymorphism {
                public static void main(String[] args) {
                    Animal animal = new Dog();
                    animal.sound();  // Output: Dog barks
                }
            }
        </code>
    </pre>
    <p>
        In this example, method overriding is used to provide a specific implementation of the <code>sound()</code> method in the <code>Dog</code> class, even though the reference type is <code>Animal</code>.
    </p>

    <h3>4. Abstraction</h3>
    <p>
        Abstraction is the concept of hiding the complex implementation details and showing only the necessary features of an object. In Java, abstraction is achieved using abstract classes and interfaces.
    </p>
    
    <h4>Abstract Classes</h4>
    <p>
        An abstract class is a class that cannot be instantiated on its own. It may have abstract methods (methods without implementation) that must be implemented by subclasses.
    </p>
    <pre>
        <code>
            abstract class Animal {
                abstract void sound();  // Abstract method

                public void eat() {
                    System.out.println("This animal eats food");
                }
            }

            class Dog extends Animal {
                public void sound() {
                    System.out.println("Dog barks");
                }
            }
        </code>
    </pre>
    <p>
        Here, the <code>sound()</code> method is abstract, and the <code>Dog</code> class provides its own implementation.
    </p>

    <h4>Interfaces</h4>
    <p>
        An interface in Java is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. It cannot contain instance fields or constructors.
    </p>
    <pre>
        <code>
            interface Animal {
                void sound();  // Abstract method
            }

            class Dog implements Animal {
                public void sound() {
                    System.out.println("Dog barks");
                }
            }
        </code>
    </pre>
    <p>
        The <code>Dog</code> class implements the <code>Animal</code> interface and provides its own implementation of the <code>sound()</code> method.
    </p>

    <h3>Summary</h3>
    <p>
        OOP concepts like Encapsulation, Inheritance, Polymorphism, and Abstraction form the foundation of Java programming. These principles allow for cleaner, more modular, and reusable code, making it easier to manage and scale applications.
    </p>
</div>

<!-- Classes and Objects -->
<div class="main" id="classes-objects">
    <h1>Classes and Objects</h1>

    <h3>Introduction</h3>
    <p>
        In Java, a class is a blueprint for creating objects. It defines the properties and behaviors that the objects created from the class will have. An object is an instance of a class, which means it is a specific realization of the class with actual values assigned to its properties.
    </p>

    <h3>What is a Class?</h3>
    <p>
        A class in Java is a template or blueprint for creating objects. It contains fields (variables) and methods (functions) that define the attributes and behaviors of the objects. A class can have multiple constructors, fields, and methods.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Car {
                // Fields
                String model;
                int year;

                // Constructor
                public Car(String model, int year) {
                    this.model = model;
                    this.year = year;
                }

                // Method
                public void displayDetails() {
                    System.out.println("Car Model: " + model + ", Year: " + year);
                }
            }
        </code>
    </pre>
    <p>
        In the above example, <code>Car</code> is a class with two fields: <code>model</code> and <code>year</code>. The constructor initializes these fields, and the <code>displayDetails</code> method prints the car details.
    </p>

    <h3>What is an Object?</h3>
    <p>
        An object is an instance of a class. When a class is defined, no memory is allocated. Memory is allocated only when an object of that class is created. Objects have their own unique set of data and can access the methods of the class they belong to.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class TestCar {
                public static void main(String[] args) {
                    // Creating an object of Car class
                    Car myCar = new Car("Toyota", 2022);

                    // Accessing the object's method
                    myCar.displayDetails();  // Output: Car Model: Toyota, Year: 2022
                }
            }
        </code>
    </pre>
    <p>
        In the <code>TestCar</code> class, we create an object of the <code>Car</code> class and call its <code>displayDetails</code> method to print the car's details.
    </p>

    <h3>Access Modifiers in Classes</h3>
    <p>
        Java uses access modifiers to control the visibility of fields and methods within classes. The common access modifiers are:
    </p>
    <ul>
        <li><strong>public:</strong> The field or method is accessible from anywhere.</li>
        <li><strong>private:</strong> The field or method is accessible only within the same class.</li>
        <li><strong>protected:</strong> The field or method is accessible within the same package or subclasses.</li>
        <li><strong>default (no modifier):</strong> The field or method is accessible only within the same package.</li>
    </ul>

    <h3>Constructors</h3>
    <p>
        A constructor is a special method used to initialize objects. It has the same name as the class and does not have a return type. Constructors are used to set initial values for object attributes.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Person {
                String name;
                int age;

                // Constructor
                public Person(String name, int age) {
                    this.name = name;
                    this.age = age;
                }
            }

            public class TestPerson {
                public static void main(String[] args) {
                    Person person1 = new Person("Alice", 30);
                    System.out.println(person1.name);  // Output: Alice
                    System.out.println(person1.age);   // Output: 30
                }
            }
        </code>
    </pre>
    <p>
        In the above example, the <code>Person</code> class has a constructor that initializes the <code>name</code> and <code>age</code> fields. When an object is created using the constructor, it initializes those fields with the provided values.
    </p>

    <h3>Methods in Classes</h3>
    <p>
        A method is a function defined within a class. It describes the behavior of the objects created from that class. Methods can perform actions, return values, and accept parameters.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Calculator {
                // Method to add two numbers
                public int add(int a, int b) {
                    return a + b;
                }

                // Method to subtract two numbers
                public int subtract(int a, int b) {
                    return a - b;
                }
            }

            public class TestCalculator {
                public static void main(String[] args) {
                    Calculator calc = new Calculator();
                    System.out.println(calc.add(5, 3));  // Output: 8
                    System.out.println(calc.subtract(5, 3));  // Output: 2
                }
            }
        </code>
    </pre>
    <p>
        The <code>Calculator</code> class defines two methods: <code>add</code> and <code>subtract</code>. These methods are called on an object of the <code>Calculator</code> class to perform the respective operations.
    </p>

    <h3>Summary</h3>
    <p>
        Classes and objects are the foundation of Java programming. A class defines the blueprint, while objects are instances of that blueprint. Constructors initialize objects, and methods define their behavior. Understanding classes and objects is crucial for writing effective Java programs.
    </p>
</div>

<!-- Inheritance -->
<div class="main" id="inheritance">
    <h1>Inheritance</h1>

    <h3>Introduction</h3>
    <p>
        Inheritance is one of the fundamental concepts in Object-Oriented Programming (OOP). It allows a class to inherit properties and behaviors (methods) from another class. The class that is inherited from is called the superclass or parent class, while the class that inherits is called the subclass or child class.
    </p>

    <h3>How Inheritance Works</h3>
    <p>
        When a subclass inherits from a superclass, it gains access to all the non-private fields and methods of the superclass. This allows the subclass to reuse code from the parent class and even modify or extend it to meet specific requirements.
    </p>

    <h3>Syntax of Inheritance</h3>
    <p>
        To create a subclass, you use the <code>extends</code> keyword. The subclass inherits the features of the superclass, and can also have its own fields and methods.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            // Superclass
            public class Animal {
                String name;

                // Constructor
                public Animal(String name) {
                    this.name = name;
                }

                // Method
                public void speak() {
                    System.out.println(name + " makes a sound");
                }
            }

            // Subclass
            public class Dog extends Animal {
                public Dog(String name) {
                    super(name);
                }

                // Overriding the speak method
                @Override
                public void speak() {
                    System.out.println(name + " barks");
                }
            }

            public class TestInheritance {
                public static void main(String[] args) {
                    Dog dog = new Dog("Buddy");
                    dog.speak();  // Output: Buddy barks
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>Dog</code> class inherits from the <code>Animal</code> class. It uses the <code>super</code> keyword to call the constructor of the parent class, and overrides the <code>speak</code> method to provide a specific implementation for dogs.
    </p>

    <h3>Method Overriding</h3>
    <p>
        Method overriding allows a subclass to provide its own implementation of a method that is already defined in the superclass. To override a method, the subclass defines the method with the same signature as the superclass method.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            // Superclass
            public class Animal {
                public void speak() {
                    System.out.println("The animal speaks");
                }
            }

            // Subclass
            public class Cat extends Animal {
                @Override
                public void speak() {
                    System.out.println("The cat meows");
                }
            }

            public class TestOverriding {
                public static void main(String[] args) {
                    Animal myCat = new Cat();
                    myCat.speak();  // Output: The cat meows
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>Cat</code> class overrides the <code>speak</code> method of the <code>Animal</code> class, providing a custom implementation for the cat's behavior.
    </p>

    <h3>Accessing Parent Class Methods and Constructors</h3>
    <p>
        The subclass can access the parent class methods and constructors using the <code>super</code> keyword. The <code>super()</code> call is used to invoke the constructor of the parent class, and <code>super.methodName()</code> is used to call the parent class's method.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            // Superclass
            public class Animal {
                String name;

                public Animal(String name) {
                    this.name = name;
                }

                public void speak() {
                    System.out.println(name + " speaks");
                }
            }

            // Subclass
            public class Bird extends Animal {
                public Bird(String name) {
                    super(name);  // Calling the superclass constructor
                }

                public void fly() {
                    System.out.println(name + " is flying");
                }
            }

            public class TestSuper {
                public static void main(String[] args) {
                    Bird bird = new Bird("Parrot");
                    bird.speak();  // Output: Parrot speaks
                    bird.fly();    // Output: Parrot is flying
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>Bird</code> class calls the <code>super(name)</code> constructor to initialize the <code>name</code> field of the <code>Animal</code> class.
    </p>

    <h3>Types of Inheritance</h3>
    <p>
        There are several types of inheritance in Java:
    </p>
    <ul>
        <li><strong>Single Inheritance:</strong> A subclass inherits from only one superclass (as shown in the examples above).</li>
        <li><strong>Multilevel Inheritance:</strong> A class inherits from another class, which is itself a subclass of another class.</li>
        <li><strong>Hierarchical Inheritance:</strong> Multiple subclasses inherit from the same superclass.</li>
        <li><strong>Multiple Inheritance (not supported in Java):</strong> A subclass inherits from more than one superclass. (This is not allowed in Java, but can be achieved using interfaces.)</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Inheritance is a core concept in OOP that promotes code reuse and improves code maintainability. By using inheritance, classes can share common behavior and attributes while allowing for more specific behavior in subclasses. This makes it easier to build and extend object-oriented programs.
    </p>
</div>

<!-- Polymorphism -->
<div class="main" id="polymorphism">
    <h1>Polymorphism</h1>

    <h3>Introduction</h3>
    <p>
        Polymorphism is a core concept in Object-Oriented Programming (OOP) that allows objects of different classes to be treated as objects of a common superclass. It enables a single method or function to work with different types of objects, providing flexibility in your code.
    </p>

    <h3>Types of Polymorphism</h3>
    <p>
        There are two types of polymorphism in Java:
    </p>
    <ul>
        <li><strong>Compile-time Polymorphism (Static Binding):</strong> This type of polymorphism is resolved during compile time. It occurs when multiple methods have the same name but differ in parameters (method overloading).</li>
        <li><strong>Runtime Polymorphism (Dynamic Binding):</strong> This type of polymorphism is resolved during runtime. It occurs when a method in a subclass overrides a method in the superclass (method overriding).</li>
    </ul>

    <h3>Compile-Time Polymorphism (Method Overloading)</h3>
    <p>
        Method overloading allows a class to have more than one method with the same name, but different parameters. The correct method is selected at compile time based on the method signature.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Calculator {
                // Method to add two integers
                public int add(int a, int b) {
                    return a + b;
                }

                // Overloaded method to add three integers
                public int add(int a, int b, int c) {
                    return a + b + c;
                }

                public static void main(String[] args) {
                    Calculator calc = new Calculator();
                    System.out.println(calc.add(5, 10));   // Output: 15
                    System.out.println(calc.add(5, 10, 15)); // Output: 30
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>Calculator</code> class has two overloaded <code>add</code> methods. One adds two integers, and the other adds three integers.
    </p>

    <h3>Runtime Polymorphism (Method Overriding)</h3>
    <p>
        Method overriding occurs when a subclass provides a specific implementation for a method that is already defined in its superclass. The overridden method is called at runtime, allowing the subclass to define its own behavior.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            // Superclass
            public class Animal {
                public void speak() {
                    System.out.println("The animal makes a sound");
                }
            }

            // Subclass
            public class Dog extends Animal {
                @Override
                public void speak() {
                    System.out.println("The dog barks");
                }
            }

            public class TestPolymorphism {
                public static void main(String[] args) {
                    Animal myAnimal = new Animal();
                    Animal myDog = new Dog();

                    myAnimal.speak();  // Output: The animal makes a sound
                    myDog.speak();     // Output: The dog barks
                }
            }
        </code>
    </pre>
    <p>
        In this example, both the <code>Animal</code> and <code>Dog</code> classes have a <code>speak</code> method. The <code>Dog</code> class overrides the <code>speak</code> method. At runtime, when <code>myDog.speak()</code> is called, it executes the overridden method in the <code>Dog</code> class, not the one in the <code>Animal</code> class.
    </p>

    <h3>Polymorphism and Method Overriding with Inheritance</h3>
    <p>
        Polymorphism works seamlessly with inheritance, allowing objects of subclasses to be treated as objects of their superclass, and the appropriate method is called based on the object type at runtime.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            // Superclass
            public class Animal {
                public void sound() {
                    System.out.println("Animal makes a sound");
                }
            }

            // Subclass
            public class Cat extends Animal {
                @Override
                public void sound() {
                    System.out.println("Cat meows");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Animal myAnimal = new Animal(); // Parent class object
                    Animal myCat = new Cat();        // Child class object

                    myAnimal.sound();  // Output: Animal makes a sound
                    myCat.sound();     // Output: Cat meows
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>sound</code> method is overridden in the <code>Cat</code> class. Even though the reference variable is of type <code>Animal</code>, the actual object is of type <code>Cat</code>, so the <code>Cat</code> version of <code>sound</code> is called.
    </p>

    <h3>Advantages of Polymorphism</h3>
    <ul>
        <li><strong>Code Reusability:</strong> Polymorphism allows methods to be reused in different classes, reducing the need for code duplication.</li>
        <li><strong>Flexibility:</strong> Polymorphism provides flexibility in method and class design, as you can write code that works with objects of various types.</li>
        <li><strong>Maintainability:</strong> Polymorphism allows changes to be made to the code with minimal impact on other parts of the application.</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Polymorphism is a powerful concept in OOP that allows objects of different types to be treated uniformly. It promotes code flexibility, reusability, and maintainability. By using method overloading and method overriding, you can create dynamic and efficient code that adapts to different situations.
    </p>
</div>

<!-- Encapsulation -->
<div class="main" id="encapsulation">
    <h1>Encapsulation</h1>

    <h3>Introduction</h3>
    <p>
        Encapsulation is one of the four fundamental OOP concepts. It refers to the bundling of data (variables) and methods that operate on the data into a single unit, i.e., a class. Encapsulation allows you to control access to the data and ensure the integrity of the object.
    </p>

    <h3>Why is Encapsulation Important?</h3>
    <p>
        Encapsulation helps to:
    </p>
    <ul>
        <li>Protect the object's state by restricting access to its fields.</li>
        <li>Allow controlled access to the object's data via getter and setter methods.</li>
        <li>Reduce complexity and increase reusability of code.</li>
    </ul>

    <h3>Access Modifiers in Encapsulation</h3>
    <p>
        Java uses access modifiers to enforce encapsulation and control the visibility of class members. The main access modifiers are:
    </p>
    <ul>
        <li><strong>private:</strong> Restricts access to the class itself.</li>
        <li><strong>protected:</strong> Allows access within the same package or subclasses.</li>
        <li><strong>public:</strong> Grants access from any class.</li>
        <li><strong>default:</strong> No modifier. Access is limited to the same package.</li>
    </ul>

    <h3>Example</h3>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            class Person {
                // Private fields
                private String name;
                private int age;

                // Getter and Setter for name
                public String getName() {
                    return name;
                }

                public void setName(String name) {
                    this.name = name;
                }

                // Getter and Setter for age
                public int getAge() {
                    return age;
                }

                public void setAge(int age) {
                    if (age > 0) {
                        this.age = age;
                    }
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Person person = new Person();
                    person.setName("John");
                    person.setAge(25);

                    System.out.println(person.getName()); // Output: John
                    System.out.println(person.getAge());  // Output: 25
                }
            }
        </code>
    </pre>

    <h3>Explanation</h3>
    <p>
        In this example, the <code>Person</code> class has private fields <code>name</code> and <code>age</code>, making them inaccessible from outside the class. To access or modify these fields, we use public getter and setter methods. This provides controlled access to the fields and ensures that the <code>age</code> value cannot be set to a negative number.
    </p>

    <h3>Best Practices</h3>
    <ul>
        <li>Always keep fields private and provide getter and setter methods for controlled access.</li>
        <li>Use getter and setter methods to enforce validation (e.g., ensuring that the <code>age</code> is positive).</li>
        <li>Minimize the exposure of implementation details by hiding internal logic and exposing only necessary functionality.</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Encapsulation is a core concept in Java that helps protect data and maintain the integrity of objects. By using access modifiers and getter/setter methods, you can control how the data is accessed and modified, thus ensuring better maintainability and security in your code.
    </p>
</div>

<!-- Abstraction -->
<div class="main" id="abstraction">
    <h1>Abstraction</h1>

    <h3>Introduction</h3>
    <p>
        Abstraction is one of the key concepts of Object-Oriented Programming (OOP). It refers to the concept of hiding the complex implementation details and exposing only the necessary and relevant parts of an object. The goal of abstraction is to reduce complexity and allow the programmer to focus on high-level functionality.
    </p>

    <h3>Why is Abstraction Important?</h3>
    <p>
        Abstraction helps to:
    </p>
    <ul>
        <li>Hide unnecessary implementation details from the user.</li>
        <li>Allow focusing on high-level functionality.</li>
        <li>Increase code reusability and flexibility.</li>
        <li>Improve security by hiding sensitive data and operations.</li>
    </ul>

    <h3>Types of Abstraction</h3>
    <p>
        There are two ways to achieve abstraction in Java:
    </p>
    <ul>
        <li><strong>Abstract Classes:</strong> A class that cannot be instantiated on its own but can be subclassed. It can have abstract methods (methods without a body) and non-abstract methods (methods with a body).</li>
        <li><strong>Interfaces:</strong> An interface defines a contract that classes can implement. It can only have abstract methods and constants (in older versions of Java). In modern versions of Java, interfaces can also have default and static methods.</li>
    </ul>

    <h3>Example of Abstraction using Abstract Class</h3>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            abstract class Animal {
                // Abstract method (does not have a body)
                public abstract void sound();

                // Regular method
                public void sleep() {
                    System.out.println("The animal is sleeping");
                }
            }

            class Dog extends Animal {
                // Implement the abstract method
                public void sound() {
                    System.out.println("Bark");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Dog dog = new Dog();
                    dog.sound(); // Output: Bark
                    dog.sleep(); // Output: The animal is sleeping
                }
            }
        </code>
    </pre>

    <h3>Explanation</h3>
    <p>
        In this example, the <code>Animal</code> class is abstract and has an abstract method <code>sound()</code>, which doesn't have an implementation. The <code>Dog</code> class extends the <code>Animal</code> class and provides its own implementation of the <code>sound()</code> method. The <code>sleep()</code> method is inherited from the <code>Animal</code> class and can be used directly in the <code>Dog</code> class.
    </p>

    <h3>Example of Abstraction using Interface</h3>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            interface Animal {
                // Abstract method (no body)
                void sound();

                // Default method (introduced in Java 8)
                default void sleep() {
                    System.out.println("The animal is sleeping");
                }
            }

            class Dog implements Animal {
                // Implement the abstract method
                public void sound() {
                    System.out.println("Bark");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Dog dog = new Dog();
                    dog.sound(); // Output: Bark
                    dog.sleep(); // Output: The animal is sleeping
                }
            }
        </code>
    </pre>

    <h3>Explanation</h3>
    <p>
        In this example, the <code>Animal</code> interface defines the <code>sound()</code> method, which the <code>Dog</code> class implements. The <code>sleep()</code> method in the interface is a default method, meaning it has a body and can be directly used by the implementing class without being overridden.
    </p>

    <h3>Best Practices</h3>
    <ul>
        <li>Use abstract classes when you have common functionality to be shared by all subclasses.</li>
        <li>Use interfaces when you want to define a contract for classes that can be implemented by multiple unrelated classes.</li>
        <li>Keep interfaces focused on one responsibility (i.e., one task or feature).</li>
        <li>Always favor composition over inheritance where applicable, especially when dealing with interfaces.</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Abstraction is a core principle in Java that allows developers to design more maintainable and reusable code by hiding implementation details and exposing only necessary functionalities. By using abstract classes and interfaces, Java enables cleaner code design, flexibility, and security.
    </p>
</div>

<!-- Collections Framework -->
<div class="main" id="collections">
    <h1>Collections Framework</h1>

    <h3>Introduction</h3>
    <p>
        The Collections Framework in Java provides a set of classes and interfaces that implement commonly used collection data structures. It allows developers to store, retrieve, and manipulate data in various ways, such as in lists, sets, maps, and queues. The framework is part of the java.util package.
    </p>

    <h3>Why Use Collections Framework?</h3>
    <p>
        The Collections Framework simplifies the development process by providing well-tested, optimized implementations for different types of collections. It eliminates the need for manually handling data structures, making it easier to manipulate and access data.
    </p>

    <h3>Core Interfaces</h3>
    <p>
        The core interfaces of the Collections Framework define the basic operations for various types of collections:
    </p>
    <ul>
        <li><strong>Collection:</strong> The root interface for all collection types, such as lists, sets, and queues.</li>
        <li><strong>List:</strong> An ordered collection that allows duplicate elements. Implements methods to access elements by index (e.g., ArrayList, LinkedList).</li>
        <li><strong>Set:</strong> A collection that does not allow duplicate elements (e.g., HashSet, TreeSet).</li>
        <li><strong>Map:</strong> A collection that maps keys to values (e.g., HashMap, TreeMap).</li>
        <li><strong>Queue:</strong> A collection designed for holding elements prior to processing (e.g., LinkedList, PriorityQueue).</li>
    </ul>

    <h3>Important Classes</h3>
    <ul>
        <li><strong>ArrayList:</strong> A resizable array implementation of the List interface. It allows fast access to elements but has slower insertion and deletion compared to LinkedList.</li>
        <li><strong>LinkedList:</strong> A doubly linked list implementation of the List interface. It allows efficient insertions and deletions but slower access to elements compared to ArrayList.</li>
        <li><strong>HashSet:</strong> An implementation of the Set interface that does not allow duplicate elements and has no specific order.</li>
        <li><strong>TreeSet:</strong> A NavigableSet implementation that stores elements in a sorted order (according to their natural ordering or a comparator).</li>
        <li><strong>HashMap:</strong> A map implementation that stores key-value pairs, with fast retrieval based on keys.</li>
        <li><strong>TreeMap:</strong> A map implementation that stores key-value pairs in sorted order based on the keys.</li>
    </ul>

    <h3>Example of Using ArrayList</h3>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.util.ArrayList;

            public class Main {
                public static void main(String[] args) {
                    // Create an ArrayList
                    ArrayList<String> list = new ArrayList<>();
                    
                    // Add elements to the list
                    list.add("Apple");
                    list.add("Banana");
                    list.add("Cherry");

                    // Display the elements
                    System.out.println(list);  // Output: [Apple, Banana, Cherry]
                }
            }
        </code>
    </pre>

    <h3>Example of Using HashSet</h3>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.util.HashSet;

            public class Main {
                public static void main(String[] args) {
                    // Create a HashSet
                    HashSet<String> set = new HashSet<>();
                    
                    // Add elements to the set
                    set.add("Apple");
                    set.add("Banana");
                    set.add("Cherry");

                    // Try adding a duplicate element
                    set.add("Apple");

                    // Display the elements
                    System.out.println(set);  // Output: [Apple, Banana, Cherry]
                }
            }
        </code>
    </pre>

    <h3>Example of Using HashMap</h3>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.util.HashMap;

            public class Main {
                public static void main(String[] args) {
                    // Create a HashMap
                    HashMap<String, String> map = new HashMap<>();
                    
                    // Add key-value pairs to the map
                    map.put("1", "Apple");
                    map.put("2", "Banana");
                    map.put("3", "Cherry");

                    // Display the elements
                    System.out.println(map);  // Output: {1=Apple, 2=Banana, 3=Cherry}
                }
            }
        </code>
    </pre>

    <h3>Operations on Collections</h3>
    <p>
        Common operations that can be performed on collections include:
    </p>
    <ul>
        <li><strong>Adding elements:</strong> Use <code>add()</code> (for Set, List) or <code>put()</code> (for Map).</li>
        <li><strong>Removing elements:</strong> Use <code>remove()</code>.</li>
        <li><strong>Accessing elements:</strong> Use <code>get()</code> for List and Map, or use an iterator for Set.</li>
        <li><strong>Iteration:</strong> Collections can be iterated using loops or iterators.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Choose the right collection type based on the use case (e.g., use List for ordered elements, use Set for unique elements, use Map for key-value pairs).</li>
        <li>Use <code>ArrayList</code> for fast access to elements by index, and <code>LinkedList</code> for frequent insertions and deletions.</li>
        <li>Consider using <code>HashMap</code> or <code>TreeMap</code> for fast lookups by key.</li>
        <li>Ensure proper exception handling (e.g., checking for <code>NullPointerException</code> when accessing elements).</li>
    </ul>

    <h3>Summary</h3>
    <p>
        The Collections Framework in Java provides a unified architecture for working with different types of collections. By leveraging classes like ArrayList, HashSet, and HashMap, developers can easily manage and manipulate data efficiently and effectively.
    </p>
</div>

<!-- Generics -->
<div class="main" id="generics">
    <h1>Generics</h1>

    <h3>Introduction</h3>
    <p>
        Generics allow you to write flexible, reusable, and type-safe code. By using generics, you can ensure that a class, interface, or method works with any data type, while also maintaining type safety and avoiding runtime errors.
    </p>

    <h3>Why Use Generics?</h3>
    <p>
        The main advantage of using generics is that they enable code to be written without losing type safety. Without generics, you may need to cast objects, which can lead to <code>ClassCastException</code> at runtime. With generics, you specify the type of data upfront, allowing for compile-time type checking and reducing errors.
    </p>

    <h3>Generic Classes</h3>
    <p>
        A generic class is a class that can operate on objects of various types while providing compile-time type safety. Here's the syntax for defining a generic class:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Box<T> {
                private T value;
                
                // Setter
                public void set(T value) {
                    this.value = value;
                }
                
                // Getter
                public T get() {
                    return value;
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>Box</code> class is a generic class that can hold any type of object. The type <code>T</code> is a placeholder, and you can substitute it with a specific type when creating an object of <code>Box</code>.
    </p>

    <h3>Using Generic Classes</h3>
    <p>
        Here's how to use the <code>Box</code> class with different data types:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Main {
                public static void main(String[] args) {
                    // Create a Box for Integer
                    Box<Integer> integerBox = new Box<>();
                    integerBox.set(10);
                    System.out.println("Integer Value: " + integerBox.get());

                    // Create a Box for String
                    Box<String> stringBox = new Box<>();
                    stringBox.set("Hello, World!");
                    System.out.println("String Value: " + stringBox.get());
                }
            }
        </code>
    </pre>
    <p>
        In the above example, <code>integerBox</code> holds an <code>Integer</code>, and <code>stringBox</code> holds a <code>String</code>. The same generic class is used for different types.
    </p>

    <h3>Generic Methods</h3>
    <p>
        You can also define generic methods that work with different types. Here's an example of a generic method:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Main {
                // Generic method to print an array of any type
                public static <T> void printArray(T[] array) {
                    for (T element : array) {
                        System.out.println(element);
                    }
                }
                
                public static void main(String[] args) {
                    Integer[] intArray = {1, 2, 3, 4};
                    String[] strArray = {"Apple", "Banana", "Cherry"};

                    printArray(intArray);  // Calls with Integer array
                    printArray(strArray);  // Calls with String array
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>printArray</code> method is a generic method that accepts an array of any type and prints its elements.
    </p>

    <h3>Bounded Type Parameters</h3>
    <p>
        Sometimes, you may want to restrict the types that can be used as type parameters. You can do this using bounded type parameters. For example, you can limit the type to a subclass of a particular class:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            // Only allows types that are subclasses of Number (e.g., Integer, Double)
            public class NumericBox<T extends Number> {
                private T value;
                
                public void set(T value) {
                    this.value = value;
                }
                
                public T get() {
                    return value;
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>NumericBox</code> class only accepts types that extend <code>Number</code>, such as <code>Integer</code> or <code>Double</code>.
    </p>

    <h3>Wildcard in Generics</h3>
    <p>
        The wildcard <code>?</code> allows you to specify an unknown type in generic methods and classes. Wildcards are often used when you don’t care about the specific type, but you want to restrict the range of types.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class Main {
                public static void printList(List<?> list) {
                    for (Object item : list) {
                        System.out.println(item);
                    }
                }
                
                public static void main(String[] args) {
                    List<Integer> intList = Arrays.asList(1, 2, 3, 4);
                    List<String> strList = Arrays.asList("Apple", "Banana", "Cherry");

                    printList(intList);  // Works with Integer list
                    printList(strList);  // Works with String list
                }
            }
        </code>
    </pre>
    <p>
        In this example, the <code>printList</code> method can accept any type of list using the wildcard <code>?</code>.
    </p>

    <h3>Summary</h3>
    <p>
        Generics provide a way to write flexible and type-safe code in Java. By using generic classes and methods, you can create reusable code that works with any data type, ensuring compile-time type safety and avoiding runtime errors.
    </p>
</div>

<!-- Streams and File Handling -->
<div class="main" id="streams">
    <h1>Streams and File Handling</h1>

    <h3>Introduction</h3>
    <p>
        In Java, streams provide a way to read and write data to files and other I/O (input/output) devices. Java provides various classes for handling files and streams, such as <code>FileInputStream</code>, <code>FileOutputStream</code>, and higher-level stream classes like <code>BufferedReader</code> and <code>BufferedWriter</code>.
    </p>

    <h3>Types of Streams</h3>
    <p>
        There are two main types of streams in Java:
    </p>
    <ul>
        <li><strong>Byte Streams:</strong> Handle raw binary data, such as <code>FileInputStream</code> and <code>FileOutputStream</code>.</li>
        <li><strong>Character Streams:</strong> Handle data in character form, such as <code>FileReader</code> and <code>FileWriter</code>.</li>
    </ul>

    <h3>Byte Streams</h3>
    <p>
        Byte streams are used for reading and writing binary data. The following are the most common byte stream classes:
    </p>
    <ul>
        <li><code>FileInputStream:</code> Used to read bytes from a file.</li>
        <li><code>FileOutputStream:</code> Used to write bytes to a file.</li>
    </ul>
    <h4>Example of FileInputStream and FileOutputStream:</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.io.*;

            public class ByteStreamExample {
                public static void main(String[] args) {
                    try (FileInputStream in = new FileInputStream("input.txt");
                         FileOutputStream out = new FileOutputStream("output.txt")) {

                        int byteData;
                        while ((byteData = in.read()) != -1) {
                            out.write(byteData);
                        }
                        System.out.println("File copied successfully.");
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        In this example, the contents of the file <code>input.txt</code> are read byte by byte and written to <code>output.txt</code>.
    </p>

    <h3>Character Streams</h3>
    <p>
        Character streams are used for reading and writing characters. The following are common character stream classes:
    </p>
    <ul>
        <li><code>FileReader:</code> Used to read characters from a file.</li>
        <li><code>FileWriter:</code> Used to write characters to a file.</li>
    </ul>
    <h4>Example of FileReader and FileWriter:</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.io.*;

            public class CharStreamExample {
                public static void main(String[] args) {
                    try (FileReader reader = new FileReader("input.txt");
                         FileWriter writer = new FileWriter("output.txt")) {

                        int charData;
                        while ((charData = reader.read()) != -1) {
                            writer.write(charData);
                        }
                        System.out.println("File copied successfully.");
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        This example copies the contents of <code>input.txt</code> to <code>output.txt</code> using character streams.
    </p>

    <h3>Buffered Streams</h3>
    <p>
        Buffered streams provide a performance improvement by reading or writing data in larger chunks rather than one byte or character at a time. For example, the <code>BufferedReader</code> and <code>BufferedWriter</code> classes are used to read and write text data efficiently.
    </p>
    <h4>Example of BufferedReader and BufferedWriter:</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.io.*;

            public class BufferedStreamExample {
                public static void main(String[] args) {
                    try (BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
                         BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {

                        String line;
                        while ((line = reader.readLine()) != null) {
                            writer.write(line);
                            writer.newLine();
                        }
                        System.out.println("File copied successfully.");
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        The example above reads each line from the file <code>input.txt</code> and writes it to <code>output.txt</code> using buffered streams.
    </p>

    <h3>Java NIO (New I/O)</h3>
    <p>
        Java NIO is an advanced I/O package that was introduced in Java 7. It provides a more efficient way of handling I/O operations, such as file operations and byte buffer manipulation. NIO includes the <code>Path</code>, <code>Files</code>, and <code>ByteBuffer</code> classes.
    </p>
    <h4>Example using NIO for File Copy:</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.nio.file.*;

            public class NIOExample {
                public static void main(String[] args) {
                    try {
                        Path source = Paths.get("input.txt");
                        Path destination = Paths.get("output.txt");

                        Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
                        System.out.println("File copied successfully using NIO.");
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        This example demonstrates how to copy a file using Java NIO, which simplifies the file copy process with less code.
    </p>

    <h3>File Handling Best Practices</h3>
    <ul>
        <li>Always close your streams using <code>try-with-resources</code> to ensure they are automatically closed.</li>
        <li>Use buffered streams for better performance when reading or writing large files.</li>
        <li>Handle exceptions, such as <code>FileNotFoundException</code> and <code>IOException</code>, to prevent program crashes.</li>
        <li>For NIO, use <code>Files</code> class for common file operations to simplify your code.</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Java provides various tools for handling file I/O, including byte and character streams, buffered streams, and the newer NIO package. By choosing the right type of stream and understanding how to use them effectively, you can efficiently read from and write to files in your Java applications.
    </p>
</div>

<!-- Multithreading -->
<div class="main" id="multithreading">
    <h1>Multithreading</h1>

    <h3>Introduction</h3>
    <p>
        Multithreading is a feature in Java that allows the concurrent execution of two or more parts of a program to maximize CPU utilization. Each part of a program is called a thread, and multiple threads run in parallel to perform tasks efficiently.
    </p>

    <h3>Why Use Multithreading?</h3>
    <p>
        Multithreading is useful for improving the performance of programs by executing multiple tasks at the same time. For example:
    </p>
    <ul>
        <li>Parallel processing: Perform multiple tasks concurrently to reduce overall processing time.</li>
        <li>Responsive User Interfaces: Keep the user interface responsive while executing background tasks.</li>
        <li>Efficient resource management: Use CPU resources more effectively.</li>
    </ul>

    <h3>Creating Threads</h3>
    <p>
        In Java, there are two main ways to create threads:
    </p>
    <ul>
        <li><strong>Extending the Thread class:</strong> Create a new class that extends the <code>Thread</code> class and overrides its <code>run()</code> method.</li>
        <li><strong>Implementing the Runnable interface:</strong> Create a class that implements the <code>Runnable</code> interface and its <code>run()</code> method, then pass it to a <code>Thread</code> object.</li>
    </ul>

    <h4>Example: Creating a Thread by Extending the Thread Class</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            class MyThread extends Thread {
                public void run() {
                    System.out.println("Thread is running.");
                }

                public static void main(String[] args) {
                    MyThread t1 = new MyThread();
                    t1.start();
                }
            }
        </code>
    </pre>
    <p>
        In this example, a new thread is created by extending the <code>Thread</code> class and overriding its <code>run()</code> method. The <code>start()</code> method is called to begin the execution of the thread.
    </p>

    <h4>Example: Creating a Thread by Implementing the Runnable Interface</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            class MyRunnable implements Runnable {
                public void run() {
                    System.out.println("Thread is running.");
                }

                public static void main(String[] args) {
                    MyRunnable myRunnable = new MyRunnable();
                    Thread t1 = new Thread(myRunnable);
                    t1.start();
                }
            }
        </code>
    </pre>
    <p>
        In this example, a new thread is created by implementing the <code>Runnable</code> interface and passing it to a <code>Thread</code> object.
    </p>

    <h3>Thread Lifecycle</h3>
    <p>
        A thread goes through various states during its lifetime, as illustrated in the following lifecycle:
    </p>
    <ul>
        <li><strong>New:</strong> The thread is created but not yet started.</li>
        <li><strong>Runnable:</strong> The thread is ready for execution and waiting for CPU time.</li>
        <li><strong>Blocked:</strong> The thread is waiting for resources or synchronization.</li>
        <li><strong>Waiting:</strong> The thread is waiting indefinitely for another thread to perform a particular action.</li>
        <li><strong>Timed Waiting:</strong> The thread is waiting for a specific period.</li>
        <li><strong>Terminated:</strong> The thread has completed its execution or has been terminated.</li>
    </ul>

    <h3>Thread Synchronization</h3>
    <p>
        When multiple threads access shared resources, it can lead to data inconsistency. Thread synchronization ensures that only one thread can access the shared resource at a time, preventing data corruption.
    </p>
    <ul>
        <li><strong>synchronized keyword:</strong> This keyword can be used to make a method or block of code synchronized, ensuring that only one thread can execute it at a time.</li>
    </ul>

    <h4>Example: Using Synchronization</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            class Counter {
                private int count = 0;

                public synchronized void increment() {
                    count++;
                }

                public synchronized void decrement() {
                    count--;
                }

                public int getCount() {
                    return count;
                }

                public static void main(String[] args) {
                    Counter counter = new Counter();

                    Thread t1 = new Thread(() -> {
                        for (int i = 0; i < 1000; i++) {
                            counter.increment();
                        }
                    });

                    Thread t2 = new Thread(() -> {
                        for (int i = 0; i < 1000; i++) {
                            counter.decrement();
                        }
                    });

                    t1.start();
                    t2.start();
                }
            }
        </code>
    </pre>
    <p>
        The <code>synchronized</code> keyword ensures that the increment and decrement methods are executed by only one thread at a time, preventing race conditions.
    </p>

    <h3>Thread Pools</h3>
    <p>
        A thread pool is a collection of pre-created threads that can be reused for executing multiple tasks. Java provides the <code>Executor</code> framework for managing thread pools.
    </p>
    <ul>
        <li><strong>Executor Service:</strong> An interface for managing and controlling thread pools.</li>
        <li><strong>ExecutorService.submit():</strong> Submits tasks to the thread pool.</li>
        <li><strong>ExecutorService.shutdown():</strong> Shuts down the executor service once all tasks are completed.</li>
    </ul>

    <h4>Example: Using ExecutorService</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.util.concurrent.*;

            public class ThreadPoolExample {
                public static void main(String[] args) {
                    ExecutorService executorService = Executors.newFixedThreadPool(2);

                    Runnable task1 = () -> System.out.println("Task 1 is running");
                    Runnable task2 = () -> System.out.println("Task 2 is running");

                    executorService.submit(task1);
                    executorService.submit(task2);

                    executorService.shutdown();
                }
            }
        </code>
    </pre>
    <p>
        In this example, an <code>ExecutorService</code> is used to submit two tasks to the thread pool. The pool manages the threads and ensures that the tasks are executed concurrently.
    </p>

    <h3>Best Practices for Multithreading</h3>
    <ul>
        <li><strong>Use thread pools:</strong> Thread pools help manage a fixed number of threads and avoid unnecessary thread creation.</li>
        <li><strong>Avoid deadlocks:</strong> Deadlocks occur when two or more threads are waiting for each other to release resources. To prevent this, use proper locking strategies and avoid circular dependencies.</li>
        <li><strong>Minimize synchronization:</strong> Excessive synchronization can cause performance issues. Synchronize only when necessary.</li>
        <li><strong>Use thread-safe collections:</strong> For shared data structures, use thread-safe collections like <code>ConcurrentHashMap</code> or <code>CopyOnWriteArrayList</code>.</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Multithreading is an essential concept in Java for concurrent execution. By understanding how to create, manage, and synchronize threads, you can improve the performance and responsiveness of your Java applications.
    </p>
</div>

<!-- Networking -->
<div class="main" id="networking">
    <h1>Networking</h1>

    <h3>Introduction</h3>
    <p>
        Networking in Java allows you to build applications that communicate over a network, such as a client-server model, using sockets and other communication protocols. It enables systems to share data over the internet or local networks.
    </p>

    <h3>Key Concepts of Networking</h3>
    <p>
        The two primary components in networking are:
    </p>
    <ul>
        <li><strong>Client:</strong> The system that requests and consumes resources from a server.</li>
        <li><strong>Server:</strong> The system that provides resources or services to the client.</li>
    </ul>

    <h3>Java Networking Classes</h3>
    <p>
        Java provides the <code>java.net</code> package to handle all network-related functionality. The key classes for network communication include:
    </p>
    <ul>
        <li><strong>Socket:</strong> Represents the client-side connection and provides methods for communication with a server.</li>
        <li><strong>ServerSocket:</strong> Listens for incoming client connections on the server-side and accepts them.</li>
        <li><strong>URL:</strong> Represents a Uniform Resource Locator (URL) and provides methods to access the resource.</li>
        <li><strong>HttpURLConnection:</strong> Allows interaction with HTTP-based services for GET and POST requests.</li>
        <li><strong>DatagramSocket:</strong> Used for sending and receiving datagrams, typically for UDP communication.</li>
        <li><strong>DatagramPacket:</strong> Represents the data packet used by <code>DatagramSocket</code>.</li>
    </ul>

    <h3>Creating a Simple Client-Server Application</h3>
    <p>
        A basic client-server application in Java can be created using the <code>Socket</code> and <code>ServerSocket</code> classes. The server listens for incoming client requests, while the client sends data to the server.
    </p>

    <h4>Server Example</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.io.*;
            import java.net.*;

            public class Server {
                public static void main(String[] args) {
                    try {
                        ServerSocket serverSocket = new ServerSocket(8080);
                        System.out.println("Server is waiting for client connection...");
                        Socket clientSocket = serverSocket.accept();
                        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                        String message = in.readLine();
                        System.out.println("Received message: " + message);
                        clientSocket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        This server listens for client connections on port 8080, reads a message from the client, and then prints the message to the console.
    </p>

    <h4>Client Example</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.io.*;
            import java.net.*;

            public class Client {
                public static void main(String[] args) {
                    try {
                        Socket socket = new Socket("localhost", 8080);
                        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
                        out.println("Hello, Server!");
                        socket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        The client connects to the server at "localhost" on port 8080, sends a message, and then closes the connection.
    </p>

    <h3>UDP Communication</h3>
    <p>
        Unlike TCP (used by <code>Socket</code> and <code>ServerSocket</code>), UDP is a connectionless protocol. It does not guarantee message delivery, but it is faster and uses less overhead. You can use the <code>DatagramSocket</code> and <code>DatagramPacket</code> classes for UDP communication.
    </p>

    <h4>UDP Client Example</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.net.*;

            public class UDPClient {
                public static void main(String[] args) {
                    try {
                        DatagramSocket socket = new DatagramSocket();
                        String message = "Hello, UDP Server!";
                        InetAddress serverAddress = InetAddress.getByName("localhost");
                        DatagramPacket packet = new DatagramPacket(message.getBytes(), message.length(), serverAddress, 9876);
                        socket.send(packet);
                        socket.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>

    <h4>UDP Server Example</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.net.*;

            public class UDPServer {
                public static void main(String[] args) {
                    try {
                        DatagramSocket socket = new DatagramSocket(9876);
                        byte[] receiveData = new byte[1024];
                        DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);
                        socket.receive(packet);
                        String message = new String(packet.getData(), 0, packet.getLength());
                        System.out.println("Received message: " + message);
                        socket.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        In this example, the UDP client sends a message to the server using a <code>DatagramSocket</code> and the server listens for incoming messages on port 9876.
    </p>

    <h3>Best Practices for Networking in Java</h3>
    <ul>
        <li>Always close your sockets to avoid resource leaks.</li>
        <li>Handle exceptions gracefully, especially for network timeouts and connectivity issues.</li>
        <li>Use multi-threading to handle multiple client connections efficiently on the server side.</li>
        <li>Secure your communication by using encryption protocols like SSL/TLS for sensitive data transmission.</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Java networking provides powerful tools to create client-server applications and work with various communication protocols. By using <code>Socket</code>, <code>ServerSocket</code>, <code>DatagramSocket</code>, and other classes, you can build robust and scalable networked applications in Java.
    </p>
</div>

<!-- JavaFX -->
<div class="main" id="javafx">
    <h1>JavaFX</h1>

    <h3>Introduction</h3>
    <p>
        JavaFX is a powerful framework for building modern, rich user interfaces (UIs) in Java. It provides a set of graphics and media packages that allow you to design and create graphical applications, including 2D/3D graphics, animations, and video playback. JavaFX is a successor to Swing and AWT, and it provides a more modern and feature-rich alternative for building desktop applications.
    </p>

    <h3>Key Features of JavaFX</h3>
    <ul>
        <li><strong>FXML:</strong> A declarative markup language for defining UIs, similar to HTML, but specific to JavaFX.</li>
        <li><strong>Scene Graph:</strong> A hierarchical structure representing the UI components. It allows you to manage and manipulate visual elements efficiently.</li>
        <li><strong>Controls:</strong> JavaFX provides a wide variety of built-in controls such as buttons, sliders, text fields, tables, and charts.</li>
        <li><strong>Event Handling:</strong> JavaFX provides an event-handling mechanism that allows you to respond to user actions like mouse clicks, keyboard presses, and other events.</li>
        <li><strong>Animations:</strong> JavaFX includes built-in support for animations, including transitions, fades, and movements.</li>
        <li><strong>CSS Styling:</strong> JavaFX allows you to style your application using CSS to define the look and feel of UI components.</li>
        <li><strong>Media Support:</strong> JavaFX supports embedding audio and video media into your applications.</li>
    </ul>

    <h3>Setting Up JavaFX</h3>
    <p>
        To start developing JavaFX applications, you need to ensure that your development environment is set up properly. JavaFX was separated from the JDK starting with JDK 11, so you need to add the JavaFX SDK to your project.
    </p>

    <h4>Steps to Set Up JavaFX:</h4>
    <ul>
        <li>Download the latest JavaFX SDK from the official <a href="https://openjfx.io/">JavaFX website</a>.</li>
        <li>Add the JavaFX libraries to your project's classpath.</li>
        <li>If you're using an IDE like IntelliJ IDEA or Eclipse, make sure to add the JavaFX libraries to your project settings.</li>
        <li>For command-line compilation, use the <code>--module-path</code> option to specify the location of the JavaFX libraries.</li>
    </ul>

    <h3>Basic JavaFX Application</h3>
    <p>
        A simple JavaFX application requires extending the <code>Application</code> class and overriding the <code>start()</code> method to set up the user interface.
    </p>

    <h4>Example: Simple JavaFX Application</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import javafx.application.Application;
            import javafx.scene.Scene;
            import javafx.scene.control.Button;
            import javafx.scene.layout.StackPane;
            import javafx.stage.Stage;

            public class HelloJavaFX extends Application {
                @Override
                public void start(Stage primaryStage) {
                    Button btn = new Button("Click Me!");
                    btn.setOnAction(e -> System.out.println("Hello, JavaFX!"));

                    StackPane root = new StackPane();
                    root.getChildren().add(btn);

                    Scene scene = new Scene(root, 300, 250);

                    primaryStage.setTitle("Hello JavaFX!");
                    primaryStage.setScene(scene);
                    primaryStage.show();
                }

                public static void main(String[] args) {
                    launch(args);
                }
            }
        </code>
    </pre>
    <p>
        This simple JavaFX application creates a window with a button labeled "Click Me!". When clicked, it prints "Hello, JavaFX!" to the console.
    </p>

    <h3>JavaFX UI Components</h3>
    <p>
        JavaFX provides a wide range of UI components that can be used to build interactive and visually appealing applications. Some common components include:
    </p>
    <ul>
        <li><strong>Button:</strong> A clickable button that can trigger actions.</li>
        <li><strong>Label:</strong> Displays text on the screen.</li>
        <li><strong>TextField:</strong> A single-line text input field.</li>
        <li><strong>TextArea:</strong> A multi-line text input field.</li>
        <li><strong>ComboBox:</strong> A dropdown list for selecting options.</li>
        <li><strong>ListView:</strong> A scrollable list of items.</li>
        <li><strong>TableView:</strong> A table for displaying data in rows and columns.</li>
    </ul>

    <h3>FXML: Declarative UI Design</h3>
    <p>
        FXML is an XML-based markup language used to define the user interface of a JavaFX application. It allows you to separate the UI design from the application logic.
    </p>

    <h4>Example: FXML File</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            <?xml version="1.0" encoding="UTF-8"?>
            <?import javafx.scene.control.Button?>
            <?import javafx.scene.layout.StackPane?>

            <StackPane xmlns:fx="http://javafx.com/fxml" fx:controller="HelloJavaFXController">
                <Button text="Click Me!" onAction="#handleButtonAction" />
            </StackPane>
        </code>
    </pre>
    <p>
        In this example, the FXML file describes a UI with a <code>Button</code> component. The <code>onAction</code> attribute binds to a controller method that handles button clicks.
    </p>

    <h3>Styling JavaFX Applications with CSS</h3>
    <p>
        JavaFX supports styling with CSS, allowing you to control the look and feel of your application. You can create a separate CSS file to define styles for your UI components.
    </p>

    <h4>Example: Styling with CSS</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            .button {
                -fx-background-color: #3498db;
                -fx-text-fill: white;
                -fx-font-size: 16px;
            }
        </code>
    </pre>
    <p>
        In this example, the CSS code styles all <code>Button</code> components with a blue background, white text, and a font size of 16px.
    </p>

    <h3>Event Handling in JavaFX</h3>
    <p>
        JavaFX provides a robust event-handling mechanism to respond to user actions such as button clicks, key presses, and mouse movements. Event listeners can be added to components using the <code>setOnAction</code> method or other event-specific handlers.
    </p>

    <h3>Summary</h3>
    <p>
        JavaFX is a powerful framework for building modern, rich user interfaces in Java. It provides a variety of components, styling options, and event handling mechanisms to create interactive applications. With the ability to design UIs using FXML and CSS, JavaFX allows you to separate the logic from the presentation, making it easier to build and maintain Java desktop applications.
    </p>
</div>

<!-- Swing -->
<div class="main" id="swing">
    <h1>Swing</h1>

    <h3>Introduction</h3>
    <p>
        Swing is a Java GUI (Graphical User Interface) toolkit that provides a set of GUI components for building desktop applications. It is part of the Java Foundation Classes (JFC) and provides a more flexible and powerful alternative to the older Abstract Window Toolkit (AWT). Swing allows developers to create rich and interactive UIs with features like customizable controls, event handling, and layout management.
    </p>

    <h3>Key Features of Swing</h3>
    <ul>
        <li><strong>Lightweight Components:</strong> Unlike AWT, Swing components are lightweight, meaning they are not dependent on the underlying OS for rendering and can be drawn directly by Java.</li>
        <li><strong>Pluggable Look and Feel:</strong> Swing allows the UI to be styled and customized with different look-and-feels, giving applications a consistent appearance across platforms.</li>
        <li><strong>Rich Set of Components:</strong> Swing provides a wide variety of built-in components such as buttons, text fields, tables, and trees.</li>
        <li><strong>Event Handling:</strong> Swing follows the event-driven programming model, where actions like button clicks, key presses, and mouse movements are handled via event listeners.</li>
        <li><strong>Layout Managers:</strong> Swing offers several layout managers that help organize components in a flexible and responsive way, such as <code>FlowLayout</code>, <code>BorderLayout</code>, and <code>GridLayout</code>.</li>
        <li><strong>Customizable Components:</strong> Swing components can be customized, making it possible to modify their appearance, behavior, and interactions.</li>
    </ul>

    <h3>Setting Up Swing</h3>
    <p>
        Swing is included in the standard Java Development Kit (JDK), so no additional installation is required. You can start using Swing in any Java application by importing the relevant Swing packages.
    </p>

    <h4>Example: Importing Swing Components</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import javax.swing.JButton;
            import javax.swing.JFrame;
            import javax.swing.JPanel;
        </code>
    </pre>

    <h3>Basic Swing Application</h3>
    <p>
        To create a simple Swing application, you typically create a JFrame to hold your components and add various GUI elements like buttons and text fields to it.
    </p>

    <h4>Example: Simple Swing Application</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import javax.swing.*;

            public class HelloSwing {
                public static void main(String[] args) {
                    // Create a frame
                    JFrame frame = new JFrame("Hello Swing");
                    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

                    // Create a button
                    JButton button = new JButton("Click Me!");
                    button.addActionListener(e -> System.out.println("Hello, Swing!"));

                    // Add button to the frame
                    frame.getContentPane().add(button);

                    // Set the size of the frame and make it visible
                    frame.setSize(300, 200);
                    frame.setVisible(true);
                }
            }
        </code>
    </pre>
    <p>
        This simple Swing application creates a window with a button labeled "Click Me!". When clicked, it prints "Hello, Swing!" to the console.
    </p>

    <h3>Swing Components</h3>
    <p>
        Swing provides a variety of built-in components that can be used to build interactive applications. Some of the most commonly used components are:
    </p>
    <ul>
        <li><strong>JButton:</strong> A button that can trigger actions when clicked.</li>
        <li><strong>JLabel:</strong> A non-editable text component used to display information.</li>
        <li><strong>JTextField:</strong> A single-line text input field.</li>
        <li><strong>JTextArea:</strong> A multi-line text input field for more extensive input.</li>
        <li><strong>JComboBox:</strong> A dropdown list for selecting items from a list of options.</li>
        <li><strong>JList:</strong> A list of items that can be selected.</li>
        <li><strong>JTable:</strong> A table for displaying tabular data in rows and columns.</li>
        <li><strong>JTree:</strong> A tree structure to display hierarchical data.</li>
    </ul>

    <h3>Layout Managers in Swing</h3>
    <p>
        Layout managers control the arrangement and positioning of components inside containers. Swing provides several layout managers, each with a different way of managing components.
    </p>
    <ul>
        <li><strong>FlowLayout:</strong> Arranges components in a left-to-right flow, similar to text.</li>
        <li><strong>BorderLayout:</strong> Divides the container into five regions: North, South, East, West, and Center.</li>
        <li><strong>GridLayout:</strong> Arranges components in a grid with rows and columns.</li>
        <li><strong>BoxLayout:</strong> Organizes components in a single row or column.</li>
        <li><strong>CardLayout:</strong> Allows multiple components to be stacked on top of each other, with only one visible at a time.</li>
    </ul>

    <h3>Event Handling in Swing</h3>
    <p>
        Swing follows an event-driven programming model. Event listeners are used to handle user actions like button clicks, mouse events, and keyboard presses. You can attach event listeners to components and define actions that should be executed when the event occurs.
    </p>

    <h4>Example: Handling Button Click Event</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            JButton button = new JButton("Click Me!");
            button.addActionListener(e -> {
                System.out.println("Button Clicked!");
            });
        </code>
    </pre>
    <p>
        In this example, the <code>addActionListener</code> method is used to attach an event listener to the button. When the button is clicked, the message "Button Clicked!" is printed to the console.
    </p>

    <h3>Customizing Swing Components</h3>
    <p>
        Swing components are highly customizable. You can change their appearance, behavior, and interactions to fit the needs of your application. You can modify their properties, such as background color, font, and border, as well as implement custom rendering logic.
    </p>

    <h4>Example: Customizing Button Appearance</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            button.setBackground(Color.BLUE);
            button.setForeground(Color.WHITE);
            button.setFont(new Font("Arial", Font.BOLD, 14));
        </code>
    </pre>
    <p>
        This code customizes the appearance of a button by setting its background color to blue, its text color to white, and its font to bold Arial with a size of 14.
    </p>

    <h3>Summary</h3>
    <p>
        Swing is a powerful and flexible framework for building GUI applications in Java. It provides a rich set of components, layout managers, and event handling mechanisms to create interactive desktop applications. Swing’s flexibility and ability to customize components make it a popular choice for developing Java-based desktop software.
    </p>
</div>

<!-- JDBC -->
<div class="main" id="jdbc">
    <h1>JDBC (Java Database Connectivity)</h1>

    <h3>Introduction</h3>
    <p>
        JDBC (Java Database Connectivity) is an API that allows Java applications to interact with databases. It provides a standard interface for connecting to relational databases, executing queries, and processing the results. JDBC supports a wide range of databases, including MySQL, Oracle, PostgreSQL, and others, and is essential for developing data-driven applications in Java.
    </p>

    <h3>Key Components of JDBC</h3>
    <ul>
        <li><strong>Driver Manager:</strong> Manages the list of database drivers and establishes connections with the database.</li>
        <li><strong>Connection:</strong> Represents an open connection to a specific database. It provides methods to create and manage SQL statements.</li>
        <li><strong>Statement:</strong> Used to execute SQL queries against the database. There are different types of statements like <code>Statement</code>, <code>PreparedStatement</code>, and <code>CallableStatement</code>.</li>
        <li><strong>ResultSet:</strong> Represents the result of a database query. It allows traversal and retrieval of data from the result set.</li>
        <li><strong>SQLException:</strong> Handles exceptions related to database operations, such as connection errors, invalid SQL queries, and others.</li>
    </ul>

    <h3>Setting Up JDBC</h3>
    <p>
        To use JDBC in a Java project, you must include the appropriate database driver for your database in the classpath. The driver allows Java to communicate with the specific database. For example, if you are using MySQL, you need the MySQL JDBC driver.
    </p>

    <h4>Example: Including JDBC Driver</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            // MySQL JDBC Driver for Maven
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;8.0.25&lt;/version&gt;
            &lt;/dependency&gt;
        </code>
    </pre>

    <h3>Connecting to a Database</h3>
    <p>
        To connect to a database, you must create a <code>Connection</code> object. The connection is established using the <code>DriverManager.getConnection()</code> method, which requires the database URL, username, and password.
    </p>

    <h4>Example: Connecting to MySQL</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import java.sql.*;

            public class JDBCExample {
                public static void main(String[] args) {
                    try {
                        // Load the MySQL driver
                        Class.forName("com.mysql.cj.jdbc.Driver");

                        // Establish the connection
                        Connection conn = DriverManager.getConnection(
                                "jdbc:mysql://localhost:3306/mydatabase", "root", "password");

                        System.out.println("Connected to the database!");

                        // Close the connection
                        conn.close();
                    } catch (SQLException | ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }
        </code>
    </pre>
    <p>
        In this example, we load the MySQL driver using <code>Class.forName()</code> and establish a connection to the database using the connection URL, username, and password.
    </p>

    <h3>Executing SQL Queries</h3>
    <p>
        Once the connection is established, you can execute SQL queries using the <code>Statement</code> or <code>PreparedStatement</code> objects. The <code>Statement</code> is used for executing simple SQL queries, while the <code>PreparedStatement</code> is used for executing parameterized queries, which are more efficient and secure.
    </p>

    <h4>Example: Executing a Query</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            Statement stmt = conn.createStatement();
            String sql = "SELECT * FROM employees";
            ResultSet rs = stmt.executeQuery(sql);

            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                System.out.println(id + ": " + name);
            }
        </code>
    </pre>
    <p>
        In this example, we create a <code>Statement</code> object, execute a SELECT query, and process the result set using the <code>ResultSet</code> object to retrieve data from the database.
    </p>

    <h3>Prepared Statements</h3>
    <p>
        <code>PreparedStatement</code> allows you to execute parameterized SQL queries. It helps prevent SQL injection attacks and improves performance by pre-compiling the SQL query.
    </p>

    <h4>Example: Using PreparedStatement</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            String sql = "INSERT INTO employees (name, position) VALUES (?, ?)";
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, "John Doe");
            pstmt.setString(2, "Software Engineer");
            int rowsAffected = pstmt.executeUpdate();
            System.out.println("Rows affected: " + rowsAffected);
        </code>
    </pre>
    <p>
        In this example, we use a <code>PreparedStatement</code> to insert a new employee into the database. The question marks in the query are placeholders for the actual values, which are set using the <code>setString()</code> method.
    </p>

    <h3>Handling Exceptions</h3>
    <p>
        JDBC operations can throw exceptions, such as <code>SQLException</code>, if there are issues with the database connection or SQL execution. It is important to handle these exceptions properly to ensure the application behaves as expected.
    </p>

    <h4>Example: Handling SQLException</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            try {
                // JDBC operations
            } catch (SQLException e) {
                System.out.println("Database error: " + e.getMessage());
            }
        </code>
    </pre>

    <h3>Closing Database Connections</h3>
    <p>
        It is essential to close database resources (Connection, Statement, ResultSet) after use to free up system resources and avoid memory leaks. This is typically done in a <code>finally</code> block or using the <code>try-with-resources</code> statement.
    </p>

    <h4>Example: Closing Resources</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            try (Connection conn = DriverManager.getConnection(...);
                 Statement stmt = conn.createStatement()) {
                // JDBC operations
            } catch (SQLException e) {
                e.printStackTrace();
            }
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        JDBC is a powerful API for connecting Java applications to relational databases. It allows developers to execute SQL queries, process results, and manage database connections. By using JDBC, Java applications can interact with databases and store or retrieve data efficiently.
    </p>
</div>

<!-- Working with JSON -->
<div class="main" id="json-apis">
    <h1>Working with JSON</h1>

    <h3>Introduction</h3>
    <p>
        JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. Java provides several libraries to work with JSON, allowing developers to convert Java objects to JSON format and vice versa.
    </p>

    <h3>Popular Libraries for JSON in Java</h3>
    <p>
        There are several popular libraries in Java for working with JSON:
    </p>
    <ul>
        <li><strong>Jackson:</strong> A high-performance JSON library for Java that can convert Java objects to JSON and vice versa.</li>
        <li><strong>Gson:</strong> A simple and efficient library developed by Google for converting Java objects to JSON and vice versa.</li>
        <li><strong>org.json:</strong> A lightweight JSON library that provides simple tools for parsing and generating JSON data.</li>
    </ul>

    <h3>Setting Up JSON Libraries</h3>
    <p>
        To work with JSON in Java, you need to add the corresponding library to your project. Here's how to include the libraries in your project using Maven:
    </p>

    <h4>Example: Adding Jackson Dependency (Maven)</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
                &lt;version&gt;2.12.3&lt;/version&gt;
            &lt;/dependency&gt;
        </code>
    </pre>

    <h4>Example: Adding Gson Dependency (Maven)</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            &lt;dependency&gt;
                &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
                &lt;artifactId&gt;gson&lt;/artifactId&gt;
                &lt;version&gt;2.8.8&lt;/version&gt;
            &lt;/dependency&gt;
        </code>
    </pre>

    <h3>Working with Jackson</h3>
    <p>
        Jackson is one of the most widely used libraries for JSON processing in Java. It provides the ability to read and write JSON using data binding (converting between Java objects and JSON) and streaming (processing JSON in a low-level manner).
    </p>

    <h4>Example: Converting Java Object to JSON with Jackson</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import com.fasterxml.jackson.databind.ObjectMapper;

            public class JacksonExample {
                public static void main(String[] args) {
                    ObjectMapper objectMapper = new ObjectMapper();
                    Employee employee = new Employee("John Doe", "Software Engineer");

                    try {
                        // Convert Java object to JSON
                        String jsonString = objectMapper.writeValueAsString(employee);
                        System.out.println(jsonString);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }

            class Employee {
                private String name;
                private String position;

                public Employee(String name, String position) {
                    this.name = name;
                    this.position = position;
                }

                // Getters and Setters
            }
        </code>
    </pre>
    <p>
        In this example, we create an <code>Employee</code> object and use Jackson's <code>ObjectMapper</code> to convert the object into a JSON string.
    </p>

    <h4>Example: Converting JSON to Java Object with Jackson</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            String jsonString = "{\"name\":\"John Doe\", \"position\":\"Software Engineer\"}";

            try {
                // Convert JSON to Java object
                Employee employee = objectMapper.readValue(jsonString, Employee.class);
                System.out.println(employee.getName() + " - " + employee.getPosition());
            } catch (Exception e) {
                e.printStackTrace();
            }
        </code>
    </pre>

    <h3>Working with Gson</h3>
    <p>
        Gson is another popular library for working with JSON in Java. It is known for its simplicity and ease of use, especially when working with Java objects and JSON serialization/deserialization.
    </p>

    <h4>Example: Converting Java Object to JSON with Gson</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import com.google.gson.Gson;

            public class GsonExample {
                public static void main(String[] args) {
                    Gson gson = new Gson();
                    Employee employee = new Employee("Jane Smith", "Product Manager");

                    // Convert Java object to JSON
                    String jsonString = gson.toJson(employee);
                    System.out.println(jsonString);
                }
            }

            class Employee {
                private String name;
                private String position;

                public Employee(String name, String position) {
                    this.name = name;
                    this.position = position;
                }

                // Getters and Setters
            }
        </code>
    </pre>

    <h4>Example: Converting JSON to Java Object with Gson</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            String jsonString = "{\"name\":\"Jane Smith\", \"position\":\"Product Manager\"}";
            Employee employee = gson.fromJson(jsonString, Employee.class);
            System.out.println(employee.getName() + " - " + employee.getPosition());
        </code>
    </pre>

    <h3>Working with org.json Library</h3>
    <p>
        The org.json library is a lightweight library that can be used to parse and generate JSON data. It provides a simple interface for handling JSON in Java.
    </p>

    <h4>Example: Creating JSON with org.json</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import org.json.JSONObject;

            public class JSONOrgExample {
                public static void main(String[] args) {
                    // Create a JSONObject
                    JSONObject jsonObject = new JSONObject();
                    jsonObject.put("name", "Alice");
                    jsonObject.put("position", "Developer");

                    // Print JSON object
                    System.out.println(jsonObject.toString());
                }
            }
        </code>
    </pre>

    <h4>Example: Parsing JSON with org.json</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            String jsonString = "{\"name\":\"Alice\", \"position\":\"Developer\"}";
            JSONObject jsonObject = new JSONObject(jsonString);
            String name = jsonObject.getString("name");
            String position = jsonObject.getString("position");

            System.out.println(name + " - " + position);
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        Working with JSON in Java is essential for interacting with modern web services, APIs, and storing/retrieving data in a lightweight format. Whether using Jackson, Gson, or org.json, Java provides powerful libraries to easily convert Java objects to JSON and parse JSON into Java objects. By mastering these libraries, developers can efficiently manage and manipulate JSON data in Java applications.
    </p>
</div>

<!-- Code Readability -->
<div class="main" id="code-readability">
    <h1>Code Readability</h1>

    <h3>Introduction</h3>
    <p>
        Code readability is a key aspect of writing maintainable and understandable code. It refers to how easily a person can read and understand the code, even if they are not the original author. Code readability is crucial for collaboration, debugging, and future code modifications.
    </p>

    <h3>Importance of Code Readability</h3>
    <p>
        Writing readable code helps:
    </p>
    <ul>
        <li><strong>Collaboration:</strong> When multiple developers work on the same project, readable code ensures that others can easily understand and contribute to the codebase.</li>
        <li><strong>Maintenance:</strong> Code that is easy to read can be modified or updated with less effort, reducing the likelihood of introducing bugs.</li>
        <li><strong>Debugging:</strong> Clear code makes it easier to locate and fix issues quickly.</li>
        <li><strong>Code Reviews:</strong> Readable code simplifies the process of reviewing code and ensures that other developers can follow the logic and structure of the code.</li>
    </ul>

    <h3>Best Practices for Improving Code Readability</h3>
    <ul>
        <li><strong>Use Meaningful Variable and Method Names:</strong> Choose descriptive names that convey the purpose of the variable or method. Avoid abbreviations or generic names like <code>temp</code> or <code>data</code>.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Good naming
                    int numberOfItems;
                    String userName;

                    // Bad naming
                    int n;
                    String str;
                </code>
            </pre>
        </li>

        <li><strong>Follow Naming Conventions:</strong> Stick to standard naming conventions to make your code predictable and consistent. In Java, use camelCase for variables and methods, and PascalCase for class names.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Correct naming conventions
                    public class UserProfile {
                        private String userName;
                        
                        public String getUserName() {
                            return userName;
                        }
                    }
                </code>
            </pre>
        </li>

        <li><strong>Write Short and Focused Functions:</strong> Break down large methods into smaller, reusable functions that each perform a single task. This makes your code more modular and easier to understand.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Good practice: short and focused method
                    public void printUserDetails(User user) {
                        printUserName(user);
                        printUserAge(user);
                    }
                    
                    public void printUserName(User user) {
                        System.out.println(user.getName());
                    }

                    public void printUserAge(User user) {
                        System.out.println(user.getAge());
                    }
                </code>
            </pre>
        </li>

        <li><strong>Keep Code DRY (Don’t Repeat Yourself):</strong> Avoid duplicating code. If you find yourself writing the same code multiple times, consider creating a reusable method.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Good practice: DRY code
                    public int calculateRectangleArea(int width, int height) {
                        return width * height;
                    }

                    // Bad practice: repeating code
                    public int calculateSquareArea(int side) {
                        return side * side;
                    }
                </code>
            </pre>
        </li>

        <li><strong>Use Proper Indentation and Spacing:</strong> Use consistent indentation and spacing to structure your code clearly. In Java, it is common to use 4 spaces per indentation level. This makes your code visually organized and easy to follow.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Proper indentation
                    public void exampleMethod() {
                        if (condition) {
                            // Do something
                        } else {
                            // Do something else
                        }
                    }

                    // Improper indentation
                    public void exampleMethod(){
                    if(condition){
                    // Do something
                    }else{
                    // Do something else
                    }
                    }
                </code>
            </pre>
        </li>

        <li><strong>Comment Your Code:</strong> Add comments to explain the purpose of complex logic or sections of code that may not be immediately clear. However, avoid obvious comments and focus on explaining the "why" behind your code, not the "what".
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Good comment
                    // Calculate the total price including tax
                    double totalPrice = price + (price * taxRate);

                    // Bad comment
                    int x = 5; // Assign 5 to x
                </code>
            </pre>
        </li>

        <li><strong>Handle Exceptions Properly:</strong> Avoid empty catch blocks and handle exceptions in a meaningful way. Proper error handling ensures that your code remains predictable and robust.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    try {
                        int result = divide(10, 0);
                    } catch (ArithmeticException e) {
                        System.out.println("Cannot divide by zero");
                    }

                    // Avoid empty catch block
                    try {
                        int result = divide(10, 0);
                    } catch (Exception e) {
                        // Do nothing
                    }
                </code>
            </pre>
        </li>
    </ul>

    <h3>Code Readability in Practice</h3>
    <p>
        Here’s an example of code that adheres to best practices for readability:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class OrderProcessor {

                private static final double TAX_RATE = 0.07;

                public double calculateTotalPrice(double price, int quantity) {
                    double subtotal = price * quantity;
                    return calculateTotalPriceWithTax(subtotal);
                }

                private double calculateTotalPriceWithTax(double subtotal) {
                    return subtotal + (subtotal * TAX_RATE);
                }
            }
        </code>
    </pre>
    <p>
        In this example, the code is clear, concise, and easy to understand, with descriptive method names and proper indentation.
    </p>

    <h3>Summary</h3>
    <p>
        Code readability is a critical factor in creating high-quality, maintainable software. By following best practices such as using meaningful names, writing modular code, and maintaining proper formatting, you can write Java code that is easy to understand and collaborate on. Remember that readable code benefits not only you as the author but also your team and anyone who works with your code in the future.
    </p>
</div>

<!-- Effective Exception Handling -->
<div class="main" id="exception-handling">
    <h1>Effective Exception Handling</h1>

    <h3>Introduction</h3>
    <p>
        Exception handling is a crucial part of writing reliable and fault-tolerant Java programs. Proper exception handling allows your application to handle unexpected situations gracefully and continue running without crashing. Effective exception handling ensures that errors are identified, handled properly, and communicated to the user or developer without compromising the application's flow.
    </p>

    <h3>What is an Exception?</h3>
    <p>
        An exception is an event that disrupts the normal flow of a program's execution. It typically occurs when a program encounters an unexpected situation such as dividing by zero, trying to access an invalid file, or encountering a network error.
    </p>

    <h3>Types of Exceptions in Java</h3>
    <ul>
        <li><strong>Checked Exceptions:</strong> These exceptions are checked at compile-time, and the programmer is required to handle them. For example, <code>IOException</code>, <code>SQLException</code>.</li>
        <li><strong>Unchecked Exceptions:</strong> These exceptions are not checked at compile-time, and they usually indicate programming errors such as <code>NullPointerException</code>, <code>ArrayIndexOutOfBoundsException</code>.</li>
        <li><strong>Error:</strong> Errors represent serious problems that typically cannot be handled by the program, such as <code>OutOfMemoryError</code> or <code>StackOverflowError</code>.</li>
    </ul>

    <h3>Best Practices for Exception Handling</h3>
    <ul>
        <li><strong>Use Specific Exception Types:</strong> Catch specific exceptions rather than using a generic <code>Exception</code> class. This allows you to handle different exceptions in different ways based on their nature.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Good practice: catch specific exceptions
                    try {
                        FileReader reader = new FileReader("file.txt");
                    } catch (FileNotFoundException e) {
                        System.out.println("File not found!");
                    }

                    // Bad practice: catch generic Exception
                    try {
                        // Code that may throw exception
                    } catch (Exception e) {
                        // Handle any exception
                    }
                </code>
            </pre>
        </li>

        <li><strong>Avoid Empty Catch Blocks:</strong> Never leave a <code>catch</code> block empty. Instead, log the exception or provide a meaningful response, such as displaying an error message to the user or retrying the operation.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    try {
                        int result = divide(10, 0);
                    } catch (ArithmeticException e) {
                        // Good practice: log and handle the error
                        System.out.println("Error: Cannot divide by zero.");
                    }

                    // Bad practice: empty catch block
                    try {
                        int result = divide(10, 0);
                    } catch (ArithmeticException e) {
                        // No action taken
                    }
                </code>
            </pre>
        </li>

        <li><strong>Don’t Use Exceptions for Control Flow:</strong> Exceptions should be used to handle exceptional situations, not to control the normal flow of the program. Relying on exceptions for regular logic can make your code harder to understand and maintain.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    // Good practice: avoid using exceptions for normal control flow
                    if (condition) {
                        // Normal logic
                    }

                    // Bad practice: using exception for control flow
                    try {
                        if (condition) {
                            // Normal logic
                        }
                    } catch (SomeException e) {
                        // Exception handling for normal condition
                    }
                </code>
            </pre>
        </li>

        <li><strong>Use Finally Block for Cleanup:</strong> The <code>finally</code> block is used to execute important cleanup tasks, such as closing resources (e.g., database connections, file streams), whether or not an exception occurred.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    try {
                        FileReader reader = new FileReader("file.txt");
                    } catch (IOException e) {
                        System.out.println("File not found!");
                    } finally {
                        // Always close the resource
                        reader.close();
                    }
                </code>
            </pre>
        </li>

        <li><strong>Log Exceptions Properly:</strong> Always log exceptions for debugging and future reference. Proper logging can help you track issues, improve your code, and understand the program's behavior in production environments.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    try {
                        int result = divide(10, 0);
                    } catch (ArithmeticException e) {
                        // Log the exception
                        System.err.println("Error: " + e.getMessage());
                    }
                </code>
            </pre>
        </li>

        <li><strong>Use Custom Exception Classes:</strong> When necessary, create custom exceptions that represent specific errors in your application. This allows you to provide more context to the error and handle it appropriately.
            <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                <code>
                    public class InvalidAgeException extends Exception {
                        public InvalidAgeException(String message) {
                            super(message);
                        }
                    }

                    // Usage of custom exception
                    try {
                        throw new InvalidAgeException("Age must be greater than 18");
                    } catch (InvalidAgeException e) {
                        System.out.println(e.getMessage());
                    }
                </code>
            </pre>
        </li>
    </ul>

    <h3>Exception Handling Example</h3>
    <p>
        Below is an example of effective exception handling that demonstrates how to catch specific exceptions, clean up resources, and log the error:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            public class DatabaseConnection {
                public void connectToDatabase() {
                    try {
                        // Code to connect to the database
                        // Simulating an exception
                        throw new SQLException("Database connection failed");

                    } catch (SQLException e) {
                        // Log the exception
                        System.err.println("Error connecting to database: " + e.getMessage());

                    } finally {
                        // Clean up resources (e.g., close the connection)
                        System.out.println("Closing the database connection...");
                    }
                }
            }
        </code>
    </pre>

    <h3>Summary</h3>
    <p>
        Effective exception handling is essential for writing robust Java applications. By following best practices such as using specific exceptions, avoiding empty catch blocks, cleaning up resources, and logging exceptions properly, you can ensure that your application can handle unexpected situations gracefully and continue running smoothly.
    </p>
</div>

<!-- Unit Testing -->
<div class="main" id="unit-testing">
    <h1>Unit Testing</h1>

    <h3>Introduction</h3>
    <p>
        Unit testing is a critical part of software development, ensuring that individual components (or units) of the program work as expected. In Java, unit tests are typically written using frameworks like JUnit. Unit tests allow developers to catch bugs early, validate the correctness of code, and ensure that changes do not introduce new issues.
    </p>

    <h3>What is a Unit Test?</h3>
    <p>
        A unit test is a method that tests a specific unit of code (usually a function or method) in isolation. The goal of a unit test is to verify that the code works as expected for different inputs and scenarios.
    </p>

    <h3>JUnit Framework</h3>
    <p>
        The JUnit framework is widely used for writing and running unit tests in Java. It provides annotations and methods to define and execute test cases, as well as to assert conditions and check if the tests pass or fail.
    </p>

    <h4>Setting Up JUnit</h4>
    <p>
        To use JUnit in a project, you need to add the JUnit dependency. For Maven projects, you can add the following to your <code>pom.xml</code> file:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            <dependency>
                <groupId>org.junit.jupiter</groupId>
                <artifactId>junit-jupiter-api</artifactId>
                <version>5.8.1</version>
                <scope>test</scope>
            </dependency>
        </code>
    </pre>

    <h4>Basic Annotations in JUnit</h4>
    <ul>
        <li><strong>@Test:</strong> Marks a method as a test case.</li>
        <li><strong>@BeforeEach:</strong> Executes before each test case, used for setting up common test data.</li>
        <li><strong>@AfterEach:</strong> Executes after each test case, used for cleaning up resources.</li>
        <li><strong>@BeforeAll:</strong> Executes once before all tests in a class.</li>
        <li><strong>@AfterAll:</strong> Executes once after all tests in a class.</li>
    </ul>

    <h3>Writing Unit Tests</h3>
    <p>
        A typical unit test involves creating an instance of the class to be tested, calling its methods, and asserting that the output matches the expected result. Below is a basic example of a unit test for a <code>Calculator</code> class:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import org.junit.jupiter.api.Test;
            import static org.junit.jupiter.api.Assertions.assertEquals;

            public class CalculatorTest {
                @Test
                public void testAdd() {
                    Calculator calculator = new Calculator();
                    int result = calculator.add(2, 3);
                    assertEquals(5, result);  // Verifies that the result is correct
                }
            }
        </code>
    </pre>

    <h3>Assertions in JUnit</h3>
    <p>
        Assertions are used to validate the results of a test. If the assertion fails, the test will fail. Some common assertions include:
    </p>
    <ul>
        <li><code>assertEquals(expected, actual):</code> Asserts that the expected value is equal to the actual value.</li>
        <li><code>assertNotEquals(expected, actual):</code> Asserts that the expected value is not equal to the actual value.</li>
        <li><code>assertTrue(condition):</code> Asserts that the given condition is true.</li>
        <li><code>assertFalse(condition):</code> Asserts that the given condition is false.</li>
        <li><code>assertNull(object):</code> Asserts that the object is null.</li>
        <li><code>assertNotNull(object):</code> Asserts that the object is not null.</li>
    </ul>

    <h4>Example of Using Assertions</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import org.junit.jupiter.api.Test;
            import static org.junit.jupiter.api.Assertions.*;

            public class CalculatorTest {
                @Test
                public void testMultiply() {
                    Calculator calculator = new Calculator();
                    int result = calculator.multiply(4, 5);
                    assertEquals(20, result);  // Asserts that 4 * 5 equals 20
                }

                @Test
                public void testIsPositive() {
                    Calculator calculator = new Calculator();
                    boolean result = calculator.isPositive(3);
                    assertTrue(result);  // Asserts that the number is positive
                }
            }
        </code>
    </pre>

    <h3>Test Coverage</h3>
    <p>
        Test coverage refers to the percentage of your code that is covered by tests. Good test coverage helps to ensure that most of your code is being tested, which reduces the chance of bugs and makes refactoring safer. However, 100% test coverage does not necessarily mean the code is error-free.
    </p>

    <h3>Mocking in Unit Testing</h3>
    <p>
        Sometimes, unit tests require isolating the class being tested from external dependencies, such as databases or APIs. In such cases, you can use mocking frameworks (e.g., Mockito) to simulate the behavior of dependencies and focus on testing the class itself.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import org.junit.jupiter.api.Test;
            import static org.mockito.Mockito.*;

            public class UserServiceTest {
                @Test
                public void testGetUser() {
                    // Mocking the database service
                    DatabaseService dbService = mock(DatabaseService.class);
                    UserService userService = new UserService(dbService);
                    when(dbService.getUserById(1)).thenReturn(new User(1, "John"));

                    User user = userService.getUser(1);
                    assertEquals("John", user.getName());
                }
            }
        </code>
    </pre>

    <h3>Test-Driven Development (TDD)</h3>
    <p>
        Test-Driven Development (TDD) is a software development methodology where developers write tests before writing the actual code. In TDD, the process is as follows:
    </p>
    <ul>
        <li>Write a failing test.</li>
        <li>Write the minimum code to make the test pass.</li>
        <li>Refactor the code while keeping the test green (passing).</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Unit testing is an essential practice in Java development. By writing unit tests, developers ensure that their code works as expected and is less prone to bugs. Using JUnit for unit testing provides a simple and effective way to write, manage, and execute tests. Additionally, utilizing test coverage, mocking, and Test-Driven Development (TDD) can help create more robust and reliable applications.
    </p>
</div>

<!-- Unit Testing -->
<div class="main" id="unit-testing">
    <h1>Unit Testing</h1>

    <h3>Introduction</h3>
    <p>
        Unit testing is a software testing technique where individual units or components of a software are tested in isolation. In Java, unit tests help verify that the individual parts of an application are working as expected before they are integrated into the larger system.
    </p>

    <h3>Why Unit Testing?</h3>
    <p>
        Unit testing ensures the correctness of your code and helps catch bugs early in the development process. It improves code quality, reduces the risk of defects, and makes it easier to maintain and refactor code over time.
    </p>

    <h3>JUnit Framework</h3>
    <p>
        In Java, the most popular framework for unit testing is <strong>JUnit</strong>. JUnit provides annotations and methods that help structure test cases and assertions to validate expected results.
    </p>

    <h4>Setting Up JUnit</h4>
    <p>
        To get started with JUnit, you'll need to add JUnit to your project. If you're using Maven or Gradle, you can include JUnit as a dependency. Here’s an example for Maven:
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            &lt;dependency&gt;
                &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
                &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
                &lt;version&gt;5.7.0&lt;/version&gt;
                &lt;scope&gt;test&lt;/scope&gt;
            &lt;/dependency&gt;
        </code>
    </pre>

    <h3>Writing a Simple Unit Test</h3>
    <p>
        A unit test consists of three main parts: setup, execution, and verification. JUnit provides various annotations to help define test methods, including:
    </p>
    <ul>
        <li><strong>@Test:</strong> Marks a method as a unit test.</li>
        <li><strong>@BeforeEach:</strong> Sets up the test environment before each test is executed.</li>
        <li><strong>@AfterEach:</strong> Cleans up after each test method has executed.</li>
        <li><strong>@BeforeAll:</strong> Runs once before any test methods in the class are run (useful for expensive setup).</li>
        <li><strong>@AfterAll:</strong> Runs once after all tests in the class have been executed.</li>
    </ul>

    <h4>Example: Writing a Simple Unit Test</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import org.junit.jupiter.api.Test;
            import static org.junit.jupiter.api.Assertions.*;

            public class CalculatorTest {
                
                @Test
                public void testAdd() {
                    Calculator calculator = new Calculator();
                    int result = calculator.add(2, 3);
                    assertEquals(5, result, "2 + 3 should equal 5");
                }

                @Test
                public void testSubtract() {
                    Calculator calculator = new Calculator();
                    int result = calculator.subtract(5, 3);
                    assertEquals(2, result, "5 - 3 should equal 2");
                }
            }
        </code>
    </pre>

    <h3>Assertions</h3>
    <p>
        Assertions are used to check if the expected results match the actual results. Some common assertions in JUnit include:
    </p>
    <ul>
        <li><code>assertEquals(expected, actual)</code>: Asserts that the expected value is equal to the actual value.</li>
        <li><code>assertTrue(condition)</code>: Asserts that the condition is true.</li>
        <li><code>assertFalse(condition)</code>: Asserts that the condition is false.</li>
        <li><code>assertNull(object)</code>: Asserts that the object is null.</li>
        <li><code>assertNotNull(object)</code>: Asserts that the object is not null.</li>
    </ul>

    <h4>Example: Using Assertions</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            @Test
            public void testDivide() {
                Calculator calculator = new Calculator();
                int result = calculator.divide(6, 3);
                assertEquals(2, result, "6 / 3 should equal 2");
            }
        </code>
    </pre>

    <h3>Mocking Dependencies with Mockito</h3>
    <p>
        Mockito is a popular Java library that helps with mocking objects and their behaviors for unit tests. Mocking is used when your code depends on external systems, such as databases or APIs, and you want to isolate the unit being tested from those dependencies.
    </p>
    <ul>
        <li><strong>Mock:</strong> Create mock objects for dependencies.</li>
        <li><strong>When:</strong> Define behavior for mocked objects.</li>
        <li><strong>Verify:</strong> Verify if certain interactions occurred with mock objects.</li>
    </ul>

    <h4>Example: Using Mockito</h4>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import static org.mockito.Mockito.*;

            @Test
            public void testServiceMethod() {
                MyService service = mock(MyService.class);
                when(service.getData()).thenReturn("Mocked Data");

                String result = service.getData();
                assertEquals("Mocked Data", result);
                
                verify(service).getData();  // Verify that getData() was called
            }
        </code>
    </pre>

    <h3>Test Suites</h3>
    <p>
        A test suite is a collection of test cases that can be run together. In JUnit, you can create a suite to group multiple test classes together and execute them at once.
    </p>
    <pre>
        <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
        <code>
            import org.junit.jupiter.api.Test;
            import org.junit.jupiter.api.TestInstance;
            import org.junit.jupiter.api.TestFactory;
            import static org.junit.jupiter.api.Assertions.*;

            @TestInstance(TestInstance.Lifecycle.PER_CLASS)
            @TestFactory
            public class TestSuite {
                
                @Test
                void testAll() {
                    assertTrue(true);
                    assertFalse(false);
                }
            }
        </code>
    </pre>

    <h3>Continuous Integration and Unit Testing</h3>
    <p>
        Unit tests play a crucial role in continuous integration (CI). Tools like Jenkins, GitHub Actions, and GitLab CI can automatically run unit tests every time changes are made to the codebase. This ensures that the new code does not break existing functionality and that the system remains stable.
    </p>

    <h3>Summary</h3>
    <p>
        Unit testing is a fundamental part of modern software development. By writing unit tests, you can ensure the correctness of your code, catch bugs early, and improve maintainability. JUnit and Mockito are widely used tools for unit testing in Java, and by using assertions, mock objects, and test suites, developers can write effective and reliable unit tests for their applications.
    </p>
</div>

<!-- Performance Optimization -->
<div class="main" id="performance">
    <h1>Performance Optimization</h1>

    <h3>Introduction</h3>
    <p>
        Performance optimization in Java involves improving the speed, efficiency, and resource utilization of Java applications. Effective performance tuning can lead to faster execution times, reduced memory consumption, and better scalability, resulting in a more responsive and efficient application.
    </p>

    <h3>Why Performance Optimization Matters?</h3>
    <p>
        Optimizing performance is essential for applications that handle large volumes of data, require real-time processing, or run on resource-constrained environments like mobile devices or cloud servers. Poor performance can lead to increased latency, system crashes, and poor user experiences.
    </p>

    <h3>Identifying Performance Bottlenecks</h3>
    <p>
        Before optimizing your application, it’s important to identify performance bottlenecks. Some common techniques to find areas needing optimization include:
    </p>
    <ul>
        <li><strong>Profiling:</strong> Use profilers to monitor CPU and memory usage, track method execution time, and find inefficient code.</li>
        <li><strong>Logging:</strong> Add logging to measure execution times for critical sections of code.</li>
        <li><strong>Benchmarking:</strong> Measure the time taken by different methods or algorithms to perform tasks.</li>
    </ul>

    <h3>Optimizing Memory Usage</h3>
    <p>
        Java applications can consume a significant amount of memory. Optimizing memory usage involves minimizing object creation, avoiding memory leaks, and using data structures that fit your requirements.
    </p>
    <h4>Techniques to Optimize Memory Usage:</h4>
    <ul>
        <li><strong>Object Pooling:</strong> Reuse objects instead of creating new ones frequently.</li>
        <li><strong>Use Efficient Data Structures:</strong> Choose the right data structures (e.g., HashMap, ArrayList) based on access patterns and memory efficiency.</li>
        <li><strong>Garbage Collection Optimization:</strong> Use weak references and optimize garbage collection to prevent memory leaks and unnecessary object retention.</li>
    </ul>

    <h3>Optimizing CPU Usage</h3>
    <p>
        Java applications can be CPU-intensive, particularly in multi-threaded applications or when performing complex computations. Reducing CPU consumption can improve overall performance and scalability.
    </p>
    <h4>Techniques to Optimize CPU Usage:</h4>
    <ul>
        <li><strong>Efficient Algorithms:</strong> Choose efficient algorithms with lower time complexity (e.g., O(log n) instead of O(n^2)).</li>
        <li><strong>Parallel Processing:</strong> Use multi-threading or parallel processing to leverage multiple CPU cores.</li>
        <li><strong>Lazy Evaluation:</strong> Only compute values when necessary, delaying computations until they are needed.</li>
    </ul>

    <h3>Database and I/O Optimization</h3>
    <p>
        Database access and file I/O operations can become performance bottlenecks in applications that require frequent data storage or retrieval. Optimizing these operations is crucial for improving application performance.
    </p>
    <h4>Techniques to Optimize Database Access:</h4>
    <ul>
        <li><strong>Database Indexing:</strong> Use indexes to speed up query execution.</li>
        <li><strong>Batch Processing:</strong> Group multiple database operations into a single transaction to reduce overhead.</li>
        <li><strong>Connection Pooling:</strong> Reuse database connections instead of opening and closing connections repeatedly.</li>
    </ul>
    <h4>Techniques to Optimize I/O:</h4>
    <ul>
        <li><strong>Buffered I/O:</strong> Use buffered streams to reduce the number of I/O operations.</li>
        <li><strong>Asynchronous I/O:</strong> Use asynchronous I/O operations to avoid blocking threads during file operations.</li>
    </ul>

    <h3>Using Java Optimizations</h3>
    <p>
        Java provides several built-in optimizations and features to improve application performance, including Just-In-Time (JIT) compilation, garbage collection tuning, and JVM flags.
    </p>
    <h4>JIT Compiler Optimization:</h4>
    <p>
        The JIT compiler in the JVM translates bytecode into machine code at runtime, optimizing frequently executed code paths. You can enable additional JIT optimizations using JVM flags like <code>-XX:+AggressiveOpts</code> to speed up the application.
    </p>

    <h4>Garbage Collection Tuning:</h4>
    <p>
        Garbage collection (GC) is an important aspect of Java performance. Tuning GC settings can help reduce the overhead caused by frequent garbage collection pauses.
    </p>
    <ul>
        <li><strong>Young Generation Size:</strong> Adjust the size of the young generation to balance between GC pause times and overall heap size.</li>
        <li><strong>GC Algorithms:</strong> Choose between different GC algorithms (e.g., Parallel GC, G1 GC, ZGC) based on the application's needs.</li>
    </ul>

    <h3>Profiling and Benchmarking Tools</h3>
    <p>
        Several profiling and benchmarking tools can help identify performance issues and validate optimizations. Some of the popular tools include:
    </p>
    <ul>
        <li><strong>JProfiler:</strong> A powerful profiler for memory, CPU, and thread analysis in Java applications.</li>
        <li><strong>VisualVM:</strong> A free, visual tool for monitoring and troubleshooting Java applications.</li>
        <li><strong>JMH (Java Microbenchmarking Harness):</strong> A framework for benchmarking Java code and measuring performance accurately.</li>
    </ul>

    <h3>Code Optimizations</h3>
    <p>
        Code-level optimizations can often yield significant performance improvements. Some common code optimizations include:
    </p>
    <ul>
        <li><strong>Avoiding Unnecessary Object Creation:</strong> Reuse objects whenever possible instead of creating new ones.</li>
        <li><strong>Using StringBuilder for String Concatenation:</strong> Use <code>StringBuilder</code> instead of <code>String</code> for concatenating strings to avoid creating multiple intermediate objects.</li>
        <li><strong>Minimizing Synchronization:</strong> Use efficient synchronization mechanisms (e.g., <code>ReentrantLock</code>) to avoid thread contention.</li>
    </ul>

    <h3>Summary</h3>
    <p>
        Performance optimization is a critical aspect of Java application development. By identifying bottlenecks, optimizing memory, CPU usage, database access, and I/O operations, and leveraging Java’s built-in optimizations, developers can significantly improve application performance. Profiling and benchmarking tools can provide valuable insights, allowing you to fine-tune your application for better scalability and efficiency.
    </p>
</div>







    </div>


    <script src="script1.js"></script>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const menuBtn = document.getElementById("menuBtn");
            const sidebar = document.getElementById("sidebar");
    
            menuBtn.addEventListener("click", () => {
                sidebar.classList.toggle("active");
            });
    
            const sidebarLinks = document.querySelectorAll(".sidebar ul li a");
            const contentSections = document.querySelectorAll(".content .content");
    
            sidebarLinks.forEach(link => {
                link.addEventListener("click", (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute("href").substring(1);
    
                    // Hide all content sections and reset sidebar links
                    contentSections.forEach(section => {
                        section.classList.remove("active");
                    });
    
                    // Show the selected content section
                    document.getElementById(targetId).classList.add("active");
    
                    // Set active background on sidebar links
                    sidebarLinks.forEach(link => {
                        link.parentElement.classList.remove("active-bg");
                    });
    
                    link.parentElement.classList.add("active-bg");
                });
            });
    
            // Initialize the first section as active
            if (contentSections.length > 0) {
                contentSections[0].classList.add("active");
                sidebarLinks[0].parentElement.classList.add("active-bg");
            }
        });
    
    
    
        document.querySelector('.menu-btn2').addEventListener('click', function () {
            const topicButtons = document.querySelector('.topic-buttons');
            // Toggle the menu visibility by moving it on and off the screen
            if (topicButtons.style.right === '0px') {
                topicButtons.style.right = '-250px'; // Slide out
            } else {
                topicButtons.style.right = '0px'; // Slide in
            }
        });
    
    
    
    
    
    
    
    </script>
    
    </body>
    
    </html>
