<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="logo.png">
    <title>C++ Course</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="stylesheet1.css">
    <style>



    </style>
</head>

<body>
    <div class="navbar">

           <!-----for desktop view------------>
        <div class="logo">
            <img src="logo.png" alt="Logo" style="height: 70px; width: auto; margin-left: 20px; ">
        </div>
        

        <!--------------for mobile view---------------->
        <div class="logo1">
            <img src="logo1.png" alt="Logo" style="height: 30px; width: 130px; margin-left: 100px; margin-top: 14px;">
        </div>

        <!-- Menu Button for Mobile View -->
        <button class="menu-btn2" aria-label="Open menu">&#x27A1;</button>

        <!-- Desktop Navbar -->
        <div class="desktop-navbar">
            <button><a href="index.html" style="color: white;">Home</a></button>
            <button><a href="python.html" style="color: white;">Python</a></button>
            <button><a href="cpp.html" style="color: white;">C++</a></button>
            <button><a href="c.html" style="color: white;">C</a></button>
            <button><a href="html.html" style="color: white;">HTML</a></button>
            <button><a href="css.html" style="color: white;">CSS</a></button>
            <button><a href="javascript.html" style="color: white;">JS</a></button>
            <button><a href="java.html" style="color: white;">Java</a></button>
            <button><a href="php.html" style="color: white;">PHP</a></button>
            <button><a href="dsa.html" style="color: white;">DSA</a></button>
        </div>

        <!-- Dropdown Menu for Mobile View -->
        <div class="topic-buttons">
            <a href="index.html"><button>Home</button></a>
            <a href="python.html"><button>Python</button></a>
            <a href="cpp.html"><button>C++</button></a>
            <a href="c.html"><button>C</button></a>
            <a href="html.html"><button>HTML</button></a>
            <a href="css.html"><button>CSS</button></a>
            <a href="javascript.html"><button>JS</button></a>
            <a href="java.html"><button>Java</button></a>
            <a href="php.html"><button>PHP</button></a>
            <a href="dsa.html"><button>DSA</button></a>
        </div>

        
        <!-- Mobile menu button -->
        <div class="menu-btn" id="menuBtn">
            &#9776;
        </div>


    </div>


    <div class="content">
        <!-- Sidebar Navigation -->
        <div class="sidebar" id="sidebar">
            <h2>Introduction</h2>
            <ul>
                <li><a href="#overview">C++ Overview</a></li>
                <li><a href="#installation-and-getting-started">Installation & Getting Started</a></li>
                <li><a href="#syntax">C++ Syntax</a></li>
                <li><a href="#comments">C++ Comments</a></li>
                <li><a href="#variables">C++ Variables</a></li>
            </ul>
    
            <h2>Data Types</h2>
            <ul>
                <li><a href="#numbers">Primitive Data Types</a></li>
                <li><a href="#strings">Strings</a></li>
                <li><a href="#arrays">Arrays</a></li>
                <li><a href="#pointers">Pointers</a></li>
                <li><a href="#structures">Structures</a></li>
                <li><a href="#enumerations">Enumerations</a></li>
            </ul>
    
            <h2>Control Flow</h2>
            <ul>
                <li><a href="#if-statements">If Statements</a></li>
                <li><a href="#for-loops">For Loops</a></li>
                <li><a href="#while-loops">While Loops</a></li>
                <li><a href="#switch-statements">Switch Statements</a></li>
                <li><a href="#break-and-continue">Break and Continue</a></li>
            </ul>
    
            <h2>Functions</h2>
            <ul>
                <li><a href="#defining-functions">Defining Functions</a></li>
                <li><a href="#arguments-and-parameters">Arguments and Parameters</a></li>
                <li><a href="#return-statement">Return Statement</a></li>
                <li><a href="#inline-functions">Inline Functions</a></li>
            </ul>
    
            <h2>Object-Oriented Programming</h2>
            <ul>
                <li><a href="#classes-and-objects">Classes and Objects</a></li>
                <li><a href="#constructors">Constructors</a></li>
                <li><a href="#destructors">Destructors</a></li>
                <li><a href="#inheritance">Inheritance</a></li>
                <li><a href="#polymorphism">Polymorphism</a></li>
                <li><a href="#encapsulation">Encapsulation</a></li>
            </ul>
    
            <h2>Standard Template Library (STL)</h2>
            <ul>
                <li><a href="#vectors">Vectors</a></li>
                <li><a href="#lists">Lists</a></li>
                <li><a href="#maps">Maps</a></li>
                <li><a href="#sets">Sets</a></li>
                <li><a href="#algorithms">Algorithms</a></li>
            </ul>
    
            <h2>File Handling</h2>
            <ul>
                <li><a href="#reading-files">Reading Files</a></li>
                <li><a href="#writing-files">Writing Files</a></li>
                <li><a href="#file-modes">File Modes</a></li>
                <li><a href="#working-with-files">Working with Files</a></li>
            </ul>
    
            <h2>Error and Exception Handling</h2>
            <ul>
                <li><a href="#syntax-errors">Syntax Errors</a></li>
                <li><a href="#exceptions">Exceptions</a></li>
                <li><a href="#try-and-catch">Try and Catch</a></li>
                <li><a href="#throwing-exceptions">Throwing Exceptions</a></li>
            </ul>
    
            <h2>Advanced Topics</h2>
            <ul>
                <li><a href="#operator-overloading">Operator Overloading</a></li>
                <li><a href="#templates">Templates</a></li>
                <li><a href="#namespaces">Namespaces</a></li>
                <li><a href="#dynamic-memory">Dynamic Memory</a></li>
            </ul>
    
            <h2>Miscellaneous</h2>
            <ul>
                <li><a href="#preprocessor-directives">Preprocessor Directives</a></li>
                <li><a href="#debugging-techniques">Debugging Techniques</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
        </div>

        

        <div class="main" id="overview">
            <h1>C++ Overview</h1>
        
            <h3>What is C++?</h3>
            <p>C++ is a <strong>statically typed</strong>, <strong>compiled</strong>, and <strong>general-purpose programming language</strong>.</p>
            <p>It supports multiple programming paradigms, such as:</p>
            <ul>
                <li><strong>Object-Oriented Programming</strong></li>
                <li><strong>Procedural Programming</strong></li>
                <li><strong>Generic Programming</strong></li>
            </ul>
            <p>C++ was developed by <strong>Bjarne Stroustrup</strong> as an extension of the C programming language in 1979.</p>
        
            <h3>Key Features of C++</h3>
            <ul>
                <li>
                    <strong>High Performance:</strong> C++ is known for its speed and efficiency, making it suitable for system programming and real-time applications.
                    <pre>
                    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                    // Example
                    #include <iostream>
                    using namespace std;
                    
                    int main() {
                        cout << "Hello, World!";
                        return 0;
                    }
                    </pre>
                </li>
                <li>
                    <strong>Object-Oriented:</strong> C++ supports encapsulation, inheritance, and polymorphism to design modular and reusable code.
                </li>
                <li>
                    <strong>Rich Standard Library:</strong> C++ offers the Standard Template Library (STL) for data structures, algorithms, and iterators.
                    <pre>
                    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                    // Example
                    #include <vector>
                    using namespace std;
                    
                    int main() {
                        vector<int> numbers = {1, 2, 3};
                        for (int num : numbers) {
                            cout << num << " ";
                        }
                        return 0;
                    }
                    </pre>
                </li>
                <li>
                    <strong>Platform Independence:</strong> C++ programs can run on various operating systems when compiled for the target platform.
                </li>
                <li>
                    <strong>Extensibility:</strong> C++ allows low-level memory manipulation, giving the developer fine-grained control over resource usage.
                </li>
                <li>
                    <strong>Community Support:</strong> C++ has a large community and extensive resources, including online forums and documentation.
                </li>
            </ul>
        
            <h3>Why Use C++?</h3>
            <p>C++ is versatile and widely used in fields such as:</p>
            <ul>
                <li><strong>System Programming:</strong> Operating systems, device drivers, and embedded systems.</li>
                <li><strong>Game Development:</strong> Popular engines like Unreal Engine use C++ for high-performance graphics and physics.</li>
                <li><strong>High-Performance Computing:</strong> Scientific simulations and computational models.</li>
                <li><strong>Software Development:</strong> Desktop applications, cross-platform libraries, and frameworks.</li>
                <li><strong>Finance and Trading:</strong> Real-time trading platforms and risk management systems.</li>
                <li><strong>IoT and Robotics:</strong> Embedded systems and robotics programming.</li>
            </ul>
        </div>
        


       
        

        <div class="main" id="installation-and-getting-started">
            <h1>Installation & Getting Started</h1>
        
            <h3>Step 1: Install a C++ Compiler</h3>
            <p>To write and run C++ programs, you need a compiler. Here are some popular options:</p>
            <ul>
                <li><strong>GCC (GNU Compiler Collection):</strong> Available for Linux, macOS, and Windows (via MinGW).</li>
                <li><strong>Clang:</strong> A powerful, fast compiler with wide platform support.</li>
                <li><strong>Microsoft Visual C++ (MSVC):</strong> Included in Visual Studio, suitable for Windows users.</li>
            </ul>
        
            <h3>Step 2: Choose a Code Editor or IDE</h3>
            <p>You can write C++ code in a simple text editor or an Integrated Development Environment (IDE) for better features like debugging and auto-completion. Popular options include:</p>
            <ul>
                <li><strong>Visual Studio:</strong> A feature-rich IDE for Windows users.</li>
                <li><strong>Visual Studio Code:</strong> A lightweight, cross-platform editor with C++ extensions.</li>
                <li><strong>CLion:</strong> A professional IDE from JetBrains with excellent C++ support.</li>
            </ul>
        
            <h3>Step 3: Write Your First C++ Program</h3>
            <p>Create a new file with a <code>.cpp</code> extension (e.g., <code>hello.cpp</code>) and write the following code:</p>
            <pre>
            <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
            // Example of a simple C++ program
            #include <iostream>
            using namespace std;
        
            int main() {
                cout << "Hello, World!";
                return 0;
            }
            </pre>
        
            <h3>Step 4: Compile and Run Your Program</h3>
            <p>Use a terminal or your IDE to compile and run your program:</p>
            <ul>
                <li><strong>Using GCC (on terminal):</strong></li>
                <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                // Compile the program
                g++ hello.cpp -o hello
        
                // Run the program
                ./hello
                </pre>
                <li><strong>Using an IDE:</strong> Most IDEs have a "Run" or "Build" button that automates the process.</li>
            </ul>
        
            <h3>Step 5: Debugging</h3>
            <p>Use debugging tools in your IDE or add <code>cout</code> statements to track variable values and program flow.</p>
        </div>



        <!-------------------C++ Syntax----------------------->

<div class="main" id="syntax">
    <h1>C++ Syntax</h1>

    <h3>Structure of a C++ Program</h3>
    <p>A basic C++ program has the following structure:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // This is a simple C++ program
    #include <iostream>  // Includes the Input/Output stream library
    using namespace std; // Allows using standard namespace elements

    int main() {
        cout << "Hello, World!"; // Outputs text to the console
        return 0;               // Exits the program successfully
    }
    </pre>
    <p>Key components of the structure:</p>
    <ul>
        <li><strong>#include &lt;iostream&gt;:</strong> Includes the standard input/output library.</li>
        <li><strong>using namespace std:</strong> Allows usage of standard names without the <code>std::</code> prefix.</li>
        <li><strong>int main():</strong> The entry point of the program where execution begins.</li>
        <li><strong>cout:</strong> Used to print output to the console.</li>
        <li><strong>return 0:</strong> Indicates successful execution of the program.</li>
    </ul>

    <h3>Semicolons and Braces</h3>
    <p>In C++, statements must end with a semicolon (<code>;</code>). Blocks of code are enclosed in curly braces <code>{ }</code>.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Example showing semicolons and braces
    int main() {
        int a = 10;          // Semicolon ends the statement
        if (a > 5) {         // Opening curly brace starts the block
            cout << "a is greater than 5"; // Code inside the block
        }                    // Closing curly brace ends the block
        return 0;
    }
    </pre>

    <h3>Comments</h3>
    <p>Comments are used to explain code and are ignored by the compiler. C++ supports:</p>
    <ul>
        <li><strong>Single-line comments:</strong> Begin with <code>//</code>.</li>
        <li><strong>Multi-line comments:</strong> Enclosed in <code>/* */</code>.</li>
    </ul>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Single-line comment
    int x = 10; // This is also a single-line comment

    /* Multi-line comment
       explaining the block below */
    int y = 20;
    cout << x + y;
    </pre>
</div>

    
<!-------------------C++ Comments----------------------->

<div class="main" id="comments">
    <h1>C++ Comments</h1>

    <h3>Introduction to Comments</h3>
    <p>Comments are used to explain the code and make it more readable. The C++ compiler ignores comments, so they do not affect the program's execution.</p>
    
    <h3>Types of Comments in C++</h3>
    <p>C++ supports two types of comments:</p>
    <ul>
        <li><strong>Single-line comments:</strong> Begin with <code>//</code> and extend to the end of the line.</li>
        <li><strong>Multi-line comments:</strong> Enclosed in <code>/* */</code> and can span multiple lines.</li>
    </ul>

    <h3>Single-line Comments</h3>
    <p>A single-line comment begins with <code>//</code>. Everything after the <code>//</code> on that line will be considered a comment.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // This is a single-line comment
    int x = 5; // Initialize variable
    cout << x;  // Output value of x
    </pre>

    <h3>Multi-line Comments</h3>
    <p>Multi-line comments are enclosed within <code>/* */</code> and can span multiple lines.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    /* This is a multi-line comment
       that spans multiple lines */
    int y = 10;
    cout << y;
    </pre>

    <h3>Commenting Best Practices</h3>
    <p>Comments should be used to:</p>
    <ul>
        <li>Explain the logic behind complex or non-obvious code.</li>
        <li>Indicate TODOs or sections of code that need improvement.</li>
        <li>Mark sections of code temporarily disabled (e.g., for debugging).</li>
    </ul>

    <h3>Example: Using Comments in a Program</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    int main() {
        // Declare two variables
        int a = 10;
        int b = 20;

        /* Add the two variables
           and store the result in c */
        int c = a + b;

        // Output the result
        cout << "The sum is: " << c;
        return 0;
    }
    </pre>
</div>


<!-------------------C++ Variables----------------------->

<div class="main" id="variables">
    <h1>C++ Variables</h1>

    <h3>Introduction to Variables</h3>
    <p>In C++, variables are used to store data that can be used and manipulated throughout the program. A variable must be declared with a specific type before it can be used.</p>

    <h3>Declaring Variables</h3>
    <p>To declare a variable in C++, you specify its type followed by its name. For example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int x; // Declares an integer variable named x
    double y; // Declares a double variable named y
    char z; // Declares a char variable named z
    </pre>
    
    <h3>Initializing Variables</h3>
    <p>When declaring a variable, you can also initialize it by assigning a value. For example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int x = 10;  // Declares and initializes x with value 10
    double y = 3.14;  // Declares and initializes y with value 3.14
    char z = 'A';  // Declares and initializes z with value 'A'
    </pre>

    <h3>Variable Types</h3>
    <p>C++ supports a variety of variable types, including:</p>
    <ul>
        <li><strong>int:</strong> Used to store integer values (e.g., 5, -10, 100).</li>
        <li><strong>double:</strong> Used to store floating-point numbers with double precision (e.g., 3.14, -0.001).</li>
        <li><strong>char:</strong> Used to store single characters (e.g., 'A', 'z').</li>
        <li><strong>bool:</strong> Used to store boolean values (<code>true</code> or <code>false</code>).</li>
        <li><strong>string:</strong> Used to store sequences of characters (e.g., "Hello, World!").</li>
    </ul>

    <h3>Example: Using Variables in a Program</h3>
    <p>Here is an example that demonstrates the use of variables:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    int main() {
        // Declare and initialize variables
        int a = 10;
        double b = 20.5;
        char c = 'A';
        
        // Output values of variables
        cout << "a = " << a << endl;
        cout << "b = " << b << endl;
        cout << "c = " << c << endl;
        
        return 0;
    }
    </pre>

    <h3>Variable Scope</h3>
    <p>The scope of a variable determines where it can be accessed in the program. There are two main types of scope in C++:</p>
    <ul>
        <li><strong>Local scope:</strong> Variables declared inside a function are accessible only within that function.</li>
        <li><strong>Global scope:</strong> Variables declared outside any function are accessible to all functions in the program.</li>
    </ul>

    <h3>Constant Variables</h3>
    <p>If a variable's value should not change, you can declare it as a constant using the <code>const</code> keyword:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    const int MAX_VALUE = 100; // Declares a constant variable
    </pre>

</div>


<!-------------------Primitive Data Types----------------------->

<div class="main" id="numbers">
    <h2>Primitive Data Types</h2>

    <h3>Introduction to Primitive Data Types</h3>
    <p>In C++, primitive data types are the basic types that represent simple values. These data types are built into the language and do not require any libraries to be used.</p>

    <h3>Common Primitive Data Types in C++</h3>
    <p>The following are the most commonly used primitive data types in C++:</p>
    <ul>
        <li><strong>int:</strong> Represents integer values (e.g., 1, -10, 500).</li>
        <li><strong>float:</strong> Represents single-precision floating-point values (e.g., 3.14, -0.0012).</li>
        <li><strong>double:</strong> Represents double-precision floating-point values (e.g., 3.14159, -999.99).</li>
        <li><strong>char:</strong> Represents a single character (e.g., 'a', 'Z').</li>
        <li><strong>bool:</strong> Represents a boolean value (either <code>true</code> or <code>false</code>).</li>
    </ul>

    <h3>Example of Primitive Data Types</h3>
    <p>This example shows how to declare and use different primitive data types in C++:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    int main() {
        // Declare and initialize primitive data types
        int age = 25;          // Integer
        float height = 5.9f;   // Float
        double pi = 3.14159;   // Double
        char grade = 'A';      // Char
        bool isPassed = true;  // Boolean

        // Output the values of the variables
        cout << "Age: " << age << endl;
        cout << "Height: " << height << endl;
        cout << "Pi: " << pi << endl;
        cout << "Grade: " << grade << endl;
        cout << "Passed: " << isPassed << endl;

        return 0;
    }
    </pre>

    <h3>Size and Range of Primitive Data Types</h3>
    <p>The size of each primitive data type depends on the system architecture, but here are common ranges:</p>
    <ul>
        <li><strong>int:</strong> Typically 4 bytes (range: -2,147,483,648 to 2,147,483,647).</li>
        <li><strong>float:</strong> Typically 4 bytes (range: ±1.5 × 10<sup>-45</sup> to ±3.4 × 10<sup>38</sup>).</li>
        <li><strong>double:</strong> Typically 8 bytes (range: ±5.0 × 10<sup>-324</sup> to ±1.7 × 10<sup>308</sup>).</li>
        <li><strong>char:</strong> Typically 1 byte (range: -128 to 127 for signed char, 0 to 255 for unsigned char).</li>
        <li><strong>bool:</strong> Typically 1 byte (values: <code>true</code> or <code>false</code>).</li>
    </ul>

    <h3>Type Modifiers for Primitive Data Types</h3>
    <p>C++ allows modifying the size and range of some primitive data types using type modifiers. These include:</p>
    <ul>
        <li><strong>signed:</strong> Specifies that a data type can hold both positive and negative values.</li>
        <li><strong>unsigned:</strong> Specifies that a data type can hold only non-negative values.</li>
        <li><strong>long:</strong> Increases the size of an integer type.</li>
        <li><strong>short:</strong> Decreases the size of an integer type.</li>
    </ul>
    <p>Example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    unsigned int count = 100; // unsigned integer
    short int temperature = -5; // short integer
    </pre>

</div>


<!-------------------Strings----------------------->

<div class="main" id="strings">
    <h2>Strings</h2>

    <h3>Introduction to Strings</h3>
    <p>In C++, a string is a sequence of characters enclosed in double quotes. C++ provides several ways to handle strings, including C-style strings (character arrays) and the C++ Standard Library <code>string</code> class.</p>

    <h3>C-style Strings</h3>
    <p>A C-style string is an array of characters terminated by a null character <code>'\0'</code>. It is a simple, low-level way to work with strings, and is often used in older C++ code.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // C-style string declaration
    char greeting[] = "Hello, World!";  // Null-terminated array of characters

    cout << greeting;  // Outputs "Hello, World!"
    </pre>

    <h3>C++ String Class</h3>
    <p>The C++ Standard Library provides the <code>string</code> class, which is more flexible and easier to work with compared to C-style strings. It automatically manages memory, and provides a variety of useful functions for string manipulation.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    #include <string>  // Include the string library

    using namespace std;

    int main() {
        // C++ string declaration and initialization
        string greeting = "Hello, World!";

        // Output the string
        cout << greeting;  // Outputs "Hello, World!"
        return 0;
    }
    </pre>

    <h3>Common String Operations</h3>
    <p>The C++ <code>string</code> class provides many useful operations. Here are a few common ones:</p>
    <ul>
        <li><strong>Length of a string:</strong> <code>length()</code> or <code>size()</code> returns the number of characters in the string.</li>
        <li><strong>Concatenation:</strong> Use the <code>+</code> operator to concatenate strings.</li>
        <li><strong>Accessing characters:</strong> Use the <code>[]</code> operator or the <code>at()</code> method to access individual characters in the string.</li>
    </ul>

    <h3>Examples of String Operations</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        // Declare strings
        string str1 = "Hello";
        string str2 = "World";
        
        // Concatenate strings
        string greeting = str1 + ", " + str2 + "!";
        cout << greeting << endl;  // Output: Hello, World!

        // Access characters in a string
        cout << "First character of str1: " << str1[0] << endl;  // Output: H
        cout << "Length of str2: " << str2.length() << endl;  // Output: 5

        return 0;
    }
    </pre>

    <h3>String Comparison</h3>
    <p>You can compare strings using relational operators or the <code>compare()</code> method:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        string str1 = "apple";
        string str2 = "banana";

        // Compare strings using relational operators
        if (str1 < str2) {
            cout << str1 << " is less than " << str2 << endl;
        }

        // Compare strings using compare() method
        if (str1.compare(str2) != 0) {
            cout << "The strings are not equal" << endl;
        }

        return 0;
    }
    </pre>

    <h3>String Input and Output</h3>
    <p>To input and output strings in C++, you can use <code>cin</code> and <code>cout</code>. Note that <code>cin</code> ignores spaces, so to input a full line, use <code>getline()</code>.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        string name;
        cout << "Enter your name: ";
        getline(cin, name);  // Read a full line, including spaces
        cout << "Hello, " << name << "!" << endl;
        return 0;
    }
    </pre>

</div>


<!-------------------Arrays----------------------->

<div class="main" id="arrays">
    <h2>Arrays</h2>

    <h3>Introduction to Arrays</h3>
    <p>An array in C++ is a collection of variables of the same type that are stored in contiguous memory locations. Arrays allow you to store multiple values under a single variable name, making it easier to work with collections of data.</p>

    <h3>Declaring Arrays</h3>
    <p>To declare an array, specify the type of the elements, followed by the array name and the size in square brackets. The size represents the number of elements the array can hold.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int numbers[5];  // Declare an integer array with 5 elements
    double prices[10];  // Declare a double array with 10 elements
    char letters[3];  // Declare a character array with 3 elements
    </pre>

    <h3>Initializing Arrays</h3>
    <p>You can initialize an array at the time of declaration by providing a list of values in curly braces. The size of the array can be omitted if you initialize it with values.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int numbers[5] = {1, 2, 3, 4, 5};  // Initialize an integer array with 5 elements
    double prices[] = {10.99, 20.50, 30.75};  // Initialize a double array (size inferred)
    char letters[] = {'a', 'b', 'c'};  // Initialize a character array (size inferred)
    </pre>

    <h3>Accessing Array Elements</h3>
    <p>Array elements are accessed using the array name and an index, where the index starts at 0. For example, <code>numbers[0]</code> accesses the first element of the array.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int numbers[5] = {1, 2, 3, 4, 5};
    cout << numbers[0];  // Output: 1 (first element)
    cout << numbers[4];  // Output: 5 (fifth element)
    </pre>

    <h3>Iterating through Arrays</h3>
    <p>To process each element of an array, you can use a loop, typically a <code>for</code> loop. Here’s an example of using a loop to iterate through an array:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int numbers[5] = {1, 2, 3, 4, 5};

    for (int i = 0; i < 5; i++) {
        cout << numbers[i] << " ";  // Output: 1 2 3 4 5
    }
    </pre>

    <h3>Multidimensional Arrays</h3>
    <p>C++ also supports multidimensional arrays. A two-dimensional array can be thought of as a table (rows and columns). Here’s how you declare and initialize a 2D array:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};  // 2D array with 2 rows and 3 columns
    cout << matrix[0][1];  // Output: 2 (element in first row, second column)
    </pre>

    <h3>Array Size</h3>
    <p>To find the size of an array, you can use the <code>sizeof</code> operator. The total size of the array is the size of one element multiplied by the number of elements.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int numbers[5] = {1, 2, 3, 4, 5};
    int size = sizeof(numbers) / sizeof(numbers[0]);  // Calculate the number of elements
    cout << "Array size: " << size;  // Output: 5
    </pre>

    <h3>Common Array Operations</h3>
    <ul>
        <li><strong>Finding the maximum or minimum value:</strong> Use a loop to iterate through the array and compare values.</li>
        <li><strong>Reversing an array:</strong> Swap elements from both ends of the array towards the middle.</li>
        <li><strong>Searching for an element:</strong> Iterate through the array and compare each element to find a match.</li>
    </ul>

    <h3>Example: Array Operations</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int numbers[5] = {10, 20, 30, 40, 50};

    // Find the maximum value
    int max = numbers[0];
    for (int i = 1; i < 5; i++) {
        if (numbers[i] > max) {
            max = numbers[i];
        }
    }
    cout << "Maximum value: " << max << endl;  // Output: 50
    </pre>

</div>


<!-------------------Pointers----------------------->

<div class="main" id="pointers">
    <h2>Pointers</h2>

    <h3>Introduction to Pointers</h3>
    <p>A pointer in C++ is a variable that stores the memory address of another variable. Pointers are a powerful feature of C++ that allows you to work directly with memory and manipulate data efficiently.</p>

    <h3>Declaring Pointers</h3>
    <p>To declare a pointer, use the <code>*</code> operator, which indicates that the variable is a pointer. The pointer must be of the same type as the variable it will point to.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int num = 10;      // Regular variable
    int *ptr;          // Pointer to an integer
    ptr = &num;        // Store the address of num in ptr
    </pre>

    <h3>Dereferencing Pointers</h3>
    <p>Dereferencing a pointer means accessing the value stored at the memory address the pointer is pointing to. This is done using the <code>*</code> operator again.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int num = 10;
    int *ptr = &num;  // Pointer to num

    // Dereferencing to access the value
    cout << *ptr;  // Output: 10 (value stored at the address of num)
    </pre>

    <h3>Pointer Arithmetic</h3>
    <p>Pointers in C++ support arithmetic operations, which can be used to move between different memory locations in an array or other data structures.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;  // Pointer to the first element of the array

    // Accessing array elements using pointer arithmetic
    cout << *(ptr + 2);  // Output: 3 (third element of the array)
    </pre>

    <h3>Null Pointers</h3>
    <p>A null pointer is a pointer that does not point to any valid memory location. It is usually used to indicate that the pointer is uninitialized or invalid.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int *ptr = nullptr;  // Null pointer
    if (ptr == nullptr) {
        cout << "Pointer is null." << endl;  // Output: Pointer is null.
    }
    </pre>

    <h3>Pointer to Pointer</h3>
    <p>C++ allows you to have a pointer that points to another pointer. This is known as a pointer to pointer.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int num = 10;
    int *ptr = &num;         // Pointer to num
    int **ptr2 = &ptr;       // Pointer to pointer

    cout << **ptr2;  // Dereferencing twice to access the value: Output: 10
    </pre>

    <h3>Dynamic Memory Allocation</h3>
    <p>C++ allows you to allocate memory dynamically using the <code>new</code> operator, and free it using the <code>delete</code> operator.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int *ptr = new int;  // Dynamically allocate memory for an integer
    *ptr = 25;           // Assign a value to the dynamically allocated memory
    cout << *ptr;        // Output: 25

    delete ptr;          // Free the allocated memory
    </pre>

    <h3>Example: Using Pointers with Functions</h3>
    <p>Pointers can also be used to pass arguments by reference to functions, allowing you to modify the original values directly.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    void increment(int *p) {
        (*p)++;  // Dereference pointer and increment the value
    }

    int main() {
        int num = 5;
        cout << "Before increment: " << num << endl;  // Output: 5
        increment(&num);  // Pass the address of num to the function
        cout << "After increment: " << num << endl;   // Output: 6
        return 0;
    }
    </pre>

</div>





<!-------------------Enumerations----------------------->

<div class="main" id="enumerations">
    <h2>Enumerations</h2>

    <h3>Introduction to Enumerations</h3>
    <p>An enumeration (enum) in C++ is a user-defined data type that consists of a set of named integral constants. It allows you to define variables that can only take a limited set of values, improving the clarity and readability of the code.</p>

    <h3>Declaring an Enumeration</h3>
    <p>To declare an enumeration, use the <code>enum</code> keyword, followed by the enumeration name and a list of constant values enclosed in curly braces.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    enum Day {
        Sunday,    // 0
        Monday,    // 1
        Tuesday,   // 2
        Wednesday, // 3
        Thursday,  // 4
        Friday,    // 5
        Saturday   // 6
    };
    </pre>

    <h3>Assigning Values to Enum Members</h3>
    <p>By default, the first value of an enumeration is assigned 0, and the value of each subsequent member is incremented by 1. However, you can explicitly assign values to the members of an enumeration.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    enum Day {
        Sunday = 1,    // 1
        Monday = 2,    // 2
        Tuesday = 3,   // 3
        Wednesday = 4, // 4
        Thursday = 5,  // 5
        Friday = 6,    // 6
        Saturday = 7   // 7
    };
    </pre>

    <h3>Using Enumerations</h3>
    <p>Once an enumeration is declared, you can use the enumeration type to declare variables. You can also assign integer values to these variables, but the values should correspond to the defined enumeration constants.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    enum Day { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday };

    Day today = Wednesday;  // Assigning an enum value to a variable
    cout << today;  // Output: 3 (integer value of Wednesday)
    </pre>

    <h3>Enumerations with Explicit Values</h3>
    <p>When you assign explicit values to enumeration members, you can use them in the same way, but the integer values you assigned will be used instead of the default values.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    enum Day {
        Sunday = 1,
        Monday = 2,
        Tuesday = 3,
        Wednesday = 4,
        Thursday = 5,
        Friday = 6,
        Saturday = 7
    };

    Day today = Friday;  // Assigning an enum value to a variable
    cout << today;  // Output: 6 (integer value of Friday)
    </pre>

    <h3>Enum as Flags</h3>
    <p>Enumerations can also be used to represent flags (a set of binary options). This is done by assigning powers of 2 to each member of the enum so they can be combined using bitwise operations.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    enum Permissions {
        Read = 1,   // 1 (2^0)
        Write = 2,  // 2 (2^1)
        Execute = 4 // 4 (2^2)
    };

    Permissions userPermissions = Read | Write;  // Combining flags using bitwise OR
    cout << userPermissions;  // Output: 3 (Read + Write)
    </pre>

    <h3>Enum Classes (Scoped Enums)</h3>
    <p>C++11 introduced scoped enumerations (enum classes), which provide better type safety by preventing implicit conversions to integer types and allowing better scoping of the enum members.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    enum class Day {
        Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
    };

    Day today = Day::Wednesday;  // Accessing enum members with scope resolution operator
    cout << static_cast<int>(today);  // Output: 3 (integer value of Wednesday)
    </pre>

    <h3>Example: Using Enumerations in Switch Case</h3>
    <p>Enumerations can be used in switch statements, allowing for more readable and maintainable code when dealing with a fixed set of values.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    enum Day { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday };

    void printDay(Day d) {
        switch(d) {
            case Sunday: cout << "Sunday"; break;
            case Monday: cout << "Monday"; break;
            case Tuesday: cout << "Tuesday"; break;
            case Wednesday: cout << "Wednesday"; break;
            case Thursday: cout << "Thursday"; break;
            case Friday: cout << "Friday"; break;
            case Saturday: cout << "Saturday"; break;
        }
    }

    int main() {
        Day today = Tuesday;
        printDay(today);  // Output: Tuesday
        return 0;
    }
    </pre>

</div>


<!-------------------If Statements----------------------->

<div class="main" id="if-statements">
    <h2>If Statements</h2>

    <h3>Introduction to If Statements</h3>
    <p>The <code>if</code> statement is used to execute a block of code based on a condition. If the condition evaluates to <code>true</code>, the code inside the block is executed; otherwise, it is skipped.</p>

    <h3>Basic Syntax</h3>
    <p>The basic syntax of an <code>if</code> statement is as follows:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    if (condition) {
        // Code to execute if condition is true
    }
    </pre>

    <h3>Example of an If Statement</h3>
    <p>The following example demonstrates an <code>if</code> statement that checks if a number is positive:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int number = 10;

    if (number > 0) {
        cout << "The number is positive." << endl;
    }
    </pre>
    <p>If the condition <code>number > 0</code> is true, the program will output "The number is positive."</p>

    <h3>If-Else Statement</h3>
    <p>The <code>if-else</code> statement allows you to execute one block of code if the condition is true and another block if it is false.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int number = -5;

    if (number > 0) {
        cout << "The number is positive." << endl;
    } else {
        cout << "The number is not positive." << endl;
    }
    </pre>
    <p>If <code>number > 0</code> is false, the program will output "The number is not positive."</p>

    <h3>If-Else If-Else Statement</h3>
    <p>The <code>if-else if-else</code> statement allows you to check multiple conditions. If the first condition is false, the program checks the next <code>else if</code> condition, and so on. If no conditions are true, the code in the final <code>else</code> block is executed.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int number = 0;

    if (number > 0) {
        cout << "The number is positive." << endl;
    } else if (number < 0) {
        cout << "The number is negative." << endl;
    } else {
        cout << "The number is zero." << endl;
    }
    </pre>
    <p>In this example, the program will output "The number is zero" because the value of <code>number</code> is 0.</p>

    <h3>Nested If Statements</h3>
    <p>You can place one <code>if</code> statement inside another. These are called nested <code>if</code> statements.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int number = 10;

    if (number > 0) {
        if (number % 2 == 0) {
            cout << "The number is positive and even." << endl;
        } else {
            cout << "The number is positive and odd." << endl;
        }
    } else {
        cout << "The number is not positive." << endl;
    }
    </pre>
    <p>In this example, the program will output "The number is positive and even" because the number is greater than 0 and divisible by 2.</p>

    <h3>Logical Operators in If Statements</h3>
    <p>You can combine multiple conditions in an <code>if</code> statement using logical operators:</p>
    <ul>
        <li><code>&&</code> (AND): True if both conditions are true.</li>
        <li><code>||</code> (OR): True if at least one condition is true.</li>
        <li><code>!</code> (NOT): Reverses the condition.</li>
    </ul>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int a = 10, b = 20;

    if (a > 0 && b > 0) {
        cout << "Both numbers are positive." << endl;
    }

    if (a < 0 || b < 0) {
        cout << "At least one number is negative." << endl;
    }

    if (!(a < 0)) {
        cout << "The first number is not negative." << endl;
    }
    </pre>

    <h3>Example with Multiple Conditions</h3>
    <p>In this example, we check whether a number is positive, even, and divisible by 5:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int number = 10;

    if (number > 0 && number % 2 == 0 && number % 5 == 0) {
        cout << "The number is positive, even, and divisible by 5." << endl;
    }
    </pre>

</div>


<!-------------------For Loops----------------------->

<div class="main" id="for-loops">
    <h2>For Loops</h2>

    <h3>Introduction to For Loops</h3>
    <p>A <code>for</code> loop is used to execute a block of code a specified number of times. It is commonly used when the number of iterations is known beforehand.</p>

    <h3>Basic Syntax of a For Loop</h3>
    <p>The basic syntax of a <code>for</code> loop is as follows:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (initialization; condition; increment/decrement) {
        // Code to execute in each iteration
    }
    </pre>

    <h3>Example: Simple For Loop</h3>
    <p>The following example demonstrates a basic <code>for</code> loop that prints numbers from 1 to 5:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (int i = 1; i <= 5; i++) {
        cout << i << endl;
    }
    </pre>
    <p>The loop starts by initializing <code>i</code> to 1, and the condition <code>i <= 5</code> is checked before each iteration. After executing the code inside the loop, <code>i</code> is incremented by 1 until the condition becomes false.</p>

    <h3>For Loop with Multiple Initializations and Increments</h3>
    <p>You can also initialize multiple variables and have multiple increments or decrements in a <code>for</code> loop.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (int i = 0, j = 10; i <= 5; i++, j--) {
        cout << "i: " << i << ", j: " << j << endl;
    }
    </pre>
    <p>In this example, <code>i</code> is incremented and <code>j</code> is decremented in each iteration. The loop will execute as long as <code>i <= 5</code>.</p>

    <h3>Nested For Loops</h3>
    <p>A nested <code>for</code> loop is a loop inside another loop. The inner loop is executed completely for every iteration of the outer loop.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (int i = 1; i <= 3; i++) {
        for (int j = 1; j <= 3; j++) {
            cout << "i: " << i << ", j: " << j << endl;
        }
    }
    </pre>
    <p>This will produce a combination of <code>i</code> and <code>j</code> values, where for each value of <code>i</code>, the inner loop will run completely.</p>

    <h3>For Loop with Break and Continue</h3>
    <p>You can control the flow of a <code>for</code> loop using <code>break</code> and <code>continue</code>.</p>
    <ul>
        <li><strong>break:</strong> Terminates the loop immediately.</li>
        <li><strong>continue:</strong> Skips the current iteration and moves to the next iteration.</li>
    </ul>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (int i = 0; i < 5; i++) {
        if (i == 2) {
            continue;  // Skip the iteration when i is 2
        }
        if (i == 4) {
            break;  // Exit the loop when i is 4
        }
        cout << i << endl;
    }
    </pre>
    <p>In this example, the number 2 is skipped, and the loop ends before printing the number 4 due to the <code>break</code>.</p>

    <h3>For Each Loop (Range-Based For Loop)</h3>
    <p>C++11 introduced the range-based <code>for</code> loop, which iterates over each element in a container (such as an array or vector) without needing an index variable.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int arr[] = {1, 2, 3, 4, 5};

    for (int x : arr) {
        cout << x << endl;
    }
    </pre>
    <p>This range-based <code>for</code> loop iterates over each element in the array <code>arr</code> and prints the value of each element.</p>

</div>


<!-------------------While Loops----------------------->

<div class="main" id="while-loops">
    <h2>While Loops</h2>

    <h3>Introduction to While Loops</h3>
    <p>A <code>while</code> loop repeatedly executes a block of code as long as a specified condition is true. The condition is checked before each iteration, and if it is true, the loop continues; otherwise, it stops.</p>

    <h3>Basic Syntax of a While Loop</h3>
    <p>The basic syntax of a <code>while</code> loop is as follows:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    while (condition) {
        // Code to execute in each iteration
    }
    </pre>

    <h3>Example: Simple While Loop</h3>
    <p>The following example demonstrates a basic <code>while</code> loop that prints numbers from 1 to 5:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int i = 1;
    while (i <= 5) {
        cout << i << endl;
        i++;  // Increment the value of i in each iteration
    }
    </pre>
    <p>The loop continues as long as the condition <code>i <= 5</code> is true. After each iteration, the value of <code>i</code> is incremented, and the loop stops once <code>i</code> exceeds 5.</p>

    <h3>Infinite Loop</h3>
    <p>If the condition in a <code>while</code> loop is always true, the loop will run indefinitely, which is known as an infinite loop. You should be careful to avoid such loops in your program, unless you want the program to run forever until stopped manually.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    while (true) {
        cout << "This is an infinite loop" << endl;
        // The loop will never stop unless we break out of it manually
    }
    </pre>

    <h3>While Loop with Break and Continue</h3>
    <p>You can control the flow of a <code>while</code> loop using <code>break</code> and <code>continue</code>.</p>
    <ul>
        <li><strong>break:</strong> Terminates the loop immediately.</li>
        <li><strong>continue:</strong> Skips the current iteration and moves to the next iteration.</li>
    </ul>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int i = 0;
    while (i < 5) {
        if (i == 2) {
            continue;  // Skip the iteration when i is 2
        }
        if (i == 4) {
            break;  // Exit the loop when i is 4
        }
        cout << i << endl;
        i++;
    }
    </pre>
    <p>In this example, the number 2 is skipped, and the loop ends before printing the number 4 due to the <code>break</code>.</p>

    <h3>Do-While Loop</h3>
    <p>A <code>do-while</code> loop is similar to a <code>while</code> loop, but with one important difference: the condition is checked after the code block has executed. This means that the code inside the loop will always be executed at least once, even if the condition is false initially.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int i = 1;
    do {
        cout << i << endl;
        i++;
    } while (i <= 5);
    </pre>
    <p>In this example, the loop will print numbers from 1 to 5, as the condition is checked after the loop runs for the first time.</p>

</div>


<!-------------------Switch Statements----------------------->

<div class="main" id="switch-statements">
    <h2>Switch Statements</h2>

    <h3>Introduction to Switch Statements</h3>
    <p>The <code>switch</code> statement allows you to execute one out of many code blocks based on the value of a variable or expression. It is often used when you have multiple conditions that depend on the same variable, making it more readable than multiple <code>if-else</code> statements.</p>

    <h3>Basic Syntax of a Switch Statement</h3>
    <p>The basic syntax of a <code>switch</code> statement is as follows:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    switch (expression) {
        case value1:
            // Code to execute if expression == value1
            break;
        case value2:
            // Code to execute if expression == value2
            break;
        default:
            // Code to execute if no case matches
    }
    </pre>

    <h3>Example: Simple Switch Statement</h3>
    <p>The following example demonstrates a simple <code>switch</code> statement that prints a message based on the value of a variable:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int day = 3;

    switch (day) {
        case 1:
            cout << "Monday" << endl;
            break;
        case 2:
            cout << "Tuesday" << endl;
            break;
        case 3:
            cout << "Wednesday" << endl;
            break;
        default:
            cout << "Invalid day" << endl;
    }
    </pre>
    <p>In this example, the program will output "Wednesday" because the value of <code>day</code> is 3. The <code>break</code> statement ensures that the program exits the <code>switch</code> after the matched case is executed.</p>

    <h3>Default Case</h3>
    <p>The <code>default</code> case is optional and is used when no cases match the expression. If no case matches and the <code>default</code> case is present, the code inside it will be executed. If the <code>default</code> case is absent, the <code>switch</code> statement simply does nothing if no matches are found.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int day = 10;

    switch (day) {
        case 1:
            cout << "Monday" << endl;
            break;
        case 2:
            cout << "Tuesday" << endl;
            break;
        case 3:
            cout << "Wednesday" << endl;
            break;
        default:
            cout << "Invalid day" << endl;
    }
    </pre>
    <p>In this example, since <code>day</code> is 10, which doesn’t match any case, the program will output "Invalid day".</p>

    <h3>Fall-Through Behavior</h3>
    <p>In C++, if you omit the <code>break</code> statement, the program will "fall through" to the next case and execute it as well, even if that case doesn’t match the expression. This is known as fall-through behavior.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int day = 1;

    switch (day) {
        case 1:
            cout << "Monday" << endl;
        case 2:
            cout << "Tuesday" << endl;
        case 3:
            cout << "Wednesday" << endl;
            break;
        default:
            cout << "Invalid day" << endl;
    }
    </pre>
    <p>In this example, the output will be "Monday", "Tuesday", and "Wednesday" because the <code>break</code> statement is missing from the first two cases. The program falls through and executes all the subsequent cases until the <code>break</code> is reached.</p>

    <h3>Switch Statement with Multiple Cases</h3>
    <p>Multiple cases can be grouped together if they execute the same block of code. This helps to reduce code duplication.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int day = 2;

    switch (day) {
        case 1:
        case 2:
        case 3:
            cout << "Weekday" << endl;
            break;
        case 4:
        case 5:
            cout << "Weekend" << endl;
            break;
        default:
            cout << "Invalid day" << endl;
    }
    </pre>
    <p>In this example, since <code>day</code> is 2, the program will output "Weekday", as cases 1, 2, and 3 all lead to the same code block.</p>

    <h3>Switch with Char or String Expressions</h3>
    <p>You can use characters or strings as expressions in a <code>switch</code> statement. The behavior is the same as with integers.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    char grade = 'A';

    switch (grade) {
        case 'A':
            cout << "Excellent" << endl;
            break;
        case 'B':
            cout << "Good" << endl;
            break;
        case 'C':
            cout << "Average" << endl;
            break;
        default:
            cout << "Invalid grade" << endl;
    }
    </pre>
    <p>This example will output "Excellent" because the value of <code>grade</code> is 'A'.</p>

</div>


<!-------------------Break and Continue----------------------->

<div class="main" id="break-and-continue">
    <h2>Break and Continue</h2>

    <h3>Introduction to Break and Continue</h3>
    <p>The <code>break</code> and <code>continue</code> statements are used to control the flow of loops and switch statements in C++. These keywords allow you to alter the normal flow of execution in loops, making your code more flexible and efficient.</p>

    <h3>Break Statement</h3>
    <p>The <code>break</code> statement is used to exit a loop or a switch statement immediately. When <code>break</code> is encountered, the program execution is transferred to the first statement after the loop or switch block, effectively terminating the loop or switch early.</p>

    <h4>Break in a Loop</h4>
    <p>The <code>break</code> statement can be used in <code>for</code>, <code>while</code>, and <code>do-while</code> loops to exit the loop prematurely.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (int i = 0; i < 5; i++) {
        if (i == 3) {
            break;  // Exit the loop when i is 3
        }
        cout << i << endl;
    }
    </pre>
    <p>In this example, the loop will print numbers from 0 to 2 and then exit when <code>i</code> becomes 3 because of the <code>break</code> statement.</p>

    <h4>Break in a Switch Statement</h4>
    <p>In a <code>switch</code> statement, the <code>break</code> keyword is used to terminate the execution of a case and exit the <code>switch</code> block.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int day = 2;

    switch (day) {
        case 1:
            cout << "Monday" << endl;
            break;
        case 2:
            cout << "Tuesday" << endl;
            break;
        case 3:
            cout << "Wednesday" << endl;
            break;
        default:
            cout << "Invalid day" << endl;
    }
    </pre>
    <p>The program will print "Tuesday" and exit the <code>switch</code> statement due to the <code>break</code>.</p>

    <h3>Continue Statement</h3>
    <p>The <code>continue</code> statement is used to skip the remaining code in the current iteration of the loop and proceed to the next iteration. Unlike <code>break</code>, which exits the loop, <code>continue</code> just skips to the next iteration.</p>

    <h4>Continue in a Loop</h4>
    <p>The <code>continue</code> statement is often used when certain conditions need to be skipped within a loop but the loop should continue processing other iterations.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (int i = 0; i < 5; i++) {
        if (i == 2) {
            continue;  // Skip the iteration when i is 2
        }
        cout << i << endl;
    }
    </pre>
    <p>In this example, the loop will print the numbers 0, 1, 3, and 4, but it will skip printing 2 due to the <code>continue</code> statement.</p>

    <h4>Continue in a While Loop</h4>
    <p>You can also use <code>continue</code> in <code>while</code> loops to skip the current iteration and continue to the next one.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int i = 0;
    while (i < 5) {
        i++;
        if (i == 3) {
            continue;  // Skip the iteration when i is 3
        }
        cout << i << endl;
    }
    </pre>
    <p>In this example, the output will be 1, 2, 4, and 5. The value 3 is skipped due to the <code>continue</code> statement.</p>

    <h3>Break and Continue Together</h3>
    <p>Both <code>break</code> and <code>continue</code> can be used together in a loop. While <code>break</code> exits the loop entirely, <code>continue</code> only skips the current iteration and moves to the next one.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    for (int i = 0; i < 5; i++) {
        if (i == 2) {
            continue;  // Skip when i is 2
        }
        if (i == 4) {
            break;  // Exit the loop when i is 4
        }
        cout << i << endl;
    }
    </pre>
    <p>In this example, the loop will print 0, 1, and 3, then exit when <code>i</code> becomes 4 due to the <code>break</code> statement.</p>

</div>

<!-------------------Defining Functions----------------------->

<div class="main" id="defining-functions">
    <h2>Defining Functions</h2>

    <h3>Introduction to Functions</h3>
    <p>A function is a block of code that performs a specific task. Functions in C++ help in code reuse and organizing code into smaller, manageable parts. You can define your own functions, which can be called from other parts of the program.</p>

    <h3>Basic Syntax for Defining a Function</h3>
    <p>The basic syntax for defining a function in C++ includes the return type, function name, parameters (if any), and the body of the function. Here's the general format:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    return_type function_name(parameter1, parameter2, ...) {
        // Function body
    }
    </pre>
    <p>Where:</p>
    <ul>
        <li><strong>return_type:</strong> Specifies the type of value the function will return (e.g., <code>int</code>, <code>void</code>).</li>
        <li><strong>function_name:</strong> The name you assign to the function.</li>
        <li><strong>parameter1, parameter2, ...:</strong> The values passed to the function (optional). These are the inputs to the function.</li>
        <li><strong>function body:</strong> Contains the code that the function executes.</li>
    </ul>

    <h3>Example: Defining a Simple Function</h3>
    <p>This example defines a function that adds two numbers and returns the result:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    // Function to add two numbers
    int add(int a, int b) {
        return a + b;  // Return the sum of a and b
    }

    int main() {
        int result = add(3, 5);  // Calling the function
        cout << "The sum is: " << result << endl;  // Output the result
        return 0;
    }
    </pre>
    <p>In this example, the function <code>add</code> takes two parameters (<code>a</code> and <code>b</code>) and returns their sum. The function is called from <code>main</code>, and the result is printed.</p>

    <h3>Function Without Parameters</h3>
    <p>A function may not have any parameters. In such cases, you just define the function without any input values:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    void greet() {
        cout << "Hello, World!" << endl;  // Print a greeting
    }

    int main() {
        greet();  // Calling the function
        return 0;
    }
    </pre>
    <p>In this example, the <code>greet</code> function does not take any parameters and simply prints a greeting when called.</p>

    <h3>Function with No Return Value (void)</h3>
    <p>In some cases, a function does not need to return any value. For such functions, the return type is specified as <code>void</code>:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    void displayMessage() {
        cout << "This is a message from the function!" << endl;
    }

    int main() {
        displayMessage();  // Calling the function
        return 0;
    }
    </pre>
    <p>The function <code>displayMessage</code> in this example does not return a value, so it is declared with the <code>void</code> return type.</p>

    <h3>Function Overloading</h3>
    <p>C++ allows function overloading, meaning you can define multiple functions with the same name but different parameters. The compiler differentiates the functions based on the number or types of parameters.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int main() {
        cout << add(3, 5) << endl;      // Calls the integer version
        cout << add(3.5, 5.2) << endl;  // Calls the double version
        return 0;
    }
    </pre>
    <p>In this example, the function <code>add</code> is overloaded to handle both integer and double parameters.</p>

</div>


<!-------------------Arguments and Parameters----------------------->

<div class="main" id="arguments-and-parameters">
    <h2>Arguments and Parameters</h2>

    <h3>Introduction to Arguments and Parameters</h3>
    <p>In C++, functions can take inputs, known as arguments. These arguments are passed to the function via parameters, which are variables defined in the function declaration. The function can then use these parameters in its body to perform its task.</p>

    <h3>Parameters</h3>
    <p>Parameters are variables defined in the function definition that accept the values passed when the function is called. They act as placeholders for the actual data (arguments) that are provided when the function is invoked.</p>

    <h4>Syntax for Parameters</h4>
    <p>Parameters are declared within the parentheses in the function definition. The types and names of the parameters must be specified. Here's an example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    return_type function_name(parameter1_type parameter1, parameter2_type parameter2) {
        // Function body
    }
    </pre>
    <p>For example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int add(int a, int b) {
        return a + b;
    }
    </pre>

    <h3>Arguments</h3>
    <p>Arguments are the actual values that are passed to a function when it is called. These values are assigned to the parameters in the function.</p>

    <h4>Passing Arguments to a Function</h4>
    <p>When calling a function, the arguments are passed in the same order as the parameters in the function definition. Here's an example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    // Function to add two numbers
    int add(int a, int b) {
        return a + b;
    }

    int main() {
        int result = add(3, 5);  // Passing arguments 3 and 5 to the function
        cout << "The sum is: " << result << endl;
        return 0;
    }
    </pre>
    <p>In this example, the function <code>add</code> takes two parameters <code>a</code> and <code>b</code>. When calling the function in <code>main</code>, the arguments 3 and 5 are passed to the function, where they are assigned to <code>a</code> and <code>b</code>, respectively.</p>

    <h3>Types of Arguments</h3>
    <p>There are two primary ways to pass arguments to functions:</p>
    <ul>
        <li><strong>Call by Value:</strong> The actual value of the argument is passed to the function. The function operates on a copy of the argument, so changes made inside the function do not affect the original value.</li>
        <li><strong>Call by Reference:</strong> A reference (memory address) to the actual argument is passed to the function. Any changes made to the parameter inside the function will affect the original argument.</li>
    </ul>

    <h4>Call by Value</h4>
    <p>In call by value, a copy of the argument is passed to the function. Changes made inside the function do not affect the original variable.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    void modifyValue(int x) {
        x = 10;  // Modifying the value inside the function
    }

    int main() {
        int num = 5;
        modifyValue(num);  // num is passed by value
        cout << "Value of num: " << num << endl;  // num remains unchanged
        return 0;
    }
    </pre>
    <p>In this example, the value of <code>num</code> remains unchanged after calling <code>modifyValue</code>, because the argument is passed by value.</p>

    <h4>Call by Reference</h4>
    <p>In call by reference, the address of the argument is passed to the function. Changes made to the parameter inside the function directly affect the original argument.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    void modifyValue(int &x) {
        x = 10;  // Modifying the value inside the function
    }

    int main() {
        int num = 5;
        modifyValue(num);  // num is passed by reference
        cout << "Value of num: " << num << endl;  // num is modified
        return 0;
    }
    </pre>
    <p>In this example, the value of <code>num</code> changes to 10 after calling <code>modifyValue</code>, because the argument is passed by reference.</p>

    <h3>Default Arguments</h3>
    <p>C++ allows functions to have default values for parameters. If no argument is provided for a parameter, the default value is used.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int add(int a, int b = 5) {  // Default value for b is 5
        return a + b;
    }

    int main() {
        cout << add(3) << endl;  // Only one argument is passed, b defaults to 5
        cout << add(3, 7) << endl;  // Both arguments are passed
        return 0;
    }
    </pre>
    <p>In this example, if only one argument is passed to the <code>add</code> function, the second parameter <code>b</code> takes the default value of 5.</p>

</div>


<!-------------------Return Statement----------------------->

<div class="main" id="return-statement">
    <h2>Return Statement</h2>

    <h3>Introduction to the Return Statement</h3>
    <p>The <code>return</code> statement is used to exit a function and optionally return a value to the caller. The return statement can be used in any function that has a specified return type (other than <code>void</code>), and it terminates the function's execution, sending a result back to the point where the function was called.</p>

    <h3>Syntax of the Return Statement</h3>
    <p>The syntax for the return statement is as follows:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    return expression;
    </pre>
    <p>Where <code>expression</code> is the value to be returned by the function. The expression can be a constant, variable, or any valid expression that matches the return type of the function.</p>

    <h3>Example: Return Statement in a Function</h3>
    <p>Here's an example of a function that returns the sum of two integers:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    // Function to add two numbers
    int add(int a, int b) {
        return a + b;  // Return the sum of a and b
    }

    int main() {
        int result = add(3, 5);  // Calling the function and storing the result
        cout << "The sum is: " << result << endl;  // Output the result
        return 0;
    }
    </pre>
    <p>In this example, the function <code>add</code> returns the sum of <code>a</code> and <code>b</code>, which is then printed in the <code>main</code> function.</p>

    <h3>Returning from a Void Function</h3>
    <p>If the function has a <code>void</code> return type, the <code>return</code> statement can be used without any expression, simply to exit the function early:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    void printMessage() {
        cout << "This message will be printed." << endl;
        return;  // Early exit (optional in this case)
    }

    int main() {
        printMessage();  // Calling the function
        return 0;
    }
    </pre>
    <p>In this example, the <code>return</code> statement is used to exit the <code>printMessage</code> function early, though it’s not strictly necessary here as the function would exit anyway after printing the message.</p>

    <h3>Returning Multiple Values (via References or Pointers)</h3>
    <p>C++ functions can only return one value directly. However, if you need to return multiple values, you can do so by using references or pointers to modify the original variables in the calling function.</p>

    <h4>Example with References</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    void getValues(int &a, int &b) {
        a = 10;
        b = 20;
    }

    int main() {
        int x, y;
        getValues(x, y);  // Passing variables by reference
        cout << "x: " << x << ", y: " << y << endl;
        return 0;
    }
    </pre>
    <p>In this example, the function <code>getValues</code> modifies the values of <code>x</code> and <code>y</code> using references, effectively "returning" multiple values to the caller.</p>

    <h4>Example with Pointers</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    void setValues(int *a, int *b) {
        *a = 10;
        *b = 20;
    }

    int main() {
        int x, y;
        setValues(&x, &y);  // Passing addresses of variables
        cout << "x: " << x << ", y: " << y << endl;
        return 0;
    }
    </pre>
    <p>In this example, the function <code>setValues</code> uses pointers to modify the values of <code>x</code> and <code>y</code> in the calling function.</p>

    <h3>Early Return</h3>
    <p>In some cases, it might be useful to return from a function early if certain conditions are met. This is often used to simplify control flow and avoid unnecessary computation:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    bool isEven(int number) {
        if (number % 2 == 0) {
            return true;  // Early return if number is even
        }
        return false;
    }

    int main() {
        cout << isEven(4) << endl;  // Output: 1 (true)
        cout << isEven(5) << endl;  // Output: 0 (false)
        return 0;
    }
    </pre>
    <p>In this example, the <code>isEven</code> function returns early if the number is even, making the code more efficient.</p>

</div>


<!-------------------Inline Functions----------------------->

<div class="main" id="inline-functions">
    <h2>Inline Functions</h2>

    <h3>Introduction to Inline Functions</h3>
    <p>An inline function is a function that is expanded in place at the point where it is called, rather than being called through the normal function call mechanism. This can help reduce the overhead of function calls, especially for small, frequently called functions.</p>

    <h3>Syntax of Inline Functions</h3>
    <p>To declare a function as inline, the <code>inline</code> keyword is placed before the return type in the function definition:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    inline return_type function_name(parameters) {
        // Function body
    }
    </pre>
    <p>For example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    inline int add(int a, int b) {
        return a + b;  // Adding two numbers
    }
    </pre>

    <h3>Why Use Inline Functions?</h3>
    <p>Inline functions are typically used for small, performance-critical functions. When a function is declared as inline, the compiler attempts to replace the function call with the actual function code. This eliminates the overhead of making a function call (like saving registers, jumping to the function address, etc.). However, for larger functions, using inline may result in larger executable sizes without significant performance improvement.</p>

    <h3>Example: Using Inline Functions</h3>
    <p>Here’s an example where an inline function is used to calculate the area of a rectangle:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include <iostream>
    using namespace std;

    // Inline function to calculate area of rectangle
    inline int area(int length, int width) {
        return length * width;
    }

    int main() {
        int length = 5;
        int width = 10;
        cout << "Area of rectangle: " << area(length, width) << endl;
        return 0;
    }
    </pre>
    <p>In this example, the <code>area</code> function is defined as inline. The compiler will attempt to replace the function call <code>area(length, width)</code> with the actual function code, improving efficiency.</p>

    <h3>Inline Function Limitations</h3>
    <p>While inline functions can improve performance in certain cases, they are not always beneficial. Here are some limitations:</p>
    <ul>
        <li><strong>Function size:</strong> Inline functions are most effective for small functions. Large functions or functions with complex logic may not benefit from being declared inline.</li>
        <li><strong>Code size:</strong> If inline functions are used excessively, they can increase the overall size of the program, potentially negating performance gains.</li>
        <li><strong>Recursion:</strong> Inline functions should not be recursive. Recursion would prevent the function from being inlined, as the compiler would not be able to determine the size of the function call graph.</li>
    </ul>

    <h3>How the Compiler Handles Inline Functions</h3>
    <p>The compiler makes the final decision on whether a function will be inlined or not. While declaring a function as <code>inline</code> suggests that it should be inlined, the compiler may choose not to do so, particularly if the function is too complex or large.</p>

    <h3>Example: Inline vs Non-Inline</h3>
    <p>Here’s a comparison of an inline and a non-inline version of the same function:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Inline function
    inline int multiply(int a, int b) {
        return a * b;
    }

    // Non-inline function
    int multiplyNonInline(int a, int b) {
        return a * b;
    }
    </pre>
    <p>In the case of <code>multiply</code>, declaring it as <code>inline</code> suggests to the compiler that it should be replaced directly in the code. However, the <code>multiplyNonInline</code> function will go through the normal function call process.</p>

</div>


<!-------------------Classes and Objects----------------------->

<div class="main" id="classes-and-objects">
    <h2>Classes and Objects</h2>

    <h3>Introduction to Classes and Objects</h3>
    <p>In C++, classes and objects are fundamental concepts in Object-Oriented Programming (OOP). A class serves as a blueprint for creating objects (instances), and it defines the properties (attributes) and behaviors (methods) that the objects will have. An object is an instance of a class, and each object can have its own state and can perform actions defined in the class.</p>

    <h3>Defining a Class</h3>
    <p>The syntax for defining a class is as follows:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class ClassName {
    public:
        // Attributes (data members)
        data_type attribute_name;

        // Methods (member functions)
        return_type method_name(parameters) {
            // Function body
        }
    };
    </pre>
    <p>Here’s an example of a class that represents a <code>Car</code>:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Car {
    public:
        string brand;
        string model;
        int year;

        // Method to display car details
        void displayDetails() {
            cout << "Brand: " << brand << ", Model: " << model << ", Year: " << year << endl;
        }
    };
    </pre>

    <h3>Creating Objects from a Class</h3>
    <p>Once a class is defined, you can create objects of that class. Objects are created by using the class name as a type and providing the necessary values for the attributes:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int main() {
        // Creating an object of the Car class
        Car myCar;
        myCar.brand = "Toyota";
        myCar.model = "Corolla";
        myCar.year = 2020;

        // Calling a method on the object
        myCar.displayDetails();
        
        return 0;
    }
    </pre>
    <p>In this example, an object <code>myCar</code> is created from the <code>Car</code> class, and the <code>displayDetails</code> method is called on the object.</p>

    <h3>Accessing Attributes and Methods</h3>
    <p>Attributes and methods of a class can be accessed using the dot operator (<code>.</code>) on an object. Public members can be accessed directly, while private members can only be accessed through public methods (getters/setters).</p>

    <h4>Example of Accessing Attributes and Methods</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Person {
    public:
        string name;
        int age;

        void displayInfo() {
            cout << "Name: " << name << ", Age: " << age << endl;
        }
    };

    int main() {
        Person person1;
        person1.name = "John";
        person1.age = 30;
        person1.displayInfo();  // Output: Name: John, Age: 30
        return 0;
    }
    </pre>
    <p>In this example, the attributes <code>name</code> and <code>age</code> of the <code>person1</code> object are accessed and modified directly, and the <code>displayInfo</code> method is called to display the object's information.</p>

    <h3>Constructors and Destructors</h3>
    <p>Constructors and destructors are special member functions that handle object creation and destruction. We'll explore them in more detail in the next topics.</p>

    <h3>Summary</h3>
    <ul>
        <li><strong>Class:</strong> A blueprint for creating objects, which defines attributes and methods.</li>
        <li><strong>Object:</strong> An instance of a class that can hold data and perform actions.</li>
        <li><strong>Attributes:</strong> Variables that represent the state of an object.</li>
        <li><strong>Methods:</strong> Functions that define the behaviors of an object.</li>
        <li><strong>Accessing:</strong> Use the dot operator to access attributes and methods of an object.</li>
    </ul>

</div>


<!-------------------Constructors----------------------->

<div class="main" id="constructors">
    <h2>Constructors</h2>

    <h3>Introduction to Constructors</h3>
    <p>A constructor is a special member function of a class that is executed automatically when an object of that class is created. It is used to initialize the object's attributes with default or user-provided values. Constructors have the same name as the class and do not have a return type.</p>

    <h3>Types of Constructors</h3>
    <p>There are two main types of constructors in C++:</p>
    <ul>
        <li><strong>Default Constructor:</strong> A constructor that does not take any parameters and initializes the object with default values.</li>
        <li><strong>Parameterized Constructor:</strong> A constructor that takes one or more parameters to initialize the object with specific values at the time of creation.</li>
    </ul>

    <h3>Default Constructor</h3>
    <p>A default constructor is called when an object is created without any arguments. If you don't provide a constructor, the compiler will automatically provide a default constructor for you. However, you can also explicitly define it.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Car {
    public:
        string brand;
        string model;
        int year;

        // Default constructor
        Car() {
            brand = "Unknown";
            model = "Unknown";
            year = 0;
        }

        void displayDetails() {
            cout << "Brand: " << brand << ", Model: " << model << ", Year: " << year << endl;
        }
    };

    int main() {
        Car myCar;  // Default constructor is called
        myCar.displayDetails();  // Output: Brand: Unknown, Model: Unknown, Year: 0
        return 0;
    }
    </pre>
    <p>In this example, the default constructor initializes the <code>brand</code>, <code>model</code>, and <code>year</code> attributes of the <code>myCar</code> object with default values.</p>

    <h3>Parameterized Constructor</h3>
    <p>A parameterized constructor allows you to pass values to the constructor at the time of object creation. This allows for more flexible and customized object initialization.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Car {
    public:
        string brand;
        string model;
        int year;

        // Parameterized constructor
        Car(string b, string m, int y) {
            brand = b;
            model = m;
            year = y;
        }

        void displayDetails() {
            cout << "Brand: " << brand << ", Model: " << model << ", Year: " << year << endl;
        }
    };

    int main() {
        Car myCar("Toyota", "Corolla", 2020);  // Parameterized constructor is called
        myCar.displayDetails();  // Output: Brand: Toyota, Model: Corolla, Year: 2020
        return 0;
    }
    </pre>
    <p>In this example, the parameterized constructor takes three arguments and initializes the <code>myCar</code> object with the provided values.</p>

    <h3>Constructor Overloading</h3>
    <p>C++ allows constructor overloading, which means you can define multiple constructors with different parameter lists in the same class. The appropriate constructor is called based on the arguments passed during object creation.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Car {
    public:
        string brand;
        string model;
        int year;

        // Default constructor
        Car() {
            brand = "Unknown";
            model = "Unknown";
            year = 0;
        }

        // Parameterized constructor
        Car(string b, string m, int y) {
            brand = b;
            model = m;
            year = y;
        }

        void displayDetails() {
            cout << "Brand: " << brand << ", Model: " << model << ", Year: " << year << endl;
        }
    };

    int main() {
        Car car1;  // Default constructor
        car1.displayDetails();  // Output: Brand: Unknown, Model: Unknown, Year: 0

        Car car2("Ford", "Mustang", 2021);  // Parameterized constructor
        car2.displayDetails();  // Output: Brand: Ford, Model: Mustang, Year: 2021

        return 0;
    }
    </pre>
    <p>In this example, both the default and parameterized constructors are used to create different objects of the <code>Car</code> class.</p>

    <h3>Constructor Initialization List</h3>
    <p>You can also use an initialization list to initialize object attributes. This is particularly useful for initializing constant data members or references.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Car {
    public:
        string brand;
        string model;
        int year;

        // Constructor with initialization list
        Car(string b, string m, int y) : brand(b), model(m), year(y) {}

        void displayDetails() {
            cout << "Brand: " << brand << ", Model: " << model << ", Year: " << year << endl;
        }
    };

    int main() {
        Car car("Honda", "Civic", 2022);
        car.displayDetails();  // Output: Brand: Honda, Model: Civic, Year: 2022
        return 0;
    }
    </pre>
    <p>The initialization list (<code>: brand(b), model(m), year(y)</code>) initializes the data members of the <code>Car</code> class.</p>

    <h3>Summary</h3>
    <ul>
        <li><strong>Constructor:</strong> A special function used to initialize objects of a class.</li>
        <li><strong>Default Constructor:</strong> A constructor that does not take any parameters and provides default values.</li>
        <li><strong>Parameterized Constructor:</strong> A constructor that takes parameters to initialize objects with specific values.</li>
        <li><strong>Constructor Overloading:</strong> Defining multiple constructors with different parameter lists in the same class.</li>
        <li><strong>Initialization List:</strong> A list used to initialize data members of a class directly when constructing an object.</li>
    </ul>

</div>


<!-------------------Destructors----------------------->

<div class="main" id="destructors">
    <h2>Destructors</h2>

    <h3>Introduction to Destructors</h3>
    <p>A destructor is a special member function of a class that is called automatically when an object of that class is destroyed. The purpose of a destructor is to release resources acquired by the object during its lifetime, such as memory, file handles, or other system resources.</p>

    <h3>Syntax of a Destructor</h3>
    <p>A destructor has the same name as the class but is preceded by a tilde (~). It does not take any parameters, and it does not return any value.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class ClassName {
    public:
        // Constructor
        ClassName() {
            // Initialization code
        }

        // Destructor
        ~ClassName() {
            // Cleanup code
        }
    };
    </pre>
    <p>In the example above, the destructor is named <code>~ClassName</code> and is called automatically when an object of the class goes out of scope or is explicitly deleted.</p>

    <h3>Example of a Destructor</h3>
    <p>Here's an example of a class that uses a destructor to release dynamically allocated memory:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class MyClass {
    private:
        int* ptr;

    public:
        // Constructor
        MyClass(int value) {
            ptr = new int;  // Dynamically allocated memory
            *ptr = value;
            cout << "Constructor: Memory allocated" << endl;
        }

        // Destructor
        ~MyClass() {
            delete ptr;  // Memory released
            cout << "Destructor: Memory freed" << endl;
        }

        void display() {
            cout << "Value: " << *ptr << endl;
        }
    };

    int main() {
        MyClass obj(10);  // Constructor is called
        obj.display();
        // Destructor is called automatically when the object goes out of scope
        return 0;
    }
    </pre>
    <p>In this example, the constructor allocates memory dynamically, and the destructor is responsible for freeing that memory when the object is destroyed. When the <code>obj</code> goes out of scope at the end of <code>main</code>, the destructor is automatically called, releasing the memory and printing the cleanup message.</p>

    <h3>Destructor and Object Lifetime</h3>
    <p>Destructors are called automatically when an object goes out of scope or is explicitly deleted if the object was created dynamically. For objects created on the stack, the destructor is called when the object goes out of scope. For objects created on the heap (using <code>new</code>), the destructor is called when <code>delete</code> is used to destroy the object.</p>

    <h3>Destructor in Inheritance</h3>
    <p>If a class has a base class, and the derived class has a destructor, the base class destructor will be automatically called when the derived class object is destroyed. However, if the base class destructor is not virtual, it may cause resource leaks in the derived class. It's good practice to declare the base class destructor as <code>virtual</code> to ensure proper cleanup of resources.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Base {
    public:
        virtual ~Base() {
            cout << "Base class destructor" << endl;
        }
    };

    class Derived : public Base {
    public:
        ~Derived() {
            cout << "Derived class destructor" << endl;
        }
    };

    int main() {
        Derived* d = new Derived();  // Base and Derived destructors will be called
        delete d;  // Proper destructor call due to virtual function
        return 0;
    }
    </pre>
    <p>In this example, the base class destructor is declared <code>virtual</code>, ensuring that both the base and derived class destructors are called when <code>delete</code> is used on a derived class object.</p>

    <h3>Summary</h3>
    <ul>
        <li><strong>Destructor:</strong> A special function that is automatically called when an object is destroyed, used to release resources acquired during the object's lifetime.</li>
        <li><strong>Syntax:</strong> The destructor has the same name as the class but is preceded by a tilde (~), and it takes no parameters and has no return type.</li>
        <li><strong>Automatic Cleanup:</strong> The destructor is automatically called when an object goes out of scope or is explicitly deleted.</li>
        <li><strong>Inheritance:</strong> If a derived class has a destructor, the base class destructor is called automatically. Always declare base class destructors as virtual to ensure proper cleanup.</li>
    </ul>

</div>


<!-------------------Inheritance----------------------->

<div class="main" id="inheritance">
    <h2>Inheritance</h2>

    <h3>Introduction to Inheritance</h3>
    <p>Inheritance is a fundamental concept in Object-Oriented Programming (OOP) that allows a class to acquire the properties and methods of another class. The class that inherits is called the derived class, and the class being inherited from is called the base class. Inheritance promotes code reuse and establishes a relationship between classes.</p>

    <h3>Types of Inheritance</h3>
    <p>There are several types of inheritance in C++:</p>
    <ul>
        <li><strong>Single Inheritance:</strong> A class inherits from a single base class.</li>
        <li><strong>Multiple Inheritance:</strong> A class inherits from more than one base class.</li>
        <li><strong>Multilevel Inheritance:</strong> A class inherits from a derived class, forming a chain of inheritance.</li>
        <li><strong>Hierarchical Inheritance:</strong> Multiple classes inherit from a single base class.</li>
        <li><strong>Hybrid Inheritance:</strong> A combination of more than one type of inheritance.</li>
    </ul>

    <h3>Single Inheritance</h3>
    <p>In single inheritance, a derived class inherits from a single base class.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Animal {
    public:
        void eat() {
            cout << "Eating..." << endl;
        }
    };

    class Dog : public Animal {
    public:
        void bark() {
            cout << "Barking..." << endl;
        }
    };

    int main() {
        Dog myDog;
        myDog.eat();  // Inherited from Animal class
        myDog.bark();  // Defined in Dog class
        return 0;
    }
    </pre>
    <p>In this example, the <code>Dog</code> class inherits the <code>eat</code> method from the <code>Animal</code> class. The <code>Dog</code> class can also define its own methods, such as <code>bark</code>.</p>

    <h3>Multiple Inheritance</h3>
    <p>Multiple inheritance allows a class to inherit from more than one base class. However, it can lead to ambiguity if both base classes have methods with the same name, so it should be used cautiously.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Animal {
    public:
        void eat() {
            cout << "Eating..." << endl;
        }
    };

    class Vehicle {
    public:
        void drive() {
            cout << "Driving..." << endl;
        }
    };

    class Car : public Animal, public Vehicle {
    public:
        void honk() {
            cout << "Honking..." << endl;
        }
    };

    int main() {
        Car myCar;
        myCar.eat();    // Inherited from Animal class
        myCar.drive();  // Inherited from Vehicle class
        myCar.honk();   // Defined in Car class
        return 0;
    }
    </pre>
    <p>Here, the <code>Car</code> class inherits from both the <code>Animal</code> and <code>Vehicle</code> classes, enabling it to use methods from both base classes.</p>

    <h3>Multilevel Inheritance</h3>
    <p>Multilevel inheritance involves a class inheriting from another derived class, forming a chain of inheritance.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Animal {
    public:
        void eat() {
            cout << "Eating..." << endl;
        }
    };

    class Mammal : public Animal {
    public:
        void sleep() {
            cout << "Sleeping..." << endl;
        }
    };

    class Dog : public Mammal {
    public:
        void bark() {
            cout << "Barking..." << endl;
        }
    };

    int main() {
        Dog myDog;
        myDog.eat();    // Inherited from Animal class
        myDog.sleep();  // Inherited from Mammal class
        myDog.bark();   // Defined in Dog class
        return 0;
    }
    </pre>
    <p>In this example, the <code>Dog</code> class inherits from <code>Mammal</code>, which in turn inherits from <code>Animal</code>.</p>

    <h3>Access Modifiers in Inheritance</h3>
    <p>In C++, the access control of the base class members is affected by the type of inheritance. You can specify how the base class members are inherited using access modifiers.</p>
    <ul>
        <li><strong>Public Inheritance:</strong> Public members of the base class remain public in the derived class, and private members are not inherited.</li>
        <li><strong>Private Inheritance:</strong> Public and protected members of the base class become private in the derived class.</li>
        <li><strong>Protected Inheritance:</strong> Public and protected members of the base class become protected in the derived class.</li>
    </ul>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Base {
    public:
        int x;
    protected:
        int y;
    private:
        int z;

    public:
        Base() {
            x = 1;
            y = 2;
            z = 3;
        }
    };

    class Derived : public Base {
    public:
        void display() {
            cout << "x: " << x << ", y: " << y << endl;  // x and y are accessible
            // cout << "z: " << z << endl;  // Error: z is private in Base class
        }
    };

    int main() {
        Derived obj;
        obj.display();
        return 0;
    }
    </pre>
    <p>In this example, the <code>Derived</code> class inherits the public and protected members of the <code>Base</code> class, but the private members are not accessible.</p>

    <h3>Summary</h3>
    <ul>
        <li><strong>Inheritance:</strong> Allows a derived class to inherit properties and methods from a base class.</li>
        <li><strong>Single Inheritance:</strong> A derived class inherits from one base class.</li>
        <li><strong>Multiple Inheritance:</strong> A derived class inherits from more than one base class.</li>
        <li><strong>Multilevel Inheritance:</strong> A class inherits from a derived class, forming a chain.</li>
        <li><strong>Access Modifiers:</strong> Control how base class members are inherited in the derived class (public, protected, private).</li>
    </ul>

</div>


<!-------------------Polymorphism----------------------->

<div class="main" id="polymorphism">
    <h2>Polymorphism</h2>

    <h3>Introduction to Polymorphism</h3>
    <p>Polymorphism is a key concept in Object-Oriented Programming (OOP) that allows objects of different classes to be treated as objects of a common base class. It enables one interface to be used for a general class of actions, making it possible to define multiple methods with the same name but different behaviors. Polymorphism is mainly divided into two types:</p>
    <ul>
        <li><strong>Compile-time polymorphism</strong> (Method Overloading and Operator Overloading)</li>
        <li><strong>Runtime polymorphism</strong> (Method Overriding with virtual functions)</li>
    </ul>

    <h3>Compile-time Polymorphism</h3>
    <p>Compile-time polymorphism occurs when the method to be called is resolved at compile time. This is typically achieved through method overloading and operator overloading.</p>

    <h4>Method Overloading</h4>
    <p>Method overloading is when two or more methods in the same class have the same name but different parameters (either in type or number of parameters).</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class MathOperations {
    public:
        int add(int a, int b) {
            return a + b;
        }

        double add(double a, double b) {
            return a + b;
        }
    };

    int main() {
        MathOperations math;
        cout << math.add(2, 3) << endl;       // Calls the int version
        cout << math.add(2.5, 3.5) << endl;   // Calls the double version
        return 0;
    }
    </pre>
    <p>In this example, the <code>add</code> method is overloaded with two different parameter types: one that takes integers and one that takes doubles.</p>

    <h4>Operator Overloading</h4>
    <p>Operator overloading allows you to redefine the behavior of operators for user-defined types. It enables you to use operators such as +, -, *, etc., with your own classes.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Complex {
    private:
        int real, imag;

    public:
        Complex(int r, int i) : real(r), imag(i) {}

        Complex operator + (const Complex& c) {
            return Complex(real + c.real, imag + c.imag);
        }

        void display() {
            cout << real << " + " << imag << "i" << endl;
        }
    };

    int main() {
        Complex c1(1, 2), c2(3, 4);
        Complex c3 = c1 + c2;  // Uses overloaded + operator
        c3.display();
        return 0;
    }
    </pre>
    <p>Here, the <code>+</code> operator is overloaded to add two <code>Complex</code> numbers, resulting in the sum of the real and imaginary parts.</p>

    <h3>Runtime Polymorphism</h3>
    <p>Runtime polymorphism occurs when the method to be called is determined at runtime. This is achieved using method overriding and virtual functions.</p>

    <h4>Method Overriding with Virtual Functions</h4>
    <p>In method overriding, a method in a derived class has the same name and signature as a method in the base class. The base class method is declared as <code>virtual</code> to enable dynamic binding at runtime, ensuring that the derived class's version of the method is called.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Animal {
    public:
        virtual void sound() {
            cout << "Some animal sound" << endl;
        }
    };

    class Dog : public Animal {
    public:
        void sound() override {
            cout << "Barking..." << endl;
        }
    };

    class Cat : public Animal {
    public:
        void sound() override {
            cout << "Meowing..." << endl;
        }
    };

    int main() {
        Animal* animal1 = new Dog();
        Animal* animal2 = new Cat();
        
        animal1->sound();  // Calls Dog's version
        animal2->sound();  // Calls Cat's version

        delete animal1;
        delete animal2;
        return 0;
    }
    </pre>
    <p>In this example, the <code>sound</code> method is overridden in both the <code>Dog</code> and <code>Cat</code> classes. Because the base class <code>sound</code> method is declared <code>virtual</code>, the appropriate method is called at runtime based on the object type.</p>

    <h3>Virtual Functions and Dynamic Binding</h3>
    <p>When a base class method is declared as virtual, the C++ runtime system uses dynamic binding to determine which version of the method to invoke based on the actual object type, rather than the type of the pointer or reference used to call the method. This allows for true polymorphic behavior.</p>

    <h3>Pure Virtual Functions and Abstract Classes</h3>
    <p>A pure virtual function is a function that has no implementation in the base class and must be implemented by derived classes. A class containing at least one pure virtual function is called an abstract class, and objects of abstract classes cannot be instantiated.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Shape {
    public:
        virtual void draw() = 0;  // Pure virtual function
    };

    class Circle : public Shape {
    public:
        void draw() override {
            cout << "Drawing a circle" << endl;
        }
    };

    int main() {
        Shape* shape = new Circle();
        shape->draw();  // Calls Circle's draw method
        delete shape;
        return 0;
    }
    </pre>
    <p>In this example, the <code>Shape</code> class has a pure virtual function <code>draw</code>, making it an abstract class. The derived class <code>Circle</code> provides an implementation for <code>draw</code>.</p>

    <h3>Summary</h3>
    <ul>
        <li><strong>Compile-time Polymorphism:</strong> Achieved through method overloading and operator overloading, where the method to be called is determined at compile time.</li>
        <li><strong>Runtime Polymorphism:</strong> Achieved through method overriding with virtual functions, where the method to be called is determined at runtime.</li>
        <li><strong>Method Overloading:</strong> Multiple methods with the same name but different parameters.</li>
        <li><strong>Operator Overloading:</strong> Redefining the behavior of operators for user-defined types.</li>
        <li><strong>Method Overriding:</strong> A derived class method with the same name and signature as a base class method.</li>
        <li><strong>Virtual Functions:</strong> Functions that allow dynamic binding, enabling runtime polymorphism.</li>
        <li><strong>Pure Virtual Functions:</strong> Functions with no implementation in the base class, requiring derived classes to provide an implementation.</li>
    </ul>

</div>


<!-------------------Encapsulation----------------------->

<div class="main" id="encapsulation">
    <h2>Encapsulation</h2>

    <h3>Introduction to Encapsulation</h3>
    <p>Encapsulation is one of the fundamental principles of Object-Oriented Programming (OOP). It refers to the bundling of data (variables) and methods (functions) that operate on the data into a single unit or class. Encapsulation helps restrict access to certain details of an object and protects the object's internal state from unauthorized modification.</p>
    <p>In C++, encapsulation is achieved using:</p>
    <ul>
        <li><strong>Private Members:</strong> Data members and methods that cannot be accessed directly from outside the class.</li>
        <li><strong>Public Members:</strong> Methods and data members that can be accessed from outside the class.</li>
        <li><strong>Access Modifiers:</strong> Keywords like <code>private</code>, <code>public</code>, and <code>protected</code> that control the visibility and accessibility of class members.</li>
    </ul>

    <h3>Private and Public Access Modifiers</h3>
    <p>C++ provides three access modifiers:</p>
    <ul>
        <li><strong>private:</strong> Members declared as private can only be accessed within the class and are not accessible from outside the class.</li>
        <li><strong>public:</strong> Members declared as public can be accessed from outside the class.</li>
        <li><strong>protected:</strong> Members declared as protected can be accessed within the class and by derived classes but not from outside the class.</li>
    </ul>

    <h3>Encapsulation Example</h3>
    <p>The following example demonstrates encapsulation by using private and public members in a class:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Account {
    private:
        double balance;  // Private data member

    public:
        Account(double initialBalance) {  // Constructor
            if (initialBalance > 0) {
                balance = initialBalance;
            } else {
                balance = 0;
            }
        }

        void deposit(double amount) {  // Public method to deposit money
            if (amount > 0) {
                balance += amount;
            }
        }

        void withdraw(double amount) {  // Public method to withdraw money
            if (amount > 0 && amount <= balance) {
                balance -= amount;
            }
        }

        double getBalance() {  // Public method to access the balance
            return balance;
        }
    };

    int main() {
        Account acc(1000);  // Create an Account object with an initial balance
        acc.deposit(500);    // Deposit money into the account
        acc.withdraw(200);   // Withdraw money from the account
        cout << "Balance: " << acc.getBalance() << endl;  // Access balance via getter
        return 0;
    }
    </pre>
    <p>In this example, the <code>balance</code> data member is private, so it cannot be directly accessed from outside the class. The <code>deposit</code>, <code>withdraw</code>, and <code>getBalance</code> methods are public, providing controlled access to the private <code>balance</code>.</p>

    <h3>Benefits of Encapsulation</h3>
    <ul>
        <li><strong>Data Protection:</strong> Encapsulation helps protect the internal state of an object from direct access and modification, ensuring data integrity.</li>
        <li><strong>Code Flexibility:</strong> With encapsulation, the implementation details can be changed without affecting the external code using the class.</li>
        <li><strong>Improved Maintainability:</strong> By hiding the internal details and exposing only essential methods, the code becomes easier to maintain and extend.</li>
        <li><strong>Access Control:</strong> Encapsulation allows you to define and enforce rules about how data is accessed and modified.</li>
    </ul>

    <h3>Getter and Setter Methods</h3>
    <p>Getter and setter methods are used to provide controlled access to private data members. A getter method retrieves the value of a private data member, while a setter method allows modifying the value of a private data member.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    class Person {
    private:
        string name;  // Private data member

    public:
        // Getter method
        string getName() {
            return name;
        }

        // Setter method
        void setName(string newName) {
            name = newName;
        }
    };

    int main() {
        Person p;
        p.setName("John Doe");  // Set name using setter
        cout << "Name: " << p.getName() << endl;  // Get name using getter
        return 0;
    }
    </pre>
    <p>In this example, the <code>name</code> data member is private, and getter and setter methods are used to access and modify it from outside the class.</p>

    <h3>Summary</h3>
    <ul>
        <li><strong>Encapsulation</strong> involves combining data and methods that operate on the data into a single class, providing controlled access to the data.</li>
        <li><strong>Access Modifiers</strong> such as <code>private</code>, <code>public</code>, and <code>protected</code> control the visibility and accessibility of class members.</li>
        <li><strong>Private Members</strong> cannot be accessed directly from outside the class, ensuring data protection.</li>
        <li><strong>Public Methods</strong> provide controlled access to private data, enabling safe modification and retrieval.</li>
        <li><strong>Getter and Setter Methods</strong> are used to provide controlled access to private data members, allowing validation or modification during access.</li>
        <li><strong>Encapsulation Benefits:</strong> It ensures data protection, flexibility, maintainability, and access control, leading to better design and functionality of the class.</li>
    </ul>

</div>


<!-------------------Vectors----------------------->

<div class="main" id="vectors">
    <h2>Vectors</h2>

    <h3>Introduction to Vectors</h3>
    <p>In C++, vectors are part of the Standard Template Library (STL) and provide a dynamic array that can resize itself automatically when elements are added or removed. Vectors are implemented as arrays that can grow or shrink in size, unlike normal arrays that have fixed sizes.</p>
    <p>Vectors are similar to arrays, but they offer more flexibility and ease of use. They are more efficient when it comes to resizing and can store any data type, including user-defined types.</p>

    <h3>Declaring and Initializing Vectors</h3>
    <p>To use vectors, the header <code>#include &lt;vector&gt;</code> is required. Vectors can be declared in a variety of ways:</p>
    <ul>
        <li><strong>Default Declaration:</strong> A vector with no initial elements.</li>
        <li><strong>Vector with Initial Size:</strong> A vector with a specified number of elements initialized to a default value.</li>
        <li><strong>Vector with Initial Values:</strong> A vector initialized with specific values.</li>
    </ul>

    <h4>Example of Vector Declaration and Initialization</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    
    int main() {
        // Default declaration
        vector<int> vec1;
        
        // Vector with initial size (5 elements initialized to 0)
        vector<int> vec2(5, 0);
        
        // Vector with initial values
        vector<int> vec3 = {1, 2, 3, 4, 5};
        
        cout << "Size of vec3: " << vec3.size() << endl;
        return 0;
    }
    </pre>

    <h3>Accessing Elements in a Vector</h3>
    <p>Elements in a vector can be accessed using indices, similar to arrays. Vectors also provide functions such as <code>at()</code>, <code>front()</code>, and <code>back()</code> to access elements at specific positions.</p>

    <h4>Example of Accessing Vector Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    
    int main() {
        vector<int> vec = {10, 20, 30, 40, 50};
        
        // Using index
        cout << "Element at index 2: " << vec[2] << endl;

        // Using at()
        cout << "Element at index 3: " << vec.at(3) << endl;

        // Using front() and back()
        cout << "First element: " << vec.front() << endl;
        cout << "Last element: " << vec.back() << endl;

        return 0;
    }
    </pre>

    <h3>Adding and Removing Elements</h3>
    <p>Vectors allow dynamic addition and removal of elements. Functions like <code>push_back()</code> and <code>pop_back()</code> are commonly used for this purpose:</p>
    <ul>
        <li><strong>push_back(value):</strong> Adds an element to the end of the vector.</li>
        <li><strong>pop_back():</strong> Removes the last element of the vector.</li>
    </ul>

    <h4>Example of Adding and Removing Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    
    int main() {
        vector<int> vec = {10, 20, 30};
        
        // Adding elements
        vec.push_back(40);
        vec.push_back(50);
        
        // Removing the last element
        vec.pop_back();
        
        // Display the elements
        cout << "Elements in vector: ";
        for (int i : vec) {
            cout << i << " ";
        }
        
        return 0;
    }
    </pre>

    <h3>Vector Size and Capacity</h3>
    <p>Vectors have two important properties:</p>
    <ul>
        <li><strong>Size:</strong> The number of elements currently stored in the vector. This can be accessed using the <code>size()</code> method.</li>
        <li><strong>Capacity:</strong> The amount of space currently allocated for the vector. This can be accessed using the <code>capacity()</code> method. The capacity is automatically increased when the vector's size exceeds its current capacity.</li>
    </ul>

    <h4>Example of Vector Size and Capacity</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    
    int main() {
        vector<int> vec = {10, 20, 30};
        
        cout << "Size of vector: " << vec.size() << endl;
        cout << "Capacity of vector: " << vec.capacity() << endl;
        
        // Adding more elements
        vec.push_back(40);
        vec.push_back(50);
        
        cout << "New size of vector: " << vec.size() << endl;
        cout << "New capacity of vector: " << vec.capacity() << endl;

        return 0;
    }
    </pre>

    <h3>Clearing and Resizing Vectors</h3>
    <p>Vectors can be resized or cleared to remove all elements:</p>
    <ul>
        <li><strong>resize(size):</strong> Changes the size of the vector. If the new size is smaller, excess elements are removed. If larger, new elements are added (initialized to 0 for basic types).</li>
        <li><strong>clear():</strong> Removes all elements from the vector, making its size 0.</li>
    </ul>

    <h4>Example of Resizing and Clearing a Vector</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    
    int main() {
        vector<int> vec = {10, 20, 30};
        
        // Resizing the vector
        vec.resize(5);  // Now it has 5 elements, last 2 are initialized to 0
        
        cout << "Size after resizing: " << vec.size() << endl;
        
        // Clearing the vector
        vec.clear();
        
        cout << "Size after clearing: " << vec.size() << endl;

        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li><strong>Vectors</strong> are dynamic arrays that can automatically resize as elements are added or removed.</li>
        <li><strong>Size and Capacity:</strong> Vectors have a size that reflects the number of elements, and a capacity that reflects the allocated space.</li>
        <li><strong>Accessing Elements:</strong> Elements can be accessed using indices, <code>at()</code>, <code>front()</code>, and <code>back()</code>.</li>
        <li><strong>Adding and Removing Elements:</strong> Vectors provide methods like <code>push_back()</code> to add elements and <code>pop_back()</code> to remove the last element.</li>
        <li><strong>Resizing and Clearing:</strong> The <code>resize()</code> method changes the vector size, while <code>clear()</code> removes all elements.</li>
    </ul>
</div>


<!-------------------Lists----------------------->

<div class="main" id="lists">
    <h2>Lists</h2>

    <h3>Introduction to Lists</h3>
    <p>In C++, lists are part of the Standard Template Library (STL) and provide a doubly linked list implementation. Unlike vectors, which provide random access to elements, lists allow efficient insertions and deletions at both ends of the sequence. Lists are particularly useful when frequent insertions and deletions are required.</p>
    <p>Unlike vectors, lists do not provide direct access to elements using an index. Instead, they provide iterators to traverse the elements.</p>

    <h3>Declaring and Initializing Lists</h3>
    <p>To use lists, the header <code>#include &lt;list&gt;</code> is required. Lists can be declared in a variety of ways:</p>
    <ul>
        <li><strong>Default Declaration:</strong> A list with no initial elements.</li>
        <li><strong>List with Initial Values:</strong> A list initialized with specific values.</li>
    </ul>

    <h4>Example of List Declaration and Initialization</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;list&gt;
    
    int main() {
        // Default declaration
        list<int> lst1;
        
        // List with initial values
        list<int> lst2 = {10, 20, 30, 40, 50};
        
        cout << "Size of lst2: " << lst2.size() << endl;
        return 0;
    }
    </pre>

    <h3>Accessing Elements in a List</h3>
    <p>Lists do not provide direct access to elements by index like arrays or vectors. Instead, we use iterators to traverse the list and access elements.</p>
    <p>Here is an example of accessing elements using an iterator:</p>

    <h4>Example of Accessing List Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;list&gt;
    
    int main() {
        list<int> lst = {10, 20, 30, 40, 50};
        
        // Using an iterator to access elements
        list<int>::iterator it = lst.begin();
        while (it != lst.end()) {
            cout << *it << " ";  // Dereferencing iterator to get the element
            ++it;  // Moving to the next element
        }
        
        return 0;
    }
    </pre>

    <h3>Adding and Removing Elements</h3>
    <p>Lists allow dynamic addition and removal of elements. Functions like <code>push_back()</code>, <code>push_front()</code>, <code>pop_back()</code>, and <code>pop_front()</code> are commonly used for these operations:</p>
    <ul>
        <li><strong>push_back(value):</strong> Adds an element to the end of the list.</li>
        <li><strong>push_front(value):</strong> Adds an element to the front of the list.</li>
        <li><strong>pop_back():</strong> Removes the last element of the list.</li>
        <li><strong>pop_front():</strong> Removes the first element of the list.</li>
    </ul>

    <h4>Example of Adding and Removing Elements in a List</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;list&gt;
    
    int main() {
        list<int> lst = {10, 20, 30};
        
        // Adding elements
        lst.push_back(40);
        lst.push_front(5);
        
        // Removing elements
        lst.pop_back();
        lst.pop_front();
        
        // Displaying the elements
        for (int val : lst) {
            cout << val << " ";
        }
        
        return 0;
    }
    </pre>

    <h3>Iterating through a List</h3>
    <p>You can iterate through a list using iterators or a range-based for loop. The following example demonstrates both methods:</p>

    <h4>Example of Iterating Through a List</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;list&gt;
    
    int main() {
        list<int> lst = {10, 20, 30, 40, 50};
        
        // Using an iterator
        list<int>::iterator it = lst.begin();
        while (it != lst.end()) {
            cout << *it << " ";
            ++it;
        }
        cout << endl;
        
        // Using a range-based for loop
        for (int val : lst) {
            cout << val << " ";
        }
        
        return 0;
    }
    </pre>

    <h3>Removing Specific Elements</h3>
    <p>You can remove specific elements from a list using the <code>remove()</code> function. Note that <code>remove()</code> works by value and removes all occurrences of that value:</p>

    <h4>Example of Removing Specific Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;list&gt;
    
    int main() {
        list<int> lst = {10, 20, 30, 20, 40};
        
        // Removing all occurrences of 20
        lst.remove(20);
        
        // Display the elements
        for (int val : lst) {
            cout << val << " ";
        }
        
        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li><strong>Lists</strong> are doubly linked lists that allow efficient insertions and deletions at both ends.</li>
        <li><strong>Accessing Elements:</strong> Use iterators to traverse and access elements in a list.</li>
        <li><strong>Adding and Removing Elements:</strong> Use <code>push_back()</code>, <code>push_front()</code>, <code>pop_back()</code>, and <code>pop_front()</code>.</li>
        <li><strong>Iterating:</strong> Use iterators or a range-based for loop to iterate through list elements.</li>
        <li><strong>Removing Specific Elements:</strong> Use <code>remove()</code> to remove specific values from the list.</li>
    </ul>
</div>


<!-------------------Maps----------------------->

<div class="main" id="maps">
    <h2>Maps</h2>

    <h3>Introduction to Maps</h3>
    <p>In C++, maps are part of the Standard Template Library (STL) and represent associative containers that store key-value pairs. Each element in a map consists of a key and a corresponding value. Maps are sorted by their keys, and each key in a map must be unique.</p>
    <p>Maps provide fast look-up times for values based on keys, which makes them ideal for tasks such as searching, sorting, and organizing data efficiently.</p>

    <h3>Declaring and Initializing Maps</h3>
    <p>To use maps, the header <code>#include &lt;map&gt;</code> is required. Maps can be declared with specific types for both keys and values. The syntax is:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;map&gt;

    int main() {
        // Declaring a map with string keys and int values
        map<string, int> studentGrades;

        // Initializing a map with key-value pairs
        map<string, int> studentScores = {{"Alice", 90}, {"Bob", 85}, {"Charlie", 88}};
        
        return 0;
    }
    </pre>

    <h3>Accessing Elements in a Map</h3>
    <p>You can access the values in a map by using the corresponding keys. The <code>at()</code> function allows access with bounds checking, while the <code>[]</code> operator provides direct access (if the key exists, otherwise it creates a new entry).</p>

    <h4>Example of Accessing Map Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;map&gt;

    int main() {
        map<string, int> studentScores = {{"Alice", 90}, {"Bob", 85}, {"Charlie", 88}};
        
        // Accessing values using at() function
        cout << "Alice's score: " << studentScores.at("Alice") << endl;

        // Accessing values using [] operator
        cout << "Bob's score: " << studentScores["Bob"] << endl;

        return 0;
    }
    </pre>

    <h3>Adding and Removing Elements</h3>
    <p>Maps allow adding and removing elements dynamically. To add an element, you can use the <code>insert()</code> function or the <code>[]</code> operator. To remove an element, you can use the <code>erase()</code> function.</p>

    <h4>Example of Adding and Removing Map Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;map&gt;

    int main() {
        map<string, int> studentScores = {{"Alice", 90}, {"Bob", 85}};
        
        // Adding a new element using insert()
        studentScores.insert({"Charlie", 88});
        
        // Adding a new element using the [] operator
        studentScores["David"] = 92;
        
        // Removing an element using erase()
        studentScores.erase("Bob");
        
        // Displaying the remaining elements
        for (const auto& entry : studentScores) {
            cout << entry.first << ": " << entry.second << endl;
        }

        return 0;
    }
    </pre>

    <h3>Iterating through a Map</h3>
    <p>You can iterate through a map using iterators or a range-based for loop. Here is an example of both methods:</p>

    <h4>Example of Iterating Through a Map</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;map&gt;

    int main() {
        map<string, int> studentScores = {{"Alice", 90}, {"Bob", 85}, {"Charlie", 88}};
        
        // Using an iterator to access map elements
        map<string, int>::iterator it = studentScores.begin();
        while (it != studentScores.end()) {
            cout << it->first << ": " << it->second << endl;
            ++it;
        }
        
        cout << endl;

        // Using a range-based for loop
        for (const auto& entry : studentScores) {
            cout << entry.first << ": " << entry.second << endl;
        }

        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li><strong>Maps</strong> store key-value pairs and are automatically sorted by key.</li>
        <li><strong>Declaring Maps:</strong> Use the syntax <code>map&lt;key_type, value_type&gt;</code> to declare a map.</li>
        <li><strong>Accessing Elements:</strong> Use <code>at()</code> for safe access or <code>[]</code> for direct access.</li>
        <li><strong>Adding and Removing Elements:</strong> Use <code>insert()</code> to add and <code>erase()</code> to remove elements.</li>
        <li><strong>Iterating:</strong> Use iterators or a range-based for loop to iterate through map elements.</li>
    </ul>
</div>


<!-------------------Sets----------------------->

<div class="main" id="sets">
    <h2>Sets</h2>

    <h3>Introduction to Sets</h3>
    <p>In C++, sets are part of the Standard Template Library (STL) and represent associative containers that store unique elements in a specific order. Sets do not allow duplicate elements and are implemented as balanced binary search trees.</p>
    <p>Sets are ideal for scenarios where you need to ensure unique values and fast search, insertion, and deletion operations.</p>

    <h3>Declaring and Initializing Sets</h3>
    <p>To use sets, the header <code>#include &lt;set&gt;</code> is required. Sets can be declared with a specific type for their elements. The syntax is:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;set&gt;

    int main() {
        // Declaring a set of integers
        set<int> mySet;

        // Initializing a set with values
        set<int> initializedSet = {10, 20, 30, 40, 50};
        
        return 0;
    }
    </pre>

    <h3>Adding Elements to a Set</h3>
    <p>Elements can be added to a set using the <code>insert()</code> function. Since sets only allow unique elements, duplicate values will not be added.</p>

    <h4>Example of Adding Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;set&gt;

    int main() {
        set<int> mySet;

        // Adding elements to the set
        mySet.insert(10);
        mySet.insert(20);
        mySet.insert(30);
        mySet.insert(20); // Duplicate, will not be added

        // Displaying elements
        for (const int& element : mySet) {
            cout << element << " ";
        }

        return 0;
    }
    </pre>

    <h3>Removing Elements from a Set</h3>
    <p>Elements can be removed from a set using the <code>erase()</code> function. You can either specify a value to remove or use an iterator.</p>

    <h4>Example of Removing Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;set&gt;

    int main() {
        set<int> mySet = {10, 20, 30, 40};

        // Removing an element by value
        mySet.erase(20);

        // Removing an element by iterator
        auto it = mySet.find(30); // Finds the iterator to 30
        if (it != mySet.end()) {
            mySet.erase(it);
        }

        // Displaying elements
        for (const int& element : mySet) {
            cout << element << " ";
        }

        return 0;
    }
    </pre>

    <h3>Accessing Elements</h3>
    <p>Sets do not provide direct access to elements via an index. Instead, you can use iterators or the <code>find()</code> function to locate specific elements.</p>

    <h4>Example of Accessing Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;set&gt;

    int main() {
        set<int> mySet = {10, 20, 30, 40};

        // Using find() to locate an element
        auto it = mySet.find(20);
        if (it != mySet.end()) {
            cout << "Element found: " << *it << endl;
        } else {
            cout << "Element not found" << endl;
        }

        return 0;
    }
    </pre>

    <h3>Iterating through a Set</h3>
    <p>You can iterate through the elements of a set using iterators or a range-based for loop. Sets maintain elements in sorted order.</p>

    <h4>Example of Iterating Through a Set</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;set&gt;

    int main() {
        set<int> mySet = {50, 10, 30, 20};

        // Using an iterator to iterate through the set
        for (auto it = mySet.begin(); it != mySet.end(); ++it) {
            cout << *it << " ";
        }
        cout << endl;

        // Using a range-based for loop
        for (const int& element : mySet) {
            cout << element << " ";
        }

        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li><strong>Sets</strong> store unique elements in sorted order.</li>
        <li><strong>Adding Elements:</strong> Use <code>insert()</code> to add elements; duplicates are ignored.</li>
        <li><strong>Removing Elements:</strong> Use <code>erase()</code> to remove elements by value or iterator.</li>
        <li><strong>Accessing Elements:</strong> Use <code>find()</code> to locate elements.</li>
        <li><strong>Iterating:</strong> Use iterators or range-based for loops to traverse elements in sorted order.</li>
    </ul>
</div>


<!-------------------Algorithms----------------------->

<div class="main" id="algorithms">
    <h2>Algorithms</h2>

    <h3>Introduction to Algorithms in STL</h3>
    <p>In C++, the Standard Template Library (STL) provides a rich collection of algorithms to perform common operations such as searching, sorting, and manipulating data. These algorithms are implemented as functions and can be applied to various containers like vectors, lists, and arrays.</p>
    <p>The <code>#include &lt;algorithm&gt;</code> header is required to use these algorithms.</p>

    <h3>Commonly Used STL Algorithms</h3>
    <ul>
        <li><strong>Sorting:</strong> <code>sort()</code></li>
        <li><strong>Searching:</strong> <code>binary_search()</code></li>
        <li><strong>Minimum/Maximum:</strong> <code>min_element()</code> and <code>max_element()</code></li>
        <li><strong>Reversing:</strong> <code>reverse()</code></li>
        <li><strong>Counting:</strong> <code>count()</code></li>
        <li><strong>Finding:</strong> <code>find()</code></li>
    </ul>

    <h3>Sorting</h3>
    <p>The <code>sort()</code> function is used to sort elements in a range in ascending order by default. It can also accept a custom comparator for descending order or custom sorting.</p>

    <h4>Example of Sorting</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;

    int main() {
        std::vector<int> nums = {5, 2, 9, 1, 5, 6};

        // Sort in ascending order
        std::sort(nums.begin(), nums.end());

        // Display sorted elements
        for (int num : nums) {
            std::cout << num << " ";
        }

        return 0;
    }
    </pre>

    <h3>Searching</h3>
    <p>The <code>binary_search()</code> function checks if an element exists in a sorted range. The range must be sorted before calling this function.</p>

    <h4>Example of Binary Search</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;

    int main() {
        std::vector<int> nums = {1, 3, 5, 7, 9};

        // Check if 5 is in the range
        if (std::binary_search(nums.begin(), nums.end(), 5)) {
            std::cout << "5 is present." << std::endl;
        } else {
            std::cout << "5 is not present." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Finding Minimum and Maximum Elements</h3>
    <p>The <code>min_element()</code> and <code>max_element()</code> functions return iterators to the smallest and largest elements in a range, respectively.</p>

    <h4>Example of Finding Min/Max Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;

    int main() {
        std::vector<int> nums = {10, 20, 5, 40, 30};

        // Find minimum and maximum
        auto minIt = std::min_element(nums.begin(), nums.end());
        auto maxIt = std::max_element(nums.begin(), nums.end());

        std::cout << "Minimum: " << *minIt << std::endl;
        std::cout << "Maximum: " << *maxIt << std::endl;

        return 0;
    }
    </pre>

    <h3>Reversing</h3>
    <p>The <code>reverse()</code> function reverses the order of elements in a range.</p>

    <h4>Example of Reversing</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;

    int main() {
        std::vector<int> nums = {1, 2, 3, 4, 5};

        // Reverse the range
        std::reverse(nums.begin(), nums.end());

        // Display reversed elements
        for (int num : nums) {
            std::cout << num << " ";
        }

        return 0;
    }
    </pre>

    <h3>Counting Elements</h3>
    <p>The <code>count()</code> function counts the occurrences of a specific value in a range.</p>

    <h4>Example of Counting</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;

    int main() {
        std::vector<int> nums = {1, 2, 3, 2, 1, 2};

        // Count occurrences of 2
        int count2 = std::count(nums.begin(), nums.end(), 2);
        std::cout << "Number of 2s: " << count2 << std::endl;

        return 0;
    }
    </pre>

    <h3>Finding Elements</h3>
    <p>The <code>find()</code> function searches for the first occurrence of a value in a range and returns an iterator to it. If the value is not found, it returns the end iterator.</p>

    <h4>Example of Finding Elements</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;

    int main() {
        std::vector<int> nums = {10, 20, 30, 40};

        // Find 30 in the range
        auto it = std::find(nums.begin(), nums.end(), 30);
        if (it != nums.end()) {
            std::cout << "Found 30 at position: " << (it - nums.begin()) << std::endl;
        } else {
            std::cout << "30 not found." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li>Algorithms in STL provide powerful functions for sorting, searching, and manipulating data.</li>
        <li><strong>Sorting:</strong> Use <code>sort()</code> for ascending or custom orders.</li>
        <li><strong>Searching:</strong> Use <code>binary_search()</code> for efficient searching in sorted ranges.</li>
        <li><strong>Finding Min/Max:</strong> Use <code>min_element()</code> and <code>max_element()</code>.</li>
        <li><strong>Reversing:</strong> Use <code>reverse()</code> to reverse elements.</li>
        <li><strong>Counting:</strong> Use <code>count()</code> to count occurrences of a value.</li>
        <li><strong>Finding:</strong> Use <code>find()</code> to locate specific elements.</li>
    </ul>
</div>


<!-------------------Reading Files----------------------->

<div class="main" id="reading-files">
    <h2>Reading Files</h2>

    <h3>Introduction</h3>
    <p>In C++, files are read using streams from the <code>fstream</code> library. The <code>ifstream</code> class is specifically designed for reading files.</p>
    <p>To read data from a file:</p>
    <ol>
        <li>Include the <code>&lt;fstream&gt;</code> header file.</li>
        <li>Create an <code>ifstream</code> object.</li>
        <li>Open the file using the <code>open()</code> method or by passing the file name to the constructor.</li>
        <li>Check if the file is successfully opened using <code>is_open()</code>.</li>
        <li>Use file stream methods such as <code>>></code> or <code>getline()</code> to read data.</li>
        <li>Close the file using <code>close()</code>.</li>
    </ol>

    <h3>Example: Reading a File Line by Line</h3>
    <p>The following example demonstrates how to read a file line by line using <code>getline()</code>:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    #include &lt;string&gt;

    int main() {
        std::ifstream inputFile("example.txt"); // Open the file
        std::string line;

        if (inputFile.is_open()) { // Check if file is open
            while (std::getline(inputFile, line)) { // Read line by line
                std::cout << line << std::endl;    // Print each line
            }
            inputFile.close(); // Close the file
        } else {
            std::cout << "Unable to open file." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Example: Reading a File Word by Word</h3>
    <p>This example shows how to read a file word by word using the extraction operator (<code>>></code>):</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    #include &lt;string&gt;

    int main() {
        std::ifstream inputFile("example.txt"); // Open the file
        std::string word;

        if (inputFile.is_open()) { // Check if file is open
            while (inputFile >> word) { // Read word by word
                std::cout << word << std::endl; // Print each word
            }
            inputFile.close(); // Close the file
        } else {
            std::cout << "Unable to open file." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Error Checking</h3>
    <p>It is essential to check whether the file was opened successfully. This can be done using the <code>is_open()</code> method. Additionally, if an error occurs during file operations, the stream's state can be checked using <code>fail()</code> or <code>eof()</code> (end-of-file).</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        std::ifstream inputFile("nonexistent.txt");

        if (!inputFile.is_open()) { // Check if the file is open
            std::cout << "File could not be opened!" << std::endl;
            return 1; // Exit with an error code
        }

        // Additional file operations...
        inputFile.close();
        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li>Use <code>ifstream</code> for reading files.</li>
        <li>Always check if the file was successfully opened using <code>is_open()</code>.</li>
        <li>Use <code>getline()</code> for reading lines and <code>>></code> for reading words.</li>
        <li>Always close the file after operations using <code>close()</code>.</li>
    </ul>
</div>


<!-------------------Writing Files----------------------->

<div class="main" id="writing-files">
    <h2>Writing Files</h2>

    <h3>Introduction</h3>
    <p>In C++, files can be written to using streams from the <code>fstream</code> library. The <code>ofstream</code> class is specifically designed for writing to files.</p>
    <p>To write data to a file:</p>
    <ol>
        <li>Include the <code>&lt;fstream&gt;</code> header file.</li>
        <li>Create an <code>ofstream</code> object.</li>
        <li>Open the file using the <code>open()</code> method or by passing the file name to the constructor.</li>
        <li>Write data using the insertion operator (<code>&lt;&lt;</code>).</li>
        <li>Close the file using <code>close()</code>.</li>
    </ol>

    <h3>Example: Writing to a File</h3>
    <p>The following example demonstrates how to write data to a file:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        std::ofstream outputFile("output.txt"); // Open the file

        if (outputFile.is_open()) { // Check if file is open
            outputFile << "This is the first line." << std::endl;
            outputFile << "This is the second line." << std::endl;
            std::cout << "Data written to the file successfully." << std::endl;
            outputFile.close(); // Close the file
        } else {
            std::cout << "Unable to open file for writing." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Appending Data to a File</h3>
    <p>To append data instead of overwriting, use the <code>ios::app</code> mode when opening the file:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        std::ofstream outputFile("output.txt", std::ios::app); // Open in append mode

        if (outputFile.is_open()) {
            outputFile << "This line is appended to the file." << std::endl;
            std::cout << "Data appended to the file successfully." << std::endl;
            outputFile.close(); // Close the file
        } else {
            std::cout << "Unable to open file for appending." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Error Checking</h3>
    <p>Always check if the file was successfully opened before attempting to write data. This can be done using the <code>is_open()</code> method. If an error occurs during writing, the stream's state can be checked using <code>fail()</code>.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        std::ofstream outputFile("nonexistent_directory/output.txt");

        if (!outputFile.is_open()) { // Check if the file is open
            std::cout << "File could not be opened for writing!" << std::endl;
            return 1; // Exit with an error code
        }

        outputFile << "This line will not be written if the file cannot be opened.";
        outputFile.close();
        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li>Use <code>ofstream</code> for writing files.</li>
        <li>Use <code>ios::app</code> mode to append data instead of overwriting.</li>
        <li>Always check if the file is open using <code>is_open()</code>.</li>
        <li>Close the file after writing using <code>close()</code>.</li>
    </ul>
</div>


<!-------------------File Modes----------------------->

<div class="main" id="file-modes">
    <h2>File Modes</h2>

    <h3>Introduction</h3>
    <p>File modes in C++ specify how a file is opened and how data can be read or written. These modes are provided as flags in the <code>fstream</code> library and can be combined using the bitwise OR operator (<code>|</code>).</p>

    <h3>Common File Modes</h3>
    <p>The most commonly used file modes are:</p>
    <ul>
        <li><code>ios::in</code>: Opens the file for reading.</li>
        <li><code>ios::out</code>: Opens the file for writing (overwrites existing content).</li>
        <li><code>ios::app</code>: Opens the file for appending (writes at the end of the file).</li>
        <li><code>ios::binary</code>: Opens the file in binary mode.</li>
        <li><code>ios::ate</code>: Opens the file and moves the file pointer to the end.</li>
        <li><code>ios::trunc</code>: Truncates the file (clears its content) if it exists.</li>
    </ul>

    <h3>Combining File Modes</h3>
    <p>You can combine file modes using the bitwise OR operator (<code>|</code>). For example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    std::fstream file("example.txt", std::ios::out | std::ios::app); 
    </pre>
    <p>This opens the file for writing and appending.</p>

    <h3>Example: Using File Modes</h3>
    <p>The following example demonstrates the use of different file modes:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        // Open file in write mode and truncate existing content
        std::ofstream outFile("example.txt", std::ios::out | std::ios::trunc);
        if (outFile.is_open()) {
            outFile << "Writing to the file." << std::endl;
            outFile.close();
        } else {
            std::cout << "Unable to open file for writing." << std::endl;
        }

        // Open file in read mode
        std::ifstream inFile("example.txt", std::ios::in);
        if (inFile.is_open()) {
            std::string line;
            while (std::getline(inFile, line)) {
                std::cout << line << std::endl;
            }
            inFile.close();
        } else {
            std::cout << "Unable to open file for reading." << std::endl;
        }

        // Open file in append mode
        std::ofstream appendFile("example.txt", std::ios::out | std::ios::app);
        if (appendFile.is_open()) {
            appendFile << "Appending to the file." << std::endl;
            appendFile.close();
        } else {
            std::cout << "Unable to open file for appending." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Binary Mode</h3>
    <p>When working with non-text files (e.g., images or executables), use the <code>ios::binary</code> mode. Here's an example:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        char data[] = { 'H', 'e', 'l', 'l', 'o' };

        // Write data in binary mode
        std::ofstream binaryOut("binary.dat", std::ios::out | std::ios::binary);
        if (binaryOut.is_open()) {
            binaryOut.write(data, sizeof(data));
            binaryOut.close();
        } else {
            std::cout << "Unable to open file for binary writing." << std::endl;
        }

        // Read data in binary mode
        char buffer[5];
        std::ifstream binaryIn("binary.dat", std::ios::in | std::ios::binary);
        if (binaryIn.is_open()) {
            binaryIn.read(buffer, sizeof(buffer));
            std::cout << "Binary Data: " << buffer << std::endl;
            binaryIn.close();
        } else {
            std::cout << "Unable to open file for binary reading." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li>Use appropriate file modes for reading, writing, or appending data.</li>
        <li>Combine modes using <code>|</code> when necessary.</li>
        <li>Use <code>ios::binary</code> for binary files.</li>
        <li>Always check if the file was successfully opened before performing operations.</li>
    </ul>
</div>


<!-------------------Working with Files----------------------->

<div class="main" id="working-with-files">
    <h2>Working with Files</h2>

    <h3>Introduction</h3>
    <p>In C++, the <code>fstream</code> library provides functionality to work with files for reading, writing, and updating. By using the appropriate file streams such as <code>ifstream</code>, <code>ofstream</code>, and <code>fstream</code>, you can perform various file operations efficiently.</p>

    <h3>File Stream Classes</h3>
    <ul>
        <li><code>ifstream</code>: Used for reading files.</li>
        <li><code>ofstream</code>: Used for writing files.</li>
        <li><code>fstream</code>: Used for both reading and writing files.</li>
    </ul>

    <h3>Opening and Closing Files</h3>
    <p>Files can be opened using the <code>open()</code> method or directly through the constructor. Always close the file using <code>close()</code> after performing operations to release resources.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        std::fstream file;

        // Open a file for both reading and writing
        file.open("example.txt", std::ios::in | std::ios::out);
        if (file.is_open()) {
            std::cout << "File opened successfully." << std::endl;
            file.close(); // Close the file
        } else {
            std::cout << "Failed to open the file." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Reading from a File</h3>
    <p>To read data from a file, use the <code>ifstream</code> or <code>fstream</code> object with <code>ios::in</code> mode:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    #include &lt;string&gt;

    int main() {
        std::ifstream inputFile("example.txt");
        if (inputFile.is_open()) {
            std::string line;
            while (std::getline(inputFile, line)) {
                std::cout << line << std::endl; // Print each line to the console
            }
            inputFile.close();
        } else {
            std::cout << "Unable to open the file for reading." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Writing to a File</h3>
    <p>To write data to a file, use the <code>ofstream</code> or <code>fstream</code> object with <code>ios::out</code> mode:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        std::ofstream outputFile("example.txt", std::ios::out);
        if (outputFile.is_open()) {
            outputFile << "This is the first line." << std::endl;
            outputFile << "This is the second line." << std::endl;
            outputFile.close();
        } else {
            std::cout << "Unable to open the file for writing." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Random Access</h3>
    <p>You can move the file pointer to specific locations for reading or writing using the following methods:</p>
    <ul>
        <li><code>seekg</code>: Move the input pointer for reading.</li>
        <li><code>seekp</code>: Move the output pointer for writing.</li>
        <li><code>tellg</code>: Get the current position of the input pointer.</li>
        <li><code>tellp</code>: Get the current position of the output pointer.</li>
    </ul>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;

    int main() {
        std::fstream file("example.txt", std::ios::in | std::ios::out);
        if (file.is_open()) {
            file.seekp(0, std::ios::end); // Move to the end of the file
            file << "Appending data using seekp." << std::endl;

            file.seekg(0, std::ios::beg); // Move to the beginning of the file
            std::string line;
            while (std::getline(file, line)) {
                std::cout << line << std::endl;
            }
            file.close();
        } else {
            std::cout << "Unable to open the file for random access." << std::endl;
        }

        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li>Use <code>ifstream</code>, <code>ofstream</code>, and <code>fstream</code> for file operations.</li>
        <li>Always close files after performing operations.</li>
        <li>Use <code>seekg</code>, <code>seekp</code>, <code>tellg</code>, and <code>tellp</code> for random access in files.</li>
    </ul>
</div>
 

<!-------------------Syntax Errors----------------------->

<div class="main" id="syntax-errors">
    <h2>Syntax Errors</h2>

    <h3>What are Syntax Errors?</h3>
    <p>Syntax errors occur when the code violates the rules of the C++ language. These errors are detected during the compilation process and prevent the program from being compiled.</p>

    <h3>Common Causes of Syntax Errors</h3>
    <ul>
        <li><strong>Missing Semicolons:</strong> Every statement in C++ must end with a semicolon (<code>;</code>).</li>
        <li><strong>Mismatched Braces:</strong> Opening and closing curly braces (<code>{</code> and <code>}</code>) must match.</li>
        <li><strong>Incorrect Variable Declarations:</strong> Variables must be declared with valid data types.</li>
        <li><strong>Misspelled Keywords:</strong> C++ keywords must be spelled correctly and used in the correct context.</li>
        <li><strong>Incorrect Syntax for Loops, Conditions, or Functions:</strong> Control structures and functions must follow the correct syntax rules.</li>
    </ul>

    <h3>Examples of Syntax Errors</h3>
    <p>Below are some common syntax errors and how to fix them:</p>

    <h4>Missing Semicolon</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Incorrect
    int x = 10
    cout << x;

    // Correct
    int x = 10;
    cout << x;
    </pre>

    <h4>Mismatched Braces</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Incorrect
    int main() {
        if (true) {
            cout << "Hello, World!";
    }

    // Correct
    int main() {
        if (true) {
            cout << "Hello, World!";
        }
    }
    </pre>

    <h4>Incorrect Variable Declaration</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Incorrect
    int x = "hello"; // Mismatched data type

    // Correct
    string x = "hello";
    </pre>

    <h4>Misspelled Keyword</h4>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Incorrect
    interger x = 10; // Incorrect spelling of 'integer'

    // Correct
    int x = 10;
    </pre>

    <h3>Tips to Avoid Syntax Errors</h3>
    <ul>
        <li>Pay attention to the syntax rules of C++ while writing code.</li>
        <li>Use an Integrated Development Environment (IDE) or text editor that highlights syntax errors.</li>
        <li>Always check for missing semicolons, mismatched braces, and correct spelling of keywords.</li>
        <li>Test small sections of code to ensure they compile successfully before adding more functionality.</li>
    </ul>

    <h3>How to Debug Syntax Errors</h3>
    <ul>
        <li>Read the error messages from the compiler carefully to locate the issue.</li>
        <li>Double-check the line number and surrounding code where the error is reported.</li>
        <li>Use comments to temporarily isolate parts of the code to narrow down the issue.</li>
    </ul>

    <h3>Conclusion</h3>
    <p>Syntax errors are common, especially for beginners, but they are easy to identify and fix. Developing a habit of writing clean and syntactically correct code will help reduce the occurrence of such errors.</p>
</div>

<!-------------------Exceptions----------------------->

<div class="main" id="exceptions">
    <h2>Exceptions</h2>

    <h3>What are Exceptions?</h3>
    <p>Exceptions are runtime errors that occur during the execution of a program. C++ provides a mechanism to handle exceptions using a try-catch block, allowing the program to handle errors gracefully instead of crashing.</p>

    <h3>Common Scenarios Leading to Exceptions</h3>
    <ul>
        <li>Division by zero</li>
        <li>Accessing invalid array indices</li>
        <li>Memory allocation failures</li>
        <li>File handling errors</li>
    </ul>

    <h3>Exception Handling Mechanism</h3>
    <p>C++ provides the following keywords to handle exceptions:</p>
    <ul>
        <li><strong>try:</strong> Defines a block of code to test for exceptions.</li>
        <li><strong>catch:</strong> Defines a block of code to handle exceptions.</li>
        <li><strong>throw:</strong> Used to throw an exception.</li>
    </ul>

    <h3>Basic Syntax</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    try {
        // Code that may throw an exception
    } catch (exceptionType exception) {
        // Code to handle the exception
    }
    </pre>

    <h3>Example: Division by Zero</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        try {
            int a = 10, b = 0;
            if (b == 0) {
                throw "Division by zero error"; // Throw an exception
            }
            cout << "Result: " << a / b << endl;
        } catch (const char* e) {
            cout << "Exception caught: " << e << endl; // Handle the exception
        }

        return 0;
    }
    </pre>

    <h3>Multiple Catch Blocks</h3>
    <p>C++ allows multiple catch blocks to handle different types of exceptions:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        try {
            int x = -1;
            if (x < 0) {
                throw x; // Throw an integer exception
            }
        } catch (int e) {
            cout << "Caught an integer exception: " << e << endl;
        } catch (...) {
            cout << "Caught an unknown exception" << endl;
        }

        return 0;
    }
    </pre>

    <h3>Standard Exceptions</h3>
    <p>C++ provides a set of standard exceptions defined in the <code>&lt;stdexcept&gt;</code> header. Some commonly used standard exceptions are:</p>
    <ul>
        <li><code>std::runtime_error</code></li>
        <li><code>std::out_of_range</code></li>
        <li><code>std::invalid_argument</code></li>
        <li><code>std::bad_alloc</code></li>
    </ul>

    <h3>Example: Using Standard Exceptions</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;stdexcept&gt;
    using namespace std;

    int main() {
        try {
            throw runtime_error("A runtime error occurred");
        } catch (runtime_error& e) {
            cout << "Exception caught: " << e.what() << endl;
        }

        return 0;
    }
    </pre>

    <h3>Summary</h3>
    <ul>
        <li>Exceptions help handle runtime errors gracefully.</li>
        <li>Use <code>try</code>, <code>catch</code>, and <code>throw</code> to implement exception handling.</li>
        <li>Standard exceptions provide predefined error handling for common scenarios.</li>
    </ul>
</div>

<!-------------------Try and Catch----------------------->

<div class="main" id="try-and-catch">
    <h2>Try and Catch</h2>

    <h3>What are Try and Catch Blocks?</h3>
    <p>The <code>try</code> and <code>catch</code> blocks are used in C++ to handle exceptions. The <code>try</code> block contains the code that might throw an exception, while the <code>catch</code> block handles the exception and prevents the program from crashing.</p>

    <h3>Basic Syntax</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    try {
        // Code that may throw an exception
    } catch (exceptionType exception) {
        // Code to handle the exception
    }
    </pre>

    <h3>Example: Division by Zero</h3>
    <p>This example demonstrates the use of <code>try</code> and <code>catch</code> to handle a division by zero exception:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        try {
            int a = 10, b = 0;
            if (b == 0) {
                throw "Division by zero is not allowed"; // Throw an exception
            }
            cout << "Result: " << a / b << endl;
        } catch (const char* e) {
            cout << "Exception caught: " << e << endl; // Handle the exception
        }

        return 0;
    }
    </pre>

    <h3>Multiple Catch Blocks</h3>
    <p>A <code>try</code> block can be followed by multiple <code>catch</code> blocks to handle different types of exceptions:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        try {
            int value = -1;
            if (value < 0) {
                throw value; // Throw an integer exception
            }
        } catch (int e) {
            cout << "Caught an integer exception: " << e << endl;
        } catch (...) {
            cout << "Caught an unknown exception" << endl;
        }

        return 0;
    }
    </pre>

    <h3>Using Standard Exceptions</h3>
    <p>C++ has a set of standard exceptions defined in the <code>&lt;stdexcept&gt;</code> header. These can also be handled using <code>try</code> and <code>catch</code>:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    #include &lt;stdexcept&gt;
    using namespace std;

    int main() {
        try {
            throw runtime_error("A runtime error occurred");
        } catch (const runtime_error& e) {
            cout << "Exception caught: " << e.what() << endl;
        }

        return 0;
    }
    </pre>

    <h3>Key Points</h3>
    <ul>
        <li>The <code>try</code> block is used to identify code that might throw an exception.</li>
        <li>The <code>catch</code> block handles specific exceptions.</li>
        <li>Multiple <code>catch</code> blocks can be used to handle different types of exceptions.</li>
        <li>The <code>catch (...)</code> block can be used to catch all types of exceptions.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Always use exception handling to manage runtime errors effectively.</li>
        <li>Write specific <code>catch</code> blocks for expected exceptions.</li>
        <li>Avoid overusing exceptions for normal control flow; they should be used only for error handling.</li>
    </ul>
</div>

<!-------------------Throwing Exceptions----------------------->

<div class="main" id="throwing-exceptions">
    <h2>Throwing Exceptions</h2>

    <h3>What is Throwing an Exception?</h3>
    <p>In C++, the <code>throw</code> keyword is used to signal an error or unexpected condition during program execution. When an exception is thrown, it is caught by an appropriate <code>catch</code> block to handle the error.</p>

    <h3>Basic Syntax</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    throw exception; // exception can be any data type or object
    </pre>
    <p>The <code>throw</code> statement is typically used inside a <code>try</code> block to signal an error, which is then handled by the corresponding <code>catch</code> block.</p>

    <h3>Example: Throwing a String Exception</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        try {
            int a = 10, b = 0;
            if (b == 0) {
                throw "Division by zero is not allowed"; // Throw a string exception
            }
            cout << "Result: " << a / b << endl;
        } catch (const char* e) {
            cout << "Exception caught: " << e << endl; // Handle the exception
        }

        return 0;
    }
    </pre>

    <h3>Throwing Different Types of Exceptions</h3>
    <p>You can throw exceptions of various types, such as integers, strings, or even objects of custom classes:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    class CustomException {
    public:
        string message;
        CustomException(string msg) : message(msg) {}
    };

    int main() {
        try {
            int value = -1;
            if (value < 0) {
                throw CustomException("Negative value is not allowed"); // Throw a custom exception
            }
        } catch (CustomException& e) {
            cout << "Custom exception caught: " << e.message << endl;
        }

        return 0;
    }
    </pre>

    <h3>Throwing Exceptions from Functions</h3>
    <p>Functions can also throw exceptions. Use the <code>throw</code> keyword to signal an error from within a function:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    double divide(int a, int b) {
        if (b == 0) {
            throw runtime_error("Division by zero error"); // Throw an exception
        }
        return (double)a / b;
    }

    int main() {
        try {
            cout << divide(10, 0) << endl; // Attempt division by zero
        } catch (runtime_error& e) {
            cout << "Exception caught: " << e.what() << endl; // Handle the exception
        }

        return 0;
    }
    </pre>

    <h3>Key Points</h3>
    <ul>
        <li>The <code>throw</code> keyword signals an error or unexpected condition.</li>
        <li>Exceptions can be of any type, including integers, strings, or objects.</li>
        <li>Functions can use <code>throw</code> to propagate errors to the calling code.</li>
        <li>Use <code>try</code> and <code>catch</code> to handle thrown exceptions gracefully.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Use specific exception types for better error handling.</li>
        <li>Avoid throwing exceptions for normal control flow; use them for errors and exceptional conditions only.</li>
        <li>Always document the exceptions that a function can throw to improve code readability and maintainability.</li>
    </ul>
</div>

<!-------------------Operator Overloading----------------------->

<div class="main" id="operator-overloading">
    <h2>Operator Overloading</h2>

    <h3>What is Operator Overloading?</h3>
    <p>Operator overloading allows you to redefine the functionality of operators for custom objects. In C++, operators can be overloaded to perform operations on user-defined types, like classes and structs.</p>

    <h3>Basic Syntax</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    returnType operator operatorSymbol (parameterList) {
        // Operator functionality
    }
    </pre>
    <p>The syntax for overloading an operator involves specifying the return type, operator symbol, and any parameters needed for the operation.</p>

    <h3>Example: Overloading the "+" Operator</h3>
    <p>In this example, we overload the <code>+</code> operator to add two complex number objects:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    class Complex {
    public:
        int real, imag;
        Complex(int r, int i) : real(r), imag(i) {}

        // Overload the "+" operator to add two Complex objects
        Complex operator + (const Complex& obj) {
            return Complex(real + obj.real, imag + obj.imag);
        }

        void display() {
            cout << real << " + " << imag << "i" << endl;
        }
    };

    int main() {
        Complex num1(3, 4), num2(1, 2);
        Complex result = num1 + num2; // Uses overloaded "+" operator
        result.display();

        return 0;
    }
    </pre>

    <h3>Overloading Other Operators</h3>
    <p>Besides the <code>+</code> operator, you can overload many other operators such as <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, and more:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    class Point {
    public:
        int x, y;
        Point(int x, int y) : x(x), y(y) {}

        // Overload the "==" operator to compare two Point objects
        bool operator == (const Point& obj) {
            return (x == obj.x && y == obj.y);
        }
    };

    int main() {
        Point p1(3, 4), p2(3, 4), p3(5, 6);
        cout << (p1 == p2) << endl; // Outputs 1 (true)
        cout << (p1 == p3) << endl; // Outputs 0 (false)

        return 0;
    }
    </pre>

    <h3>Key Points</h3>
    <ul>
        <li>Operator overloading allows you to define custom behavior for operators.</li>
        <li>It is done by defining a function with the keyword <code>operator</code> followed by the operator symbol.</li>
        <li>Overloading can be done for many operators such as <code>+</code>, <code>-</code>, <code>==</code>, and others.</li>
        <li>Operators can be overloaded for both member and non-member functions.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Only overload operators when it makes logical sense for your class or data type.</li>
        <li>Avoid overloading operators in a way that might confuse the reader of your code.</li>
        <li>Ensure overloaded operators behave intuitively and maintain consistency with their built-in counterparts.</li>
    </ul>
</div>

<!-------------------Templates----------------------->

<div class="main" id="templates">
    <h2>Templates</h2>

    <h3>What is a Template?</h3>
    <p>In C++, templates allow you to write generic and reusable code. You can define functions and classes that work with any data type, without needing to specify the type in advance. Templates are the foundation for the Standard Template Library (STL) in C++.</p>

    <h3>Function Templates</h3>
    <p>A function template defines a function that can work with any data type. The type is determined when the function is called.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    // Function template to find the maximum of two values
    template &lt;typename T&gt;
    T max(T a, T b) {
        return (a > b) ? a : b;
    }

    int main() {
        cout &lt;&lt; max(3, 5) &lt;&lt; endl; // Works with int
        cout &lt;&lt; max(3.5, 2.1) &lt;&lt; endl; // Works with double

        return 0;
    }
    </pre>
    <p>In this example, the <code>max</code> function works with both integers and floating-point numbers by using a template that can accept any data type (<code>T</code>).</p>

    <h3>Class Templates</h3>
    <p>Just like functions, you can create class templates that allow a class to operate with different data types.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    // Class template to represent a pair of values
    template &lt;typename T&gt;
    class Pair {
    public:
        T first, second;
        Pair(T a, T b) : first(a), second(b) {}
        void display() {
            cout &lt;&lt; "First: " &lt;&lt; first &lt;&lt; ", Second: " &lt;&lt; second &lt;&lt; endl;
        }
    };

    int main() {
        Pair&lt;int&gt; p1(1, 2);
        Pair&lt;double&gt; p2(3.5, 7.8);
        p1.display();
        p2.display();

        return 0;
    }
    </pre>
    <p>In this example, the <code>Pair</code> class is a template that can hold two values of any type, such as <code>int</code> and <code>double</code>.</p>

    <h3>Template Specialization</h3>
    <p>Template specialization allows you to define specific behavior for particular types while still using templates for general cases.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    // General template
    template &lt;typename T&gt;
    T multiply(T a, T b) {
        return a * b;
    }

    // Specialization for type 'char'
    template &lt;&gt;
    char multiply(char a, char b) {
        cout &lt;&lt; "Multiplying characters: ";
        return a + b;
    }

    int main() {
        cout &lt;&lt; multiply(3, 4) &lt;&lt; endl; // Works with int
        cout &lt;&lt; multiply('A', 'B') &lt;&lt; endl; // Specialization for char

        return 0;
    }
    </pre>
    <p>In this example, a general template for <code>multiply</code> works with most types, but a specialization is defined for <code>char</code> types to provide custom behavior.</p>

    <h3>Key Points</h3>
    <ul>
        <li>Templates enable generic programming by allowing functions and classes to work with any data type.</li>
        <li>Use <code>template &lt;typename T&gt;</code> to define a template function or class.</li>
        <li>Template specialization allows you to define specific implementations for certain data types.</li>
        <li>Templates are commonly used in C++ libraries, such as the Standard Template Library (STL).</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Use templates when you need to write functions or classes that can work with multiple types.</li>
        <li>Be mindful of code readability, as excessive use of templates can make the code more complex.</li>
        <li>Use template specialization judiciously for performance optimization or custom behavior for specific types.</li>
    </ul>
</div>

<!-------------------Namespaces----------------------->

<div class="main" id="namespaces">
    <h2>Namespaces</h2>

    <h3>What is a Namespace?</h3>
    <p>In C++, namespaces are used to group identifiers such as classes, functions, and variables into a logical unit to avoid name conflicts. Namespaces help in organizing code and managing scope. The standard library, for example, uses the <code>std</code> namespace.</p>

    <h3>Basic Syntax</h3>
    <p>The syntax for defining a namespace is as follows:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    namespace NamespaceName {
        // Code goes here
    }
    </pre>

    <h3>Example: Defining and Using a Namespace</h3>
    <p>Here’s a simple example of creating and using a namespace:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    // Define a custom namespace
    namespace MyNamespace {
        void display() {
            cout &lt;&lt; "Hello from MyNamespace!" &lt;&lt; endl;
        }
    }

    int main() {
        // Access the function from MyNamespace
        MyNamespace::display();
        return 0;
    }
    </pre>
    <p>In this example, we define a namespace called <code>MyNamespace</code> that contains a function <code>display()</code>. In the <code>main()</code> function, we access the <code>display()</code> function by using the <code>MyNamespace::</code> syntax.</p>

    <h3>Using the Standard Namespace</h3>
    <p>The standard library (STL) uses the <code>std</code> namespace, and many common functions such as <code>cout</code> and <code>cin</code> are defined within it. You can either specify <code>std::</code> before using standard functions or use the <code>using namespace std;</code> directive.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        cout &lt;&lt; "Hello, World!" &lt;&lt; endl;  // Uses std namespace
        return 0;
    }
    </pre>
    <p>In the above code, the <code>using namespace std;</code> allows us to use <code>cout</code> and <code>endl</code> directly without the <code>std::</code> prefix.</p>

    <h3>Nested Namespaces</h3>
    <p>You can also nest namespaces within each other, which is useful for grouping related functionality.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    namespace OuterNamespace {
        namespace InnerNamespace {
            void display() {
                cout &lt;&lt; "Hello from InnerNamespace!" &lt;&lt; endl;
            }
        }
    }

    int main() {
        // Access function from the nested namespace
        OuterNamespace::InnerNamespace::display();
        return 0;
    }
    </pre>
    <p>This example demonstrates how to access a function inside a nested namespace.</p>

    <h3>Anonymous Namespaces</h3>
    <p>An anonymous namespace does not have a name and is used to define code that is only accessible within the current translation unit (i.e., file). It is useful for internal linkage, preventing name conflicts across different files.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    // Anonymous namespace
    namespace {
        void display() {
            cout &lt;&lt; "Hello from an anonymous namespace!" &lt;&lt; endl;
        }
    }

    int main() {
        display();  // Works because it's in the same file
        return 0;
    }
    </pre>
    <p>In this example, the function <code>display()</code> is defined inside an anonymous namespace, and it is only accessible within this file.</p>

    <h3>Key Points</h3>
    <ul>
        <li>Namespaces group related code together and prevent name conflicts.</li>
        <li>You can define your own namespaces and use the <code>::</code> operator to access elements within them.</li>
        <li>The <code>std</code> namespace is used by the C++ Standard Library.</li>
        <li>Anonymous namespaces are used to limit the scope of variables and functions to a single file.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Use namespaces to organize code and avoid naming collisions, especially when working on large projects.</li>
        <li>Be cautious when using <code>using namespace std;</code>, as it can lead to ambiguity in larger codebases.</li>
        <li>Prefer nested namespaces when logically grouping related functionality.</li>
    </ul>
</div>

<!-------------------Dynamic Memory----------------------->

<div class="main" id="dynamic-memory">
    <h2>Dynamic Memory</h2>

    <h3>What is Dynamic Memory?</h3>
    <p>Dynamic memory in C++ refers to memory that is allocated at runtime using pointers, as opposed to static or automatic memory which is allocated at compile-time. Dynamic memory allocation is useful when the amount of memory required is not known in advance and can vary during the execution of a program.</p>

    <h3>Memory Allocation and Deallocation</h3>
    <p>C++ provides the <code>new</code> and <code>delete</code> operators to allocate and deallocate memory, respectively:</p>
    <ul>
        <li><code>new</code>: Allocates memory on the heap for a single variable or array of variables.</li>
        <li><code>delete</code>: Deallocates memory that was previously allocated using <code>new</code>.</li>
    </ul>

    <h3>Example: Allocating Memory for a Single Variable</h3>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        // Dynamically allocate memory for an integer
        int* ptr = new int;

        // Assign a value to the dynamically allocated memory
        *ptr = 10;

        // Output the value stored in the dynamically allocated memory
        cout &lt;&lt; "Value: " &lt;&lt; *ptr &lt;&lt; endl;

        // Deallocate memory when done
        delete ptr;

        return 0;
    }
    </pre>
    <p>In this example, the program allocates memory for a single integer using <code>new</code>, assigns a value, and then deallocates the memory using <code>delete</code> to prevent memory leaks.</p>

    <h3>Example: Allocating Memory for an Array</h3>
    <p>Dynamic memory can also be allocated for arrays:</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int main() {
        // Dynamically allocate memory for an array of 5 integers
        int* arr = new int[5];

        // Assign values to the array
        for (int i = 0; i &lt; 5; ++i) {
            arr[i] = i * 2;
        }

        // Output the values stored in the array
        for (int i = 0; i &lt; 5; ++i) {
            cout &lt;&lt; "arr[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; arr[i] &lt;&lt; endl;
        }

        // Deallocate memory for the array
        delete[] arr;

        return 0;
    }
    </pre>
    <p>This example dynamically allocates an array of integers, assigns values to the array elements, and then deallocates the memory using <code>delete[]</code>.</p>

    <h3>Memory Leaks</h3>
    <p>Memory leaks occur when dynamically allocated memory is not deallocated properly. Always ensure that memory allocated with <code>new</code> is freed using <code>delete</code> or <code>delete[]</code> to avoid memory leaks.</p>

    <h3>Key Points</h3>
    <ul>
        <li>Use <code>new</code> to allocate memory dynamically and <code>delete</code> to deallocate it.</li>
        <li>Always pair <code>new</code> with <code>delete</code> to avoid memory leaks.</li>
        <li>For arrays, use <code>new[]</code> and <code>delete[]</code>.</li>
        <li>Dynamic memory allows flexible memory usage, but requires careful management to avoid memory issues.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Use smart pointers (like <code>std::unique_ptr</code> or <code>std::shared_ptr</code>) in modern C++ to automate memory management and avoid manual <code>new</code>/<code>delete</code>.</li>
        <li>Use <code>new</code> and <code>delete</code> sparingly. Prefer containers such as <code>std::vector</code> or <code>std::string</code> for automatic memory management.</li>
        <li>Always deallocate memory as soon as it is no longer needed.</li>
    </ul>
</div>

<!-------------------Preprocessor Directives----------------------->

<div class="main" id="preprocessor-directives">
    <h2>Preprocessor Directives</h2>

    <h3>What are Preprocessor Directives?</h3>
    <p>Preprocessor directives are lines included in the code that are processed by the preprocessor before the actual compilation starts. These directives are used to include files, define constants, or conditionally compile code. Preprocessor directives begin with the <code>#</code> symbol.</p>

    <h3>Common Preprocessor Directives</h3>
    <ul>
        <li><code>#include</code>: Includes a header file.</li>
        <li><code>#define</code>: Defines a constant or macro.</li>
        <li><code>#ifdef</code>, <code>#ifndef</code>, <code>#endif</code>: Conditional compilation.</li>
        <li><code>#pragma</code>: Compiler-specific instructions.</li>
    </ul>

    <h3>1. Including Header Files</h3>
    <p>The <code>#include</code> directive is used to include header files in your program. You can include standard library files or your custom header files.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;  // Standard library header file
    #include &lt;myheader.h&gt; // Custom header file
    </pre>
    <p>Here, <code>#include &lt;iostream&gt;</code> includes the standard input/output stream library, and <code>#include &lt;myheader.h&gt;</code> includes a custom header file called <code>myheader.h</code>.</p>

    <h3>2. Defining Constants and Macros</h3>
    <p>The <code>#define</code> directive is used to define constants or macros. Constants are values that do not change, and macros are snippets of code that are substituted at compile-time.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #define PI 3.14    // Defining a constant
    #define SQUARE(x) ((x) * (x))  // Defining a macro for squaring a number
    </pre>
    <p>In this example, <code>#define PI 3.14</code> defines a constant <code>PI</code>, and <code>#define SQUARE(x) ((x) * (x))</code> defines a macro for calculating the square of a number.</p>

    <h3>3. Conditional Compilation</h3>
    <p>Conditional compilation allows the program to compile specific parts of the code depending on certain conditions. The directives <code>#ifdef</code> (if defined), <code>#ifndef</code> (if not defined), and <code>#endif</code> are used for this purpose.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #define DEBUG

    #ifdef DEBUG
        cout &lt;&lt; "Debugging information" &lt;&lt; endl;
    #endif
    </pre>
    <p>In this example, the code inside the <code>#ifdef DEBUG</code> block will only be compiled if <code>DEBUG</code> is defined.</p>

    <h3>4. Pragma Directive</h3>
    <p>The <code>#pragma</code> directive is used to provide additional instructions to the compiler. The usage and meaning of <code>#pragma</code> can vary between different compilers.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #pragma once  // Ensures the header file is included only once
    </pre>
    <p>Here, <code>#pragma once</code> ensures that a header file is included only once in a single compilation, preventing redefinition errors.</p>

    <h3>Key Points</h3>
    <ul>
        <li>Preprocessor directives are executed before the program is compiled.</li>
        <li><code>#include</code> is used to include header files.</li>
        <li><code>#define</code> is used to define constants and macros.</li>
        <li>Conditional compilation is possible with <code>#ifdef</code>, <code>#ifndef</code>, and <code>#endif</code>.</li>
        <li><code>#pragma</code> provides instructions to the compiler for specific purposes.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Use <code>#define</code> for constants and macros only when necessary. Prefer const variables and inline functions for better type safety and debugging.</li>
        <li>Use <code>#include</code> to organize code into separate header files to improve modularity.</li>
        <li>Minimize the use of <code>#pragma</code> as its functionality may vary across compilers.</li>
        <li>Be cautious with conditional compilation to avoid introducing bugs that only occur in certain environments or configurations.</li>
    </ul>
</div>

<!-------------------Debugging Techniques----------------------->

<div class="main" id="debugging-techniques">
    <h2>Debugging Techniques</h2>

    <h3>What is Debugging?</h3>
    <p>Debugging is the process of identifying and fixing errors or bugs in a program. In C++, debugging is crucial because programs may contain logical, runtime, or syntax errors that can cause unexpected behavior or crashes. There are several techniques to find and resolve these issues.</p>

    <h3>Common Debugging Techniques</h3>
    <ul>
        <li><strong>Using Print Statements:</strong> Inserting <code>cout</code> statements in various parts of the code to monitor variable values and program flow.</li>
        <li><strong>Using a Debugger:</strong> Using a debugger to step through the code line by line and inspect variable values and control flow in real time.</li>
        <li><strong>Code Review:</strong> Reviewing code with a colleague or using tools like static analyzers to detect potential issues.</li>
        <li><strong>Unit Testing:</strong> Writing tests to verify individual parts of the program work as expected.</li>
    </ul>

    <h3>1. Using Print Statements</h3>
    <p>One of the simplest ways to debug a program is by using <code>cout</code> to print messages to the console, allowing you to track variables and the flow of execution. This method is useful for small programs or quick checks.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int main() {
        int x = 5;
        cout &lt;&lt; "Value of x: " &lt;&lt; x &lt;&lt; endl;  // Print the value of x
        // Debugging further...
        return 0;
    }
    </pre>
    <p>Here, the program prints the value of <code>x</code> to the console. This can help verify if <code>x</code> is being set correctly.</p>

    <h3>2. Using a Debugger</h3>
    <p>A debugger is a tool that allows you to run your program in a controlled environment where you can step through the code, inspect variable values, and understand the program’s execution flow. Most integrated development environments (IDEs) like Visual Studio, Code::Blocks, or Xcode come with built-in debuggers.</p>
    <ul>
        <li><strong>Breakpoints:</strong> Set breakpoints at specific lines where the program will pause, allowing you to inspect variables.</li>
        <li><strong>Step Through:</strong> Step through the code one line at a time to observe the flow and identify where the error occurs.</li>
        <li><strong>Watch Variables:</strong> Watch variables in the debugger to track their values during execution.</li>
    </ul>
    <p>Using a debugger is especially helpful for complex programs where print statements alone would not be sufficient.</p>

    <h3>3. Code Review</h3>
    <p>Code review is a collaborative process where developers review each other’s code to find potential errors or improvements. This can be done manually or with the help of automated static analysis tools. A fresh pair of eyes can often spot issues that the original developer missed.</p>
    <ul>
        <li>Review the logic and flow of the program.</li>
        <li>Check for common pitfalls like off-by-one errors or missing semicolons.</li>
        <li>Ensure that all edge cases are considered.</li>
    </ul>

    <h3>4. Unit Testing</h3>
    <p>Unit testing involves writing small tests to check if individual parts of the program work as expected. This can help identify issues early in the development process, making it easier to locate the source of a bug.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    #include &lt;iostream&gt;
    using namespace std;

    int add(int a, int b) {
        return a + b;
    }

    int main() {
        if (add(2, 3) == 5) {
            cout &lt;&lt; "Test Passed" &lt;&lt; endl;
        } else {
            cout &lt;&lt; "Test Failed" &lt;&lt; endl;
        }
        return 0;
    }
    </pre>
    <p>In this example, the <code>add()</code> function is tested to ensure it returns the correct result. If the test passes, "Test Passed" is printed, otherwise "Test Failed" is displayed.</p>

    <h3>Best Practices for Debugging</h3>
    <ul>
        <li>Start by understanding the problem and isolating the issue.</li>
        <li>Use breakpoints and debuggers for complex issues.</li>
        <li>Write unit tests to catch errors early and prevent regressions.</li>
        <li>Collaborate with others during code reviews to identify potential issues.</li>
        <li>Keep the code simple and well-documented to minimize the chances of bugs occurring in the first place.</li>
    </ul>

</div>

<!-------------------Best Practices----------------------->

<div class="main" id="best-practices">
    <h2>Best Practices</h2>

    <h3>What Are Best Practices?</h3>
    <p>Best practices are a set of guidelines and principles that help programmers write clean, efficient, and maintainable code. Following best practices can improve the readability, performance, and overall quality of your C++ programs.</p>

    <h3>Key Best Practices in C++</h3>
    <ul>
        <li><strong>Write Clear and Readable Code:</strong> Prioritize code readability and clarity over cleverness. Write code that others can easily understand and maintain.</li>
        <li><strong>Follow Naming Conventions:</strong> Use descriptive and consistent names for variables, functions, and classes. This makes the code more intuitive.</li>
        <li><strong>Use Comments Wisely:</strong> Use comments to explain complex or non-obvious code. Avoid over-commenting obvious parts of the code.</li>
        <li><strong>Avoid Global Variables:</strong> Minimize the use of global variables as they can lead to unexpected behaviors and make debugging difficult.</li>
        <li><strong>Write Modular Code:</strong> Break down your code into small, reusable functions or classes. This makes the code easier to maintain and test.</li>
        <li><strong>Optimize for Readability First, Performance Later:</strong> Focus on writing clear and understandable code, and optimize for performance only when necessary.</li>
        <li><strong>Handle Errors Properly:</strong> Use proper error handling mechanisms, such as exceptions, to gracefully handle unexpected situations in the code.</li>
        <li><strong>Use the Standard Library:</strong> Leverage the C++ Standard Library (STL) to avoid reinventing the wheel. STL provides efficient and well-tested implementations for common data structures and algorithms.</li>
        <li><strong>Avoid Memory Leaks:</strong> Always ensure that dynamically allocated memory is properly freed when no longer needed.</li>
    </ul>

    <h3>1. Write Clear and Readable Code</h3>
    <p>Write code that is easy to read and understand. Use proper indentation, meaningful variable names, and avoid writing overly complex one-liners.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int calculateArea(int length, int width) {
        return length * width;
    }
    </pre>
    <p>In this example, the function <code>calculateArea()</code> has a clear and descriptive name, making it easy to understand its purpose.</p>

    <h3>2. Follow Naming Conventions</h3>
    <p>Use consistent naming conventions for variables, functions, classes, and constants. This improves the readability and maintainability of your code. A common naming convention in C++ is:</p>
    <ul>
        <li><strong>Variables:</strong> Use lowerCamelCase, e.g., <code>userAge</code>.</li>
        <li><strong>Functions:</strong> Use lowerCamelCase or verbs, e.g., <code>calculateSum()</code>.</li>
        <li><strong>Classes:</strong> Use PascalCase, e.g., <code>StudentDetails</code>.</li>
        <li><strong>Constants:</strong> Use UPPERCASE with underscores, e.g., <code>MAX_SIZE</code>.</li>
    </ul>

    <h3>3. Avoid Global Variables</h3>
    <p>Global variables are variables declared outside of any function or class. They can be accessed from anywhere in the program, which can lead to issues such as unintended modifications or hard-to-track bugs. Limit their usage as much as possible.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    // Avoid using global variables
    int globalVar;  // Avoid this!

    // Use local variables instead
    void myFunction() {
        int localVar = 10;
    }
    </pre>
    <p>In this example, <code>globalVar</code> is a global variable, which should be avoided. Instead, use local variables like <code>localVar</code> within functions to limit scope and improve modularity.</p>

    <h3>4. Write Modular Code</h3>
    <p>Modular code breaks the program into smaller, manageable functions or classes. This makes your code reusable, easier to test, and easier to debug.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    int add(int a, int b) {
        return a + b;
    }

    int main() {
        int result = add(2, 3); // Using a modular function
        cout &lt;&lt; "The result is: " &lt;&lt; result;
        return 0;
    }
    </pre>
    <p>In this example, the <code>add()</code> function is modular, making it reusable and easier to maintain.</p>

    <h3>5. Handle Errors Properly</h3>
    <p>Proper error handling is essential in any program. Use <code>try-catch</code> blocks and exceptions to handle errors gracefully rather than allowing the program to crash.</p>
    <pre>
    <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
    try {
        int result = 10 / 0;  // Division by zero
    } catch (const exception &e) {
        cout &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; endl;
    }
    </pre>
    <p>In this example, a division by zero is handled using a <code>try-catch</code> block to prevent the program from crashing and to display an error message.</p>

    <h3>Best Practices Summary</h3>
    <ul>
        <li>Write clear, readable, and maintainable code.</li>
        <li>Follow naming conventions for consistency.</li>
        <li>Avoid global variables to minimize side effects.</li>
        <li>Break the code into modular functions and classes.</li>
        <li>Handle errors gracefully using exceptions.</li>
        <li>Leverage the C++ Standard Library to save time and effort.</li>
        <li>Regularly review and refactor code for improvements.</li>
    </ul>

</div>










        </div>

        
    <script src="script1.js"></script>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const menuBtn = document.getElementById("menuBtn");
            const sidebar = document.getElementById("sidebar");

            menuBtn.addEventListener("click", () => {
                sidebar.classList.toggle("active");
            });

            const sidebarLinks = document.querySelectorAll(".sidebar ul li a");
            const contentSections = document.querySelectorAll(".content .content");

            sidebarLinks.forEach(link => {
                link.addEventListener("click", (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute("href").substring(1);

                    // Hide all content sections and reset sidebar links
                    contentSections.forEach(section => {
                        section.classList.remove("active");
                    });

                    // Show the selected content section
                    document.getElementById(targetId).classList.add("active");

                    // Set active background on sidebar links
                    sidebarLinks.forEach(link => {
                        link.parentElement.classList.remove("active-bg");
                    });

                    link.parentElement.classList.add("active-bg");
                });
            });

            // Initialize the first section as active
            if (contentSections.length > 0) {
                contentSections[0].classList.add("active");
                sidebarLinks[0].parentElement.classList.add("active-bg");
            }
        });



        document.querySelector('.menu-btn2').addEventListener('click', function () {
            const topicButtons = document.querySelector('.topic-buttons');
            // Toggle the menu visibility by moving it on and off the screen
            if (topicButtons.style.right === '0px') {
                topicButtons.style.right = '-250px'; // Slide out
            } else {
                topicButtons.style.right = '0px'; // Slide in
            }
        });







    </script>

</body>

</html>
