<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <link rel="icon" type="image/png" href="logo.png">
    <title>C Programming Course</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="stylesheet1.css">
    <style>



    </style>
</head>

<body>
    <div class="navbar">

          <!-----for desktop view------------>
        <div class="logo">
            <img src="logo.png" alt="Logo" style="height: 70px; width: auto; margin-left: 20px; ">
        </div>
        

        <!--------------for mobile view---------------->
        <div class="logo1">
            <img src="logo1.png" alt="Logo" style="height: 30px; width: 130px; margin-left: 100px; margin-top: 14px;">
        </div>


        <!-- Menu Button for Mobile View -->
        <button class="menu-btn2" aria-label="Open menu">&#x27A1;</button>

        <!-- Desktop Navbar -->
        <div class="desktop-navbar">
            <button><a href="index.html" style="color: white;">Home</a></button>
            <button><a href="python.html" style="color: white;">Python</a></button>
            <button><a href="cpp.html" style="color: white;">C++</a></button>
            <button><a href="c.html" style="color: white;">C</a></button>
            <button><a href="html.html" style="color: white;">HTML</a></button>
            <button><a href="css.html" style="color: white;">CSS</a></button>
            <button><a href="javascript.html" style="color: white;">JS</a></button>
            <button><a href="java.html" style="color: white;">Java</a></button>
            <button><a href="php.html" style="color: white;">PHP</a></button>
            <button><a href="dsa.html" style="color: white;">DSA</a></button>
        </div>

        <!-- Dropdown Menu for Mobile View -->
        <div class="topic-buttons">
            <a href="index.html"><button>Home</button></a>
            <a href="python.html"><button>Python</button></a>
            <a href="cpp.html"><button>C++</button></a>
            <a href="c.html"><button>C</button></a>
            <a href="html.html"><button>HTML</button></a>
            <a href="css.html"><button>CSS</button></a>
            <a href="javascript.html"><button>JS</button></a>
            <a href="java.html"><button>Java</button></a>
            <a href="php.html"><button>PHP</button></a>
            <a href="dsa.html"><button>DSA</button></a>
        </div>

        
        <!-- Mobile menu button -->
        <div class="menu-btn" id="menuBtn">
            &#9776;
        </div>


    </div>

    <div class="content">
        <!-- Sidebar Navigation -->
        <div class="sidebar" id="sidebar">
            <h2>Introduction</h2>
            <ul>
                <li><a href="#overview">Introduction to C</a></li>
                <li><a href="#history">History of C</a></li>
                <li><a href="#features">Features of C</a></li>
                <li><a href="#installation">Installation and Setup</a></li>
                <li><a href="#hello-world">Hello, World Program</a></li>
            </ul>
    
            <h2>Basic Concepts</h2>
            <ul>
                <li><a href="#syntax">Syntax and Structure</a></li>
                <li><a href="#data-types">Data Types</a></li>
                <li><a href="#variables">Variables and Constants</a></li>
                <li><a href="#input-output">Input and Output</a></li>
                <li><a href="#operators">Operators in C</a></li>
            </ul>
    
            <h2>Control Flow</h2>
            <ul>
                <li><a href="#if-statements">If-Else Statements</a></li>
                <li><a href="#loops">Loops (For, While, Do-While)</a></li>
                <li><a href="#switch">Switch Case</a></li>
                <li><a href="#goto">Goto Statement</a></li>
                <li><a href="#break-continue">Break and Continue</a></li>
            </ul>
    
            <h2>Functions</h2>
            <ul>
                <li><a href="#function-basics">Function Basics</a></li>
                <li><a href="#parameters">Function Parameters</a></li>
                <li><a href="#return-values">Return Values</a></li>
                <li><a href="#recursion">Recursion</a></li>
                <li><a href="#storage-classes">Storage Classes</a></li>
            </ul>
    
            <h2>Arrays and Strings</h2>
            <ul>
                <li><a href="#arrays">Introduction to Arrays</a></li>
                <li><a href="#multi-dimensional-arrays">Multi-Dimensional Arrays</a></li>
                <li><a href="#strings">Strings in C</a></li>
                <li><a href="#string-functions">String Functions</a></li>
            </ul>
    
            <h2>Pointers</h2>
            <ul>
                <li><a href="#pointer-basics">Pointers Basics</a></li>
                <li><a href="#pointer-arithmetic">Pointer Arithmetic</a></li>
                <li><a href="#pointers-and-arrays">Pointers and Arrays</a></li>
                <li><a href="#dynamic-memory">Dynamic Memory Allocation</a></li>
                <li><a href="#function-pointers">Function Pointers</a></li>
            </ul>
    
            <h2>Structures and Unions</h2>
            <ul>
                <li><a href="#structures">Structures</a></li>
                <li><a href="#nested-structures">Nested Structures</a></li>
                <li><a href="#unions">Unions</a></li>
                <li><a href="#typedef">Typedef and Enumerations</a></li>
            </ul>
    
            <h2>File Handling</h2>
            <ul>
                <li><a href="#file-operations">File Operations</a></li>
                <li><a href="#reading-files">Reading from Files</a></li>
                <li><a href="#writing-files">Writing to Files</a></li>
                <li><a href="#error-handling">File Error Handling</a></li>
            </ul>
    
            <h2>Preprocessor</h2>
            <ul>
                <li><a href="#macros">Macros and Constants</a></li>
                <li><a href="#file-inclusion">File Inclusion</a></li>
                <li><a href="#conditional-compilation">Conditional Compilation</a></li>
            </ul>
    
            <h2>Debugging and Optimization</h2>
            <ul>
                <li><a href="#debugging-techniques">Debugging Techniques</a></li>
                <li><a href="#common-errors">Common Errors in C</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
    
            <h2>Advanced Topics</h2>
            <ul>
                <li><a href="#bitwise-operations">Bitwise Operations</a></li>
                <li><a href="#memory-management">Advanced Memory Management</a></li>
                <li><a href="#data-structures">Data Structures<br> (Linked Lists, Stacks, Queues)</a></li>
                <li><a href="#advanced-pointers">Advanced Pointer Concepts</a></li>
                <li><a href="#advanced-pointers">Advanced Pointer Concepts</a></li>
            </ul>
        </div>
    </div>

    
    <div class="main" id="overview">
        <h1>Introduction to C</h1>
    
        <h3>What is C?</h3>
        <p>C is a <strong>procedural</strong>, <strong>general-purpose</strong>, and <strong>compiled programming language</strong>.</p>
        <p>It was developed by <strong>Dennis Ritchie</strong> at Bell Labs in 1972.</p>
        <p>C is widely regarded as one of the most important programming languages, forming the basis for many modern languages like C++, Java, and Python.</p>
    
        <h3>Key Features of C</h3>
        <ul>
            <li>
                <strong>Efficiency:</strong> C provides high performance and is suitable for low-level system programming and embedded systems.
                <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                // Example
                #include <stdio.h>
                
                int main() {
                    printf("Hello, World!");
                    return 0;
                }
                </pre>
            </li>
            <li>
                <strong>Portability:</strong> C programs can run on different platforms with minimal or no modification.
            </li>
            <li>
                <strong>Rich Library:</strong> C offers a variety of built-in functions and libraries to simplify development.
                <pre>
                <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
                // Example
                #include <math.h>
                #include <stdio.h>
                
                int main() {
                    printf("Square root of 16 is %.2f", sqrt(16));
                    return 0;
                }
                </pre>
            </li>
            <li>
                <strong>Low-Level Access:</strong> C provides access to memory through pointers, making it suitable for system-level programming.
            </li>
            <li>
                <strong>Modular Programming:</strong> Functions in C allow developers to write reusable and modular code.
            </li>
        </ul>
    
        <h3>Why Use C?</h3>
        <p>C is versatile and widely used in fields such as:</p>
        <ul>
            <li><strong>System Programming:</strong> Operating systems, kernels, and embedded systems.</li>
            <li><strong>Game Development:</strong> Game engines and graphics programming.</li>
            <li><strong>Embedded Systems:</strong> Microcontrollers and IoT devices.</li>
            <li><strong>Database Development:</strong> Relational database systems like MySQL are written in C.</li>
            <li><strong>Scientific Computing:</strong> Applications requiring high performance and precision.</li>
        </ul>
    </div>

    <!-- Topic: History of C -->
<div class="main" id="history">
    <h1>History of C</h1>

    <h3>Origins of C</h3>
    <p>The C programming language was developed by <strong>Dennis Ritchie</strong> at Bell Labs in 1972. It was created as an improvement over the <strong>BCPL</strong> and <strong>B</strong> programming languages, which were primarily used for system software development.</p>
    <p>C was initially designed to write the <strong>UNIX operating system</strong>, making it a crucial part of modern computing history.</p>

    <h3>Evolution of C</h3>
    <ul>
        <li>
            <strong>1972:</strong> Dennis Ritchie introduced C as an extension of the B programming language. It included data types and other improvements over its predecessor.
        </li>
        <li>
            <strong>1978:</strong> The book <strong>"The C Programming Language"</strong>, authored by Brian Kernighan and Dennis Ritchie, was published. This book, often referred to as <strong>K&R C</strong>, became the de facto standard for C programming.
        </li>
        <li>
            <strong>1989:</strong> The <strong>ANSI C</strong> standard (ANSI X3.159-1989) was established, standardizing the language and making it portable across platforms.
        </li>
        <li>
            <strong>1999:</strong> The <strong>C99</strong> standard introduced new features such as inline functions, improved support for floating-point arithmetic, and variable-length arrays.
        </li>
        <li>
            <strong>2011:</strong> The <strong>C11</strong> standard added features like multi-threading, type-generic macros, and improved Unicode support.
        </li>
    </ul>

    <h3>Influence of C</h3>
    <p>C has significantly influenced many programming languages, including:</p>
    <ul>
        <li><strong>C++:</strong> An extension of C that supports object-oriented programming.</li>
        <li><strong>Java:</strong> Inspired by C's syntax and structure.</li>
        <li><strong>Python:</strong> Although a high-level language, Python's syntax borrows elements from C.</li>
        <li><strong>Rust:</strong> A modern language designed for performance and safety, with roots in C's system-level programming.</li>
    </ul>

    <h3>Legacy of C</h3>
    <p>C remains a foundational language for many applications, including:</p>
    <ul>
        <li><strong>Operating Systems:</strong> Core components of UNIX, Linux, and Windows are written in C.</li>
        <li><strong>Compilers:</strong> Many modern compilers for other languages are built using C.</li>
        <li><strong>Embedded Systems:</strong> C is a go-to language for programming microcontrollers and embedded hardware.</li>
    </ul>
</div>

<!-- Topic: Features of C -->
<div class="main" id="features">
    <h1>Features of C</h1>

    <h3>Key Features of C</h3>
    <ul>
        <li>
            <strong>Simple and Efficient:</strong> C is straightforward, with a small set of keywords and a clean syntax, making it easy to learn and use.
        </li>
        <li>
            <strong>Portability:</strong> Programs written in C can be executed on different machines with little or no modification, ensuring platform independence.
        </li>
        <li>
            <strong>Low-Level Programming Capability:</strong> C supports low-level operations, including direct memory access using pointers, making it ideal for system-level programming.
            <pre>
            <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
            // Example: Using pointers
            #include <stdio.h>
            
            int main() {
                int num = 10;
                int *ptr = &num;
                printf("Value: %d, Address: %p", *ptr, ptr);
                return 0;
            }
            </pre>
        </li>
        <li>
            <strong>Rich Library:</strong> C provides numerous built-in functions and libraries to handle various tasks like I/O operations, string handling, and mathematical computations.
        </li>
        <li>
            <strong>Dynamic Memory Allocation:</strong> C offers functions such as <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code> for managing memory at runtime.
            <pre>
            <button class="copy-code-btn" onclick="copyCode(this)">Copy</button>
            // Example: Dynamic memory allocation
            #include <stdio.h>
            #include <stdlib.h>
            
            int main() {
                int *arr = (int *)malloc(5 * sizeof(int));
                for (int i = 0; i < 5; i++) {
                    arr[i] = i + 1;
                }
                for (int i = 0; i < 5; i++) {
                    printf("%d ", arr[i]);
                }
                free(arr);
                return 0;
            }
            </pre>
        </li>
        <li>
            <strong>Modular Programming:</strong> C encourages modular design by allowing developers to write reusable functions and organize code into multiple files.
        </li>
        <li>
            <strong>Fast and Efficient:</strong> C provides efficient execution by allowing close control over hardware, which is why it's widely used in performance-critical applications.
        </li>
    </ul>

    <h3>Applications of C</h3>
    <p>C is used in various domains, including:</p>
    <ul>
        <li><strong>Operating Systems:</strong> Core components of operating systems like UNIX, Linux, and Windows.</li>
        <li><strong>Embedded Systems:</strong> Programming microcontrollers and embedded devices.</li>
        <li><strong>Compilers:</strong> Developing compilers and interpreters for other programming languages.</li>
        <li><strong>Networking:</strong> Implementing protocols, routers, and network tools.</li>
        <li><strong>Database Systems:</strong> Popular database systems like MySQL and SQLite.</li>
    </ul>
</div>

<div class="main" id="installation">
    <h1>Installation and Setup</h1>
    
    <h3>Installing a C Compiler</h3>
    <p>To start programming in C, you need a C compiler. A compiler translates your C code into machine code that the computer can execute.</p>
    
    <h3>Step 1: Choose a C Compiler</h3>
    <p>There are several compilers available for C programming. Here are some popular options:</p>
    <ul>
        <li><strong>GCC (GNU Compiler Collection):</strong> Available for Linux, macOS, and Windows.</li>
        <li><strong>Clang:</strong> A compiler for macOS and Linux.</li>
        <li><strong>Turbo C:</strong> An older compiler for Windows, often used in academic settings.</li>
        <li><strong>MinGW:</strong> A GCC-based compiler for Windows.</li>
    </ul>
    
    <h3>Step 2: Download and Install the Compiler</h3>
    <p>Here are the installation instructions for popular compilers:</p>
    <ul>
        <li>
            <strong>GCC:</strong> 
            <ul>
                <li>Linux: GCC is usually pre-installed. If not, use the command <code>sudo apt install gcc</code> to install it.</li>
                <li>Windows: Install MinGW from <a href="https://osdn.net/projects/mingw/releases/" target="_blank">MinGW download page</a>.</li>
                <li>macOS: Install using Homebrew with <code>brew install gcc</code>.</li>
            </ul>
        </li>
        <li>
            <strong>Clang:</strong> 
            <ul>
                <li>macOS: Clang is pre-installed with Xcode tools. Install with <code>xcode-select --install</code>.</li>
                <li>Linux: Install via package manager with <code>sudo apt install clang</code>.</li>
            </ul>
        </li>
        <li>
            <strong>Turbo C:</strong> 
            <ul>
                <li>Windows: Download the installer from various third-party sites.</li>
            </ul>
        </li>
    </ul>

    <h3>Step 3: Verify Installation</h3>
    <p>After installation, verify that the compiler is correctly installed by running the following command in your terminal or command prompt:</p>
    <pre>
        gcc --version
    </pre>
    <p>This should display the version of GCC or the installed compiler.</p>

    <h3>Step 4: Set Up an IDE or Text Editor</h3>
    <p>While you can use any text editor to write C code, an Integrated Development Environment (IDE) provides features like code completion and debugging. Some popular IDEs for C programming include:</p>
    <ul>
        <li><strong>Code::Blocks:</strong> Free and open-source, available on Windows, Linux, and macOS.</li>
        <li><strong>Dev C++:</strong> A simple and lightweight IDE for Windows.</li>
        <li><strong>Eclipse:</strong> A versatile IDE that supports C/C++ development.</li>
        <li><strong>Visual Studio:</strong> A powerful IDE for C and C++ development on Windows.</li>
    </ul>
    
    <h3>Step 5: Writing and Running Your First C Program</h3>
    <p>Once you have set up your compiler and IDE, you can start writing your first C program. Here's a simple "Hello, World!" example:</p>
    <pre>
        #include <stdio.h>
        
        int main() {
            printf("Hello, World!");
            return 0;
        }
    </pre>
    <p>Save the file with a .c extension (e.g., <code>hello.c</code>), then compile and run it using the following commands:</p>
    <pre>
        gcc hello.c -o hello
        ./hello
    </pre>
    <p>If everything is set up correctly, you should see the output: <code>Hello, World!</code></p>
</div>

<div class="main" id="hello-world">
    <h1>Hello, World Program</h1>
    
    <h3>What is a "Hello, World" Program?</h3>
    <p>The "Hello, World" program is a simple program that displays the text "Hello, World!" on the screen. It is often used as the first program to write when learning a new programming language.</p>
    
    <h3>Why is it Important?</h3>
    <p>Writing a "Hello, World!" program is a great way to get started with a new programming language. It helps you:</p>
    <ul>
        <li>Understand the basic structure of a program in C.</li>
        <li>Learn how to use the compiler to run your code.</li>
        <li>Test the development environment setup to ensure everything is working.</li>
    </ul>
    
    <h3>Structure of the "Hello, World!" Program in C</h3>
    <p>A simple C program that prints "Hello, World!" consists of the following components:</p>
    <ul>
        <li><strong>Header File:</strong> The <code>#include &lt;stdio.h&gt;</code> line is a preprocessor directive that tells the compiler to include the standard input/output library for functions like <code>printf</code>.</li>
        <li><strong>Main Function:</strong> The <code>int main()</code> function is the entry point of every C program. It marks where the program begins executing.</li>
        <li><strong>printf Function:</strong> The <code>printf</code> function is used to print the output to the screen.</li>
        <li><strong>Return Statement:</strong> The <code>return 0;</code> statement indicates that the program has finished successfully.</li>
    </ul>
    
    <h3>Code Example</h3>
    <p>Here is the code for the "Hello, World!" program in C:</p>
    <pre>
        #include <stdio.h>
        
        int main() {
            printf("Hello, World!");
            return 0;
        }
    </pre>
    
    <h3>How to Compile and Run the Program</h3>
    <p>To compile and run the "Hello, World!" program, follow these steps:</p>
    <ol>
        <li>Save the code in a file named <code>hello.c</code>.</li>
        <li>Open a terminal or command prompt and navigate to the directory where the file is saved.</li>
        <li>Compile the program using the following command:</li>
        <pre>
            gcc hello.c -o hello
        </pre>
        <li>Run the compiled program:</li>
        <pre>
            ./hello
        </pre>
        <li>You should see the output:</li>
        <pre>
            Hello, World!
        </pre>
    </ol>

    <h3>What Happens Behind the Scenes?</h3>
    <p>When you run the program, the compiler processes the code in the following steps:</p>
    <ul>
        <li>The preprocessor includes the <code>stdio.h</code> library to enable input/output operations.</li>
        <li>The <code>main</code> function is executed, which calls the <code>printf</code> function to display "Hello, World!" on the screen.</li>
        <li>The program ends with the <code>return 0;</code> statement, indicating successful execution.</li>
    </ul>

    <h3>Next Steps</h3>
    <p>After successfully running the "Hello, World!" program, try modifying the text inside the <code>printf</code> function to print your own messages. This will help you practice using the <code>printf</code> function and get more familiar with the syntax of C programming.</p>
</div>

<div class="main" id="syntax">
    <!-- Topic: Syntax and Structure -->
    <h1>Syntax and Structure</h1>
    
    <h3>What is Syntax?</h3>
    <p>In C programming, syntax refers to the rules and structure used to write the code. These rules dictate how statements are written, including how functions, variables, operators, and keywords are used.</p>
    
    <h3>Basic Structure of a C Program</h3>
    <p>A simple C program consists of the following key elements:</p>
    <ul>
        <li><strong>Preprocessor Directives:</strong> Lines starting with <code>#</code>, such as <code>#include</code>, which tell the compiler to include external libraries.</li>
        <li><strong>Functions:</strong> A C program must have at least one function, <code>main()</code>, which serves as the entry point of the program.</li>
        <li><strong>Statements:</strong> Instructions that the program executes, such as assignments or function calls.</li>
        <li><strong>Comments:</strong> Text that is ignored by the compiler and is used to explain the code. They can be single-line (<code>//</code>) or multi-line (<code>/* */</code>).</li>
    </ul>
    
    <h3>Syntax Rules</h3>
    <p>C follows a few basic syntax rules that are essential for writing correct programs:</p>
    <ul>
        <li><strong>Case Sensitivity:</strong> C is case-sensitive, meaning <code>Variable</code> and <code>variable</code> are treated as different identifiers.</li>
        <li><strong>Semicolons:</strong> Every statement must end with a semicolon (<code>;</code>).</li>
        <li><strong>Braces:</strong> Blocks of code are enclosed in curly braces (<code>{ }</code>), such as the body of functions and loops.</li>
        <li><strong>Whitespace:</strong> Spaces, tabs, and newlines are used to separate tokens (keywords, identifiers, operators, etc.) but do not affect the program’s execution.</li>
    </ul>
    
    <h3>Basic Example</h3>
    <p>Here is a simple C program that demonstrates the basic syntax:</p>
    <pre>
        #include <stdio.h>
        
        // This is the main function
        int main() {
            // Printing a message to the console
            printf("Hello, C Programming!");
            return 0;
        }
    </pre>
    
    <h3>Explanation of the Example</h3>
    <ul>
        <li><code>#include &lt;stdio.h&gt;</code>: Includes the standard input/output library that contains functions like <code>printf</code>.</li>
        <li><code>int main()</code>: Declares the main function that returns an integer. The program execution starts here.</li>
        <li><code>printf("Hello, C Programming!");</code>: Prints the text "Hello, C Programming!" to the screen.</li>
        <li><code>return 0;</code>: Indicates that the program has executed successfully and returns control to the operating system.</li>
    </ul>

    <h3>Common Syntax Errors</h3>
    <p>Some common syntax errors that beginners may encounter include:</p>
    <ul>
        <li><strong>Missing semicolon:</strong> Forgetting to place a semicolon at the end of a statement.</li>
        <li><strong>Unmatched braces:</strong> Missing or extra curly braces can cause issues with block structure.</li>
        <li><strong>Incorrect spelling of keywords:</strong> Mistyping keywords like <code>int</code> or <code>return</code> will result in errors.</li>
    </ul>

    <h3>Best Practices</h3>
    <p>To avoid syntax errors and improve the readability of your code, consider the following practices:</p>
    <ul>
        <li>Write clear and consistent indentation.</li>
        <li>Use meaningful variable and function names.</li>
        <li>Comment your code to explain complex sections or logic.</li>
        <li>Check for missing semicolons and braces before compiling.</li>
    </ul>
</div>

<div class="main" id="data-types">
    <!-- Topic: Data Types -->
    <h1>Data Types</h1>
    
    <h3>What are Data Types?</h3>
    <p>Data types define the type of data a variable can store. In C, data types specify the size, memory allocation, and how the stored value can be manipulated. Choosing the correct data type is important for efficient memory usage and performance.</p>
    
    <h3>Basic Data Types in C</h3>
    <p>C provides several built-in data types that can be used to define variables:</p>
    <ul>
        <li><strong>int:</strong> Used to store integer values (whole numbers). Example: <code>int num = 10;</code></li>
        <li><strong>float:</strong> Used to store floating-point numbers (decimals). Example: <code>float price = 12.99;</code></li>
        <li><strong>double:</strong> Used to store double precision floating-point numbers. It has more precision than <code>float</code>. Example: <code>double balance = 1000.12345;</code></li>
        <li><strong>char:</strong> Used to store single characters. Example: <code>char grade = 'A';</code></li>
    </ul>
    
    <h3>Modifiers to Data Types</h3>
    <p>In C, data types can be modified to alter their size and range. Some commonly used modifiers are:</p>
    <ul>
        <li><strong>short:</strong> Modifies <code>int</code> to reduce its size.</li>
        <li><strong>long:</strong> Modifies <code>int</code> or <code>double</code> to increase its size.</li>
        <li><strong>signed:</strong> Allows storing both positive and negative values.</li>
        <li><strong>unsigned:</strong> Restricts the variable to store only positive values.</li>
    </ul>
    
    <h3>Data Type Size</h3>
    <p>The size of data types may vary based on the system architecture (32-bit or 64-bit). The following are common sizes:</p>
    <ul>
        <li><strong>int:</strong> Typically 4 bytes.</li>
        <li><strong>float:</strong> Typically 4 bytes.</li>
        <li><strong>double:</strong> Typically 8 bytes.</li>
        <li><strong>char:</strong> Typically 1 byte.</li>
    </ul>
    
    <h3>Example Usage</h3>
    <p>Here’s an example program that demonstrates the usage of different data types:</p>
    <pre>
        #include <stdio.h>
        
        int main() {
            int age = 25;
            float salary = 5000.50;
            double distance = 12345.6789;
            char grade = 'A';
            
            printf("Age: %d\n", age);
            printf("Salary: %.2f\n", salary);
            printf("Distance: %.4lf\n", distance);
            printf("Grade: %c\n", grade);
            
            return 0;
        }
    </pre>
    
    <h3>Explanation of the Example</h3>
    <ul>
        <li><code>int age = 25;</code>: Declares an integer variable <code>age</code> and assigns it the value 25.</li>
        <li><code>float salary = 5000.50;</code>: Declares a floating-point variable <code>salary</code> and assigns it the value 5000.50.</li>
        <li><code>double distance = 12345.6789;</code>: Declares a double precision variable <code>distance</code> and assigns it a value with more precision.</li>
        <li><code>char grade = 'A';</code>: Declares a character variable <code>grade</code> and assigns it the character 'A'.</li>
    </ul>

    <h3>Common Errors Related to Data Types</h3>
    <p>Some common errors related to data types include:</p>
    <ul>
        <li><strong>Type Mismatch:</strong> Assigning a value of one type to a variable of a different type (e.g., assigning a float value to an integer variable).</li>
        <li><strong>Overflow:</strong> Storing a value that exceeds the storage capacity of the data type (e.g., storing a large number in a variable declared as <code>int</code>).</li>
        <li><strong>Precision Loss:</strong> Storing a high-precision value in a <code>float</code> or <code>double</code> that exceeds the data type's capacity.</li>
    </ul>

    <h3>Best Practices</h3>
    <p>To ensure correct usage of data types:</p>
    <ul>
        <li>Always select the appropriate data type based on the size and nature of the value you want to store.</li>
        <li>Use <code>float</code> for decimal numbers with moderate precision and <code>double</code> for high precision.</li>
        <li>Ensure compatibility when assigning values between different data types to avoid unexpected behavior.</li>
    </ul>
</div>

<div class="main" id="variables">
    <!-- Topic: Variables and Constants -->
    <h1>Variables and Constants</h1>
    
    <h3>What are Variables?</h3>
    <p>A variable in C is a storage location identified by a name that holds a value of a specific data type. The value of a variable can be modified during the program's execution.</p>
    
    <h3>Declaring Variables</h3>
    <p>In C, variables must be declared with a specific data type before they are used. The syntax for declaring a variable is:</p>
    <pre><code>data_type variable_name;</code></pre>
    <p>For example, to declare an integer variable named <code>age</code>, you would write:</p>
    <pre><code>int age;</code></pre>
    
    <h3>Initializing Variables</h3>
    <p>Variables can be initialized with a value at the time of declaration:</p>
    <pre><code>int age = 25;</code></pre>
    <p>This declares an integer variable <code>age</code> and initializes it with the value 25.</p>
    
    <h3>What are Constants?</h3>
    <p>Constants are values that cannot be changed once they are assigned. In C, constants can be defined using the <code>const</code> keyword or the <code>#define</code> preprocessor directive.</p>
    
    <h3>Declaring Constants</h3>
    <p>The <code>const</code> keyword is used to declare constants in C:</p>
    <pre><code>const data_type constant_name = value;</code></pre>
    <p>For example, to declare a constant for the value of Pi:</p>
    <pre><code>const float PI = 3.14;</code></pre>
    
    <h3>Using #define for Constants</h3>
    <p>The <code>#define</code> directive can also be used to create constants:</p>
    <pre><code>#define PI 3.14</code></pre>
    <p>This defines a constant <code>PI</code> with the value 3.14. Unlike <code>const</code>, the <code>#define</code> directive does not specify a data type.</p>
    
    <h3>Scope of Variables and Constants</h3>
    <p>The scope refers to where a variable or constant can be accessed within the program. There are two types of scopes:</p>
    <ul>
        <li><strong>Local Scope:</strong> Variables declared inside a function are accessible only within that function.</li>
        <li><strong>Global Scope:</strong> Variables declared outside of any function are accessible throughout the entire program.</li>
    </ul>
    
    <h3>Example Program</h3>
    <p>Here’s a simple program that demonstrates the use of variables and constants:</p>
    <pre>
        #include <stdio.h>

        #define PI 3.14
        
        int main() {
            const int radius = 5;
            float area = PI * radius * radius;
            
            printf("The area of the circle is: %.2f\n", area);
            
            return 0;
        }
    </pre>
    
    <h3>Explanation of the Example</h3>
    <ul>
        <li><code>#define PI 3.14</code>: Defines the constant <code>PI</code> with the value 3.14.</li>
        <li><code>const int radius = 5;</code>: Declares a constant <code>radius</code> with the value 5.</li>
        <li><code>float area = PI * radius * radius;</code>: Calculates the area of a circle using the formula <code>πr²</code> and stores it in the variable <code>area</code>.</li>
        <li><code>printf("The area of the circle is: %.2f\n", area);</code>: Prints the area of the circle to the console.</li>
    </ul>
    
    <h3>Common Errors with Variables and Constants</h3>
    <p>Some common errors related to variables and constants include:</p>
    <ul>
        <li><strong>Uninitialized Variables:</strong> Using a variable without initializing it can result in undefined behavior.</li>
        <li><strong>Modifying Constants:</strong> Attempting to modify a constant value will result in a compilation error.</li>
        <li><strong>Scope Issues:</strong> Trying to access a local variable outside of its scope will result in an error.</li>
    </ul>

    <h3>Best Practices</h3>
    <p>To avoid errors and ensure clarity in your code:</p>
    <ul>
        <li>Always initialize variables before using them.</li>
        <li>Use meaningful names for variables and constants to improve code readability.</li>
        <li>Use <code>const</code> or <code>#define</code> for values that should remain unchanged throughout the program.</li>
        <li>Limit the scope of variables to the smallest necessary region in the program.</li>
    </ul>
</div>

<div class="main" id="input-output">
    <!-- Topic: Input and Output -->
    <h1>Input and Output</h1>
    
    <h3>What is Input and Output in C?</h3>
    <p>Input and output (I/O) operations are essential for interacting with users and external devices in C programming. Input refers to receiving data from the user or external sources, and output refers to displaying data to the user or sending it to external devices.</p>
    
    <h3>Standard Input and Output Functions</h3>
    <p>C provides several built-in functions for input and output operations. The most common functions are:</p>
    <ul>
        <li><strong>printf():</strong> Used to display output on the screen. Example: <code>printf("Hello, World!");</code></li>
        <li><strong>scanf():</strong> Used to read input from the user. Example: <code>scanf("%d", &num);</code></li>
    </ul>
    
    <h3>Using printf() for Output</h3>
    <p>The <code>printf()</code> function is used to print output to the console. It can print different types of data, such as integers, floating-point numbers, characters, and strings. The syntax is:</p>
    <pre><code>printf("format_string", arguments);</code></pre>
    <p>Here is an example of using <code>printf()</code> to display different types of data:</p>
    <pre><code>
        int num = 10;
        float price = 19.99;
        char letter = 'A';
        
        printf("The number is: %d\n", num);
        printf("The price is: %.2f\n", price);
        printf("The letter is: %c\n", letter);
    </code></pre>
    
    <h3>Using scanf() for Input</h3>
    <p>The <code>scanf()</code> function is used to read user input. It takes a format specifier that determines the type of data to be input. The syntax is:</p>
    <pre><code>scanf("format_string", &variable);</code></pre>
    <p>Here is an example of using <code>scanf()</code> to read data from the user:</p>
    <pre><code>
        int num;
        printf("Enter a number: ");
        scanf("%d", &num);
        printf("You entered: %d\n", num);
    </code></pre>
    <p>In this example, the program prompts the user to enter a number and then displays the entered value using <code>printf()</code>.</p>
    
    <h3>Format Specifiers</h3>
    <p>Format specifiers are used in <code>printf()</code> and <code>scanf()</code> to define the type of data. Some common format specifiers are:</p>
    <ul>
        <li><strong>%d:</strong> Integer</li>
        <li><strong>%f:</strong> Float</li>
        <li><strong>%lf:</strong> Double</li>
        <li><strong>%c:</strong> Character</li>
        <li><strong>%s:</strong> String</li>
    </ul>
    <p>For example, to read a string from the user, you would use:</p>
    <pre><code>
        char name[20];
        printf("Enter your name: ");
        scanf("%s", name);
        printf("Hello, %s!\n", name);
    </code></pre>
    
    <h3>Handling Multiple Inputs</h3>
    <p>In C, you can read multiple values using <code>scanf()</code> by specifying multiple format specifiers. For example:</p>
    <pre><code>
        int num1, num2;
        printf("Enter two numbers: ");
        scanf("%d %d", &num1, &num2);
        printf("You entered: %d and %d\n", num1, num2);
    </code></pre>
    
    <h3>Common Errors with Input and Output</h3>
    <p>Some common errors related to input and output operations include:</p>
    <ul>
        <li><strong>Incorrect Format Specifiers:</strong> Using the wrong format specifier for a given data type can lead to unexpected behavior.</li>
        <li><strong>Input Mismatch:</strong> Trying to input a value that does not match the expected data type (e.g., entering a letter when an integer is expected).</li>
        <li><strong>Uninitialized Variables:</strong> Using uninitialized variables with <code>scanf()</code> may result in garbage values.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <p>To ensure smooth input and output operations:</p>
    <ul>
        <li>Always validate user input to ensure it matches the expected format.</li>
        <li>Use proper format specifiers in <code>printf()</code> and <code>scanf()</code>.</li>
        <li>Use <code>fgets()</code> instead of <code>scanf()</code> when reading strings to avoid buffer overflow.</li>
        <li>Check for potential input errors and handle them gracefully in your program.</li>
    </ul>
</div>

<div class="main" id="operators">
    <!-- Topic: Operators in C -->
    <h1>Operators in C</h1>
    
    <h3>What are Operators?</h3>
    <p>Operators in C are symbols used to perform operations on variables and values. C supports a variety of operators to carry out arithmetic, logical, relational, and bitwise operations. Operators can be classified into several categories based on their functionality.</p>
    
    <h3>Types of Operators</h3>
    <p>The following are the main types of operators in C:</p>
    
    <ul>
        <li><strong>Arithmetic Operators:</strong> Used to perform mathematical operations like addition, subtraction, multiplication, etc.</li>
        <li><strong>Relational Operators:</strong> Used to compare two values or variables.</li>
        <li><strong>Logical Operators:</strong> Used to perform logical operations (AND, OR, NOT) between two or more expressions.</li>
        <li><strong>Bitwise Operators:</strong> Used to perform bit-level operations on integer types.</li>
        <li><strong>Assignment Operators:</strong> Used to assign values to variables.</li>
        <li><strong>Increment/Decrement Operators:</strong> Used to increase or decrease a variable's value by 1.</li>
        <li><strong>Conditional (Ternary) Operator:</strong> A shorthand for if-else conditionals.</li>
        <li><strong>Sizeof Operator:</strong> Used to determine the size of a data type or variable in bytes.</li>
    </ul>
    
    <h3>Arithmetic Operators</h3>
    <p>Arithmetic operators are used to perform basic arithmetic operations:</p>
    <ul>
        <li><strong>+</strong> : Addition</li>
        <li><strong>-</strong> : Subtraction</li>
        <li><strong>*</strong> : Multiplication</li>
        <li><strong>/</strong> : Division</li>
        <li><strong>%</strong> : Modulus (remainder)</li>
    </ul>
    <p>Example:</p>
    <pre><code>
        int a = 10, b = 5;
        int sum = a + b;
        printf("Sum: %d\n", sum); // Output: 15
    </code></pre>
    
    <h3>Relational Operators</h3>
    <p>Relational operators are used to compare two values or variables. They return either <code>true</code> (1) or <code>false</code> (0).</p>
    <ul>
        <li><strong>==</strong> : Equal to</li>
        <li><strong>!=</strong> : Not equal to</li>
        <li><strong>&gt;</strong> : Greater than</li>
        <li><strong>&lt;</strong> : Less than</li>
        <li><strong>&gt;=</strong> : Greater than or equal to</li>
        <li><strong>&lt;=</strong> : Less than or equal to</li>
    </ul>
    <p>Example:</p>
    <pre><code>
        int a = 10, b = 5;
        if (a > b) {
            printf("a is greater than b\n"); // Output: a is greater than b
        }
    </code></pre>
    
    <h3>Logical Operators</h3>
    <p>Logical operators are used to perform logical operations between two or more conditions.</p>
    <ul>
        <li><strong>&&</strong> : Logical AND</li>
        <li><strong>||</strong> : Logical OR</li>
        <li><strong>!</strong> : Logical NOT</li>
    </ul>
    <p>Example:</p>
    <pre><code>
        int a = 10, b = 5, c = 3;
        if (a > b && b > c) {
            printf("Both conditions are true\n"); // Output: Both conditions are true
        }
    </code></pre>
    
    <h3>Bitwise Operators</h3>
    <p>Bitwise operators perform operations at the bit level. They are used with integer types.</p>
    <ul>
        <li><strong>&amp;</strong> : Bitwise AND</li>
        <li><strong>|</strong> : Bitwise OR</li>
        <li><strong>^</strong> : Bitwise XOR</li>
        <li><strong>~</strong> : Bitwise NOT</li>
        <li><strong>&lt;&lt;</strong> : Left shift</li>
        <li><strong>&gt;&gt;</strong> : Right shift</li>
    </ul>
    <p>Example:</p>
    <pre><code>
        int a = 5, b = 3;
        int result = a & b;
        printf("Bitwise AND: %d\n", result); // Output: 1
    </code></pre>
    
    <h3>Assignment Operators</h3>
    <p>Assignment operators are used to assign values to variables:</p>
    <ul>
        <li><strong>=</strong> : Simple assignment</li>
        <li><strong>+=</strong> : Add and assign</li>
        <li><strong>-=</strong> : Subtract and assign</li>
        <li><strong>*=</strong> : Multiply and assign</li>
        <li><strong>/=</strong> : Divide and assign</li>
        <li><strong>%=</strong> : Modulus and assign</li>
    </ul>
    <p>Example:</p>
    <pre><code>
        int a = 10;
        a += 5; // a = a + 5
        printf("a: %d\n", a); // Output: 15
    </code></pre>
    
    <h3>Increment and Decrement Operators</h3>
    <p>These operators are used to increase or decrease a variable's value by 1:</p>
    <ul>
        <li><strong>++</strong> : Increment (increase by 1)</li>
        <li><strong>--</strong> : Decrement (decrease by 1)</li>
    </ul>
    <p>Example:</p>
    <pre><code>
        int a = 5;
        a++; // a = a + 1
        printf("a: %d\n", a); // Output: 6
    </code></pre>
    
    <h3>Conditional (Ternary) Operator</h3>
    <p>The conditional operator is a shorthand for if-else statements. The syntax is:</p>
    <pre><code>condition ? expression1 : expression2;</code></pre>
    <p>Example:</p>
    <pre><code>
        int a = 5;
        int result = (a > 3) ? 10 : 20;
        printf("Result: %d\n", result); // Output: 10
    </code></pre>
    
    <h3>Sizeof Operator</h3>
    <p>The <code>sizeof()</code> operator is used to determine the size (in bytes) of a data type or variable.</p>
    <p>Example:</p>
    <pre><code>
        int a = 10;
        printf("Size of a: %zu bytes\n", sizeof(a)); // Output: Size of a: 4 bytes
    </code></pre>
    
    <h3>Best Practices</h3>
    <p>To avoid errors and ensure efficient use of operators:</p>
    <ul>
        <li>Always check for operator precedence to ensure the correct order of operations.</li>
        <li>Use parentheses to make complex expressions more readable and avoid mistakes.</li>
        <li>Use appropriate operators based on the data types involved (e.g., avoid bitwise operators with non-integer types).</li>
    </ul>
</div>

<div class="main" id="if-statements">
    <!-- Topic: If-Else Statements -->
    <h1>If-Else Statements</h1>
    
    <h3>What is an If-Else Statement?</h3>
    <p>An <strong>if-else</strong> statement is a decision-making construct in C programming. It allows the program to choose between two or more actions based on whether a condition is true or false.</p>
    
    <h3>Syntax of If-Else Statement</h3>
    <p>The basic syntax of an if-else statement is:</p>
    <pre><code>
        if (condition) {
            // Block of code if condition is true
        } else {
            // Block of code if condition is false
        }
    </code></pre>
    
    <h3>Example: Basic If-Else</h3>
    <p>In this example, we check if a number is positive or negative:</p>
    <pre><code>
        int num = -5;
        
        if (num > 0) {
            printf("The number is positive.\n");
        } else {
            printf("The number is negative.\n");
        }
    </code></pre>
    <p>Output: <code>The number is negative.</code></p>
    
    <h3>Nested If-Else Statements</h3>
    <p>You can nest if-else statements inside one another to check multiple conditions. This is known as a <strong>nested if-else</strong> statement:</p>
    <pre><code>
        int num = 10;
        
        if (num > 0) {
            printf("The number is positive.\n");
        } else if (num == 0) {
            printf("The number is zero.\n");
        } else {
            printf("The number is negative.\n");
        }
    </code></pre>
    <p>Output: <code>The number is positive.</code></p>
    
    <h3>If-Else Ladder</h3>
    <p>An <strong>if-else ladder</strong> is a type of nested if-else used when you need to evaluate multiple conditions. Each condition is checked in sequence, and the first true condition's corresponding block is executed:</p>
    <pre><code>
        int num = 30;
        
        if (num == 10) {
            printf("The number is 10.\n");
        } else if (num == 20) {
            printf("The number is 20.\n");
        } else if (num == 30) {
            printf("The number is 30.\n");
        } else {
            printf("The number is not 10, 20, or 30.\n");
        }
    </code></pre>
    <p>Output: <code>The number is 30.</code></p>
    
    <h3>Using If-Else with Logical Operators</h3>
    <p>You can combine multiple conditions using logical operators in if-else statements. The common logical operators are:</p>
    <ul>
        <li><strong>&&</strong> : Logical AND</li>
        <li><strong>||</strong> : Logical OR</li>
        <li><strong>!</strong> : Logical NOT</li>
    </ul>
    <p>Example using logical operators:</p>
    <pre><code>
        int num1 = 5, num2 = 10;
        
        if (num1 > 0 && num2 > 0) {
            printf("Both numbers are positive.\n");
        }
    </code></pre>
    <p>Output: <code>Both numbers are positive.</code></p>
    
    <h3>Best Practices</h3>
    <p>To write clear and efficient if-else statements:</p>
    <ul>
        <li>Keep your conditions simple and easy to understand.</li>
        <li>Use curly braces even for single statements to improve readability and avoid errors.</li>
        <li>Be mindful of the order of conditions in an if-else ladder, as the first true condition will stop further evaluation.</li>
        <li>Use logical operators carefully to combine multiple conditions in a single if-else block.</li>
    </ul>
</div>

<div class="main" id="loops">
    <!-- Topic: Loops (For, While, Do-While) -->
    <h1>Loops (For, While, Do-While)</h1>
    
    <h3>What are Loops?</h3>
    <p>Loops are control structures in C that allow code to be executed repeatedly based on a given condition. There are three main types of loops in C: <strong>For Loop</strong>, <strong>While Loop</strong>, and <strong>Do-While Loop</strong>.</p>
    
    <h3>For Loop</h3>
    <p>The <strong>for loop</strong> is used when the number of iterations is known before the loop starts. It is commonly used for iterating over a range of values or a fixed number of iterations.</p>
    
    <h4>Syntax of For Loop</h4>
    <pre><code>
        for (initialization; condition; increment/decrement) {
            // Code to be executed
        }
    </code></pre>
    
    <h4>Example: Printing Numbers from 1 to 5</h4>
    <pre><code>
        for (int i = 1; i <= 5; i++) {
            printf("%d\n", i);
        }
    </code></pre>
    <p>Output: <code>1 2 3 4 5</code></p>
    
    <h3>While Loop</h3>
    <p>The <strong>while loop</strong> is used when the number of iterations is not known in advance and the loop runs as long as a given condition is true.</p>
    
    <h4>Syntax of While Loop</h4>
    <pre><code>
        while (condition) {
            // Code to be executed
        }
    </code></pre>
    
    <h4>Example: Printing Numbers from 1 to 5</h4>
    <pre><code>
        int i = 1;
        while (i <= 5) {
            printf("%d\n", i);
            i++;
        }
    </code></pre>
    <p>Output: <code>1 2 3 4 5</code></p>
    
    <h3>Do-While Loop</h3>
    <p>The <strong>do-while loop</strong> is similar to the while loop, but the condition is checked after the loop body is executed, ensuring that the loop runs at least once.</p>
    
    <h4>Syntax of Do-While Loop</h4>
    <pre><code>
        do {
            // Code to be executed
        } while (condition);
    </code></pre>
    
    <h4>Example: Printing Numbers from 1 to 5</h4>
    <pre><code>
        int i = 1;
        do {
            printf("%d\n", i);
            i++;
        } while (i <= 5);
    </code></pre>
    <p>Output: <code>1 2 3 4 5</code></p>
    
    <h3>Differences Between For, While, and Do-While Loops</h3>
    <table>
        <tr>
            <th>Loop Type</th>
            <th>Condition Check</th>
            <th>When to Use</th>
        </tr>
        <tr>
            <td>For Loop</td>
            <td>Condition is checked before the first iteration</td>
            <td>When the number of iterations is known beforehand</td>
        </tr>
        <tr>
            <td>While Loop</td>
            <td>Condition is checked before each iteration</td>
            <td>When the number of iterations is unknown, but the condition is checked beforehand</td>
        </tr>
        <tr>
            <td>Do-While Loop</td>
            <td>Condition is checked after the loop executes</td>
            <td>When the loop should execute at least once, even if the condition is false initially</td>
        </tr>
    </table>
    
    <h3>Best Practices</h3>
    <p>To use loops effectively:</p>
    <ul>
        <li>Ensure that the loop has a clear exit condition to avoid infinite loops.</li>
        <li>Use a <strong>for loop</strong> when you know the exact number of iterations.</li>
        <li>Use a <strong>while loop</strong> when the number of iterations is not known in advance but depends on a condition.</li>
        <li>Use a <strong>do-while loop</strong> when the loop body must execute at least once, regardless of the condition.</li>
        <li>Be mindful of loop control variables to avoid off-by-one errors.</li>
    </ul>
</div>

<div class="main" id="switch">
    <!-- Topic: Switch Case -->
    <h1>Switch Case</h1>
    
    <h3>What is a Switch Statement?</h3>
    <p>The <strong>switch statement</strong> is used to execute one of many blocks of code based on the value of a given expression. It is often used when there are multiple possible conditions to check, and each condition corresponds to a different action.</p>
    
    <h3>Syntax of Switch Statement</h3>
    <pre><code>
        switch (expression) {
            case value1:
                // Block of code to execute if expression == value1
                break;
            case value2:
                // Block of code to execute if expression == value2
                break;
            default:
                // Block of code to execute if no case matches
        }
    </code></pre>
    
    <h3>Example: Using Switch Case to Check Day of the Week</h3>
    <p>In this example, we check the day number and print the corresponding day of the week:</p>
    <pre><code>
        int day = 3;
        
        switch (day) {
            case 1:
                printf("Monday\n");
                break;
            case 2:
                printf("Tuesday\n");
                break;
            case 3:
                printf("Wednesday\n");
                break;
            case 4:
                printf("Thursday\n");
                break;
            case 5:
                printf("Friday\n");
                break;
            case 6:
                printf("Saturday\n");
                break;
            case 7:
                printf("Sunday\n");
                break;
            default:
                printf("Invalid day\n");
        }
    </code></pre>
    <p>Output: <code>Wednesday</code></p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>The <strong>switch</strong> statement evaluates the expression once and compares its value to each <strong>case</strong>.</li>
        <li>If a match is found, the corresponding block of code is executed.</li>
        <li>If no match is found, the <strong>default</strong> block is executed (if it exists).</li>
        <li>Each <strong>case</strong> block should end with a <strong>break</strong> statement to prevent falling through to the next case.</li>
        <li>If you omit the <strong>break</strong> statement, the program will execute the following cases as well, which can lead to unintended behavior.</li>
    </ul>
    
    <h3>Fall-through Behavior</h3>
    <p>In a <strong>switch statement</strong>, if the <strong>break</strong> statement is omitted, the program will continue executing the next case, even if it doesn't match the expression. This is called <strong>fall-through</strong>.</p>
    <pre><code>
        int num = 2;
        
        switch (num) {
            case 1:
                printf("One\n");
            case 2:
                printf("Two\n");
            case 3:
                printf("Three\n");
            default:
                printf("Invalid\n");
        }
    </code></pre>
    <p>Output: <code>Two Three Invalid</code> (No break, so fall-through happens)</p>
    
    <h3>Best Practices</h3>
    <p>To write efficient and readable switch statements:</p>
    <ul>
        <li>Always use a <strong>break</strong> statement after each case to prevent unintentional fall-through.</li>
        <li>Use the <strong>default</strong> case to handle unexpected values.</li>
        <li>Switch statements are best used when you have multiple conditions based on the same variable or expression.</li>
        <li>Avoid using complex expressions in the case labels; keep them simple for clarity.</li>
    </ul>
</div>

<div class="main" id="goto">
    <!-- Topic: Goto Statement -->
    <h1>Goto Statement</h1>
    
    <h3>What is the Goto Statement?</h3>
    <p>The <strong>goto statement</strong> is used to transfer control to a different part of the program. It provides an unconditional jump to the specified label in the program.</p>
    
    <h3>Syntax of Goto Statement</h3>
    <pre><code>
        goto label;
        
        // Some code...
        
        label:
            // Code to be executed after jump
    </code></pre>
    
    <h3>Example: Using Goto to Skip Code</h3>
    <p>In this example, we use the <strong>goto</strong> statement to skip over the rest of the code inside the loop if a certain condition is met:</p>
    <pre><code>
        int i;
        
        for (i = 1; i <= 5; i++) {
            if (i == 3) {
                goto skip;
            }
            printf("%d\n", i);
        }
        
        skip:
            printf("Jumped over number 3\n");
    </code></pre>
    <p>Output: <code>1 2 Jumped over number 3</code></p>
    
    <h3>Key Points About Goto</h3>
    <ul>
        <li>The <strong>goto</strong> statement causes an unconditional jump to a specified label.</li>
        <li>Labels are defined by using an identifier followed by a colon (e.g., <code>label:</code>).</li>
        <li>Goto can be useful for breaking out of nested loops or skipping certain parts of code, but it should be used with caution.</li>
        <li>Using <strong>goto</strong> excessively can make the program flow difficult to follow and maintain.</li>
    </ul>
    
    <h3>Why Avoid Goto?</h3>
    <p>While <strong>goto</strong> can be useful in some situations, it often leads to confusing and tangled code, which is hard to maintain and debug. It is generally considered a bad practice in structured programming. Modern programming languages encourage the use of loops, functions, and structured control flow statements like <strong>if-else</strong>, <strong>for</strong>, and <strong>while</strong> for more readable and maintainable code.</p>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Avoid using <strong>goto</strong> unless absolutely necessary.</li>
        <li>Use structured control flow statements like <strong>for</strong>, <strong>while</strong>, and <strong>if-else</strong> to make your code more readable and easier to understand.</li>
        <li>If you must use <strong>goto</strong>, ensure that its use is clear and well-documented, and that it doesn't make the code harder to follow.</li>
    </ul>
</div>

<div class="main" id="break-continue">
    <!-- Topic: Break and Continue -->
    <h1>Break and Continue</h1>
    
    <h3>What are Break and Continue?</h3>
    <p>The <strong>break</strong> and <strong>continue</strong> statements are used to control the flow of loops and switch statements in C. These two control statements help in modifying the execution flow in loops based on certain conditions.</p>
    
    <h3>Break Statement</h3>
    <p>The <strong>break</strong> statement is used to exit from a loop or switch case prematurely. When the break statement is encountered, the program immediately exits the loop or switch statement and proceeds with the next statement after the loop or switch.</p>
    
    <h4>Syntax of Break</h4>
    <pre><code>
        break;
    </code></pre>
    
    <h4>Example: Breaking Out of a Loop</h4>
    <p>In this example, we use the <strong>break</strong> statement to exit the loop when the value of <code>i</code> is equal to 3:</p>
    <pre><code>
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                break;
            }
            printf("%d\n", i);
        }
    </code></pre>
    <p>Output: <code>1 2</code></p>
    
    <h3>Continue Statement</h3>
    <p>The <strong>continue</strong> statement is used to skip the remaining code in the current iteration of a loop and proceed to the next iteration. It does not exit the loop, but skips the current iteration and moves to the next cycle.</p>
    
    <h4>Syntax of Continue</h4>
    <pre><code>
        continue;
    </code></pre>
    
    <h4>Example: Skipping an Iteration</h4>
    <p>In this example, the <strong>continue</strong> statement is used to skip printing the value of <code>i</code> when <code>i</code> is equal to 3:</p>
    <pre><code>
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                continue;
            }
            printf("%d\n", i);
        }
    </code></pre>
    <p>Output: <code>1 2 4 5</code></p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>The <strong>break</strong> statement terminates the loop or switch statement and transfers control to the next statement outside the loop.</li>
        <li>The <strong>continue</strong> statement skips the current iteration and proceeds with the next iteration of the loop.</li>
        <li>Both <strong>break</strong> and <strong>continue</strong> can be used in <strong>for</strong>, <strong>while</strong>, and <strong>do-while</strong> loops.</li>
        <li>Using <strong>break</strong> and <strong>continue</strong> can improve control over the flow of execution, but overusing them may make the code harder to understand.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Use the <strong>break</strong> statement when you need to exit a loop early based on a certain condition.</li>
        <li>Use the <strong>continue</strong> statement when you want to skip the remaining code in an iteration without exiting the loop.</li>
        <li>Make sure the use of <strong>break</strong> and <strong>continue</strong> is well-documented and understandable to avoid confusion in your code.</li>
        <li>Limit the use of these statements to make your code more readable and structured.</li>
    </ul>
</div>

<div class="main" id="function-basics">
    <!-- Topic: Function Basics -->
    <h1>Function Basics</h1>
    
    <h3>What is a Function?</h3>
    <p>A <strong>function</strong> is a self-contained block of code that encapsulates a specific task or related group of tasks. It is a way to modularize and organize code in a more efficient and reusable manner. Functions allow you to break down complex problems into simpler, manageable parts.</p>
    
    <h3>Function Declaration</h3>
    <p>The syntax for declaring a function is as follows:</p>
    <pre><code>
        return_type function_name(parameters);
    </code></pre>
    <p>Where:</p>
    <ul>
        <li><strong>return_type</strong> specifies the data type of the value the function returns (e.g., <code>int</code>, <code>void</code> for no return value).</li>
        <li><strong>function_name</strong> is the name of the function (a valid identifier).</li>
        <li><strong>parameters</strong> (optional) are the values passed to the function to be used in the function.</li>
    </ul>
    
    <h3>Function Definition</h3>
    <p>The function definition provides the actual implementation of the function. It contains the body of the function with the code that will be executed when the function is called.</p>
    <pre><code>
        return_type function_name(parameters) {
            // Function body
            // Code to perform the task
        }
    </code></pre>
    
    <h3>Example: Basic Function</h3>
    <p>Here is a simple example of a function that adds two numbers:</p>
    <pre><code>
        #include <stdio.h>
        
        // Function Declaration
        int add(int a, int b);
        
        int main() {
            int result = add(3, 4);
            printf("The sum is: %d\n", result);
            return 0;
        }
        
        // Function Definition
        int add(int a, int b) {
            return a + b;
        }
    </code></pre>
    <p>Output: <code>The sum is: 7</code></p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Functions help in organizing and simplifying code by breaking tasks into smaller, reusable blocks.</li>
        <li>Functions should ideally perform one task, making them easier to understand and maintain.</li>
        <li>Function declarations provide the prototype (signature) of the function, while the definition contains the actual code.</li>
        <li>In C, you can call a function multiple times, making your code modular and reducing redundancy.</li>
    </ul>
    
    <h3>Advantages of Using Functions</h3>
    <ul>
        <li><strong>Modularity:</strong> Code can be divided into smaller, manageable chunks.</li>
        <li><strong>Reusability:</strong> Functions can be called multiple times throughout a program.</li>
        <li><strong>Maintainability:</strong> Changes or fixes can be made in one place, rather than across the entire program.</li>
        <li><strong>Debugging:</strong> Functions help isolate errors, making it easier to identify and fix issues.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Give functions descriptive names that clearly indicate what they do.</li>
        <li>Keep functions small and focused on a single task.</li>
        <li>Use parameters and return values effectively to make your functions flexible and reusable.</li>
        <li>Ensure that function calls are meaningful and avoid excessive nesting of functions.</li>
    </ul>
</div>

<div class="main" id="parameters">
    <!-- Topic: Function Parameters -->
    <h1>Function Parameters</h1>
    
    <h3>What Are Function Parameters?</h3>
    <p><strong>Function parameters</strong> are values passed into a function when it is called. They allow you to pass data into a function so that it can operate on that data. These parameters are used in the function's body to perform specific tasks.</p>
    
    <h3>Syntax of Function Parameters</h3>
    <p>The syntax for function parameters is as follows:</p>
    <pre><code>
        return_type function_name(parameter1, parameter2, ...);
    </code></pre>
    <p>Where <code>parameter1, parameter2, ...</code> are the values you want to pass to the function. The data type of each parameter must be specified in the function declaration and definition.</p>
    
    <h3>Types of Parameters</h3>
    <ul>
        <li><strong>Formal Parameters:</strong> These are the variables defined in the function declaration and definition. They act as placeholders for the values passed to the function.</li>
        <li><strong>Actual Parameters:</strong> These are the values or variables passed to the function when it is called.</li>
    </ul>
    
    <h3>Example: Passing Parameters to a Function</h3>
    <p>In this example, the function <code>multiply</code> accepts two parameters and returns their product:</p>
    <pre><code>
        #include <stdio.h>
        
        // Function Declaration
        int multiply(int a, int b);
        
        int main() {
            int result = multiply(5, 4);  // Actual parameters
            printf("The product is: %d\n", result);
            return 0;
        }
        
        // Function Definition
        int multiply(int a, int b) {  // Formal parameters
            return a * b;
        }
    </code></pre>
    <p>Output: <code>The product is: 20</code></p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li><strong>Formal parameters</strong> are variables defined in the function declaration and definition.</li>
        <li><strong>Actual parameters</strong> are the values passed to the function during the function call.</li>
        <li>The number and type of parameters in the function declaration should match the number and type of arguments passed in the function call.</li>
        <li>Parameters are passed by value by default in C, meaning that the function gets a copy of the argument's value, not the original variable.</li>
    </ul>
    
    <h3>Passing Arguments to Functions</h3>
    <ul>
        <li><strong>Pass by Value:</strong> A copy of the argument is passed to the function. Any changes made to the parameter inside the function do not affect the actual argument.</li>
        <li><strong>Pass by Reference:</strong> This method is not directly supported in C, but can be achieved by passing the address of the variable (using pointers), allowing the function to modify the original argument.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Make sure to define function parameters clearly and use meaningful names to describe their purpose.</li>
        <li>Use parameters effectively to make your functions flexible and reusable in different contexts.</li>
        <li>Ensure that the number and type of arguments passed match the function's definition.</li>
    </ul>
</div>

<div class="main" id="return-values">
    <!-- Topic: Return Values -->
    <h1>Return Values</h1>
    
    <h3>What are Return Values?</h3>
    <p>A <strong>return value</strong> is the value that a function sends back to the caller once it finishes executing. A function can return a value to indicate the result of its operations, which can then be used elsewhere in the program.</p>
    
    <h3>Syntax of Return Statement</h3>
    <p>The syntax for returning a value from a function is as follows:</p>
    <pre><code>
        return value;
    </code></pre>
    <p>Where <code>value</code> is the value to be returned by the function, which must match the declared return type of the function.</p>
    
    <h3>Function with Return Value</h3>
    <p>In this example, the function <code>add</code> returns the sum of two integers:</p>
    <pre><code>
        #include <stdio.h>
        
        // Function Declaration
        int add(int a, int b);
        
        int main() {
            int result = add(5, 3);  // Getting the return value
            printf("The sum is: %d\n", result);
            return 0;
        }
        
        // Function Definition
        int add(int a, int b) {
            return a + b;  // Returning the sum
        }
    </code></pre>
    <p>Output: <code>The sum is: 8</code></p>
    
    <h3>Types of Return Values</h3>
    <ul>
        <li><strong>Value:</strong> A function can return a simple value, such as an integer, float, or character, based on its declared return type.</li>
        <li><strong>Void:</strong> If a function does not need to return any value, it can be declared with the <code>void</code> return type. In this case, the function will not use the <code>return</code> statement, although it can still return control to the calling function.</li>
    </ul>
    
    <h3>Returning Multiple Values</h3>
    <p>In C, a function can only return one value directly. However, you can return multiple values by using pointers or by passing structures to functions. This allows a function to modify several variables at once or return multiple pieces of related data.</p>
    
    <h3>Example: Function with Multiple Return Values</h3>
    <p>Here’s how you can return multiple values using pointers:</p>
    <pre><code>
        #include <stdio.h>
        
        // Function Declaration
        void calculate(int a, int b, int *sum, int *product);
        
        int main() {
            int x = 5, y = 3;
            int sum, product;
            calculate(x, y, &sum, &product);
            printf("Sum: %d, Product: %d\n", sum, product);
            return 0;
        }
        
        // Function Definition
        void calculate(int a, int b, int *sum, int *product) {
            *sum = a + b;
            *product = a * b;
        }
    </code></pre>
    <p>Output: <code>Sum: 8, Product: 15</code></p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>The return type of a function must match the type of the value being returned.</li>
        <li>If a function has no return value, it should be declared as <code>void</code>.</li>
        <li>Functions can return values using the <code>return</code> statement, but the function’s declared return type must be compatible with the value.</li>
        <li>For multiple return values, use pointers or structures to return more than one result.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Always ensure the return type of the function matches the type of the value you intend to return.</li>
        <li>If a function does not need to return any value, use the <code>void</code> return type to make it clear that no result is expected.</li>
        <li>Make sure to properly handle return values in the calling function to avoid unexpected behavior or errors.</li>
    </ul>
</div>

<div class="main" id="recursion">
    <!-- Topic: Recursion -->
    <h1>Recursion</h1>
    
    <h3>What is Recursion?</h3>
    <p><strong>Recursion</strong> is the process in which a function calls itself directly or indirectly to solve a problem. It is typically used when a problem can be broken down into smaller subproblems of the same type.</p>
    
    <h3>How Does Recursion Work?</h3>
    <p>A recursive function works by solving a small portion of the problem and calling itself to solve the remainder. It generally consists of two parts:</p>
    <ul>
        <li><strong>Base Case:</strong> This is the condition that stops the recursion. Without a base case, the function would continue to call itself infinitely.</li>
        <li><strong>Recursive Case:</strong> This is the part of the function where it calls itself with modified parameters to solve smaller subproblems.</li>
    </ul>
    
    <h3>Example: Factorial Function Using Recursion</h3>
    <p>In this example, we calculate the factorial of a number using recursion:</p>
    <pre><code>
        #include <stdio.h>
        
        // Function Declaration
        int factorial(int n);
        
        int main() {
            int num = 5;
            int result = factorial(num);
            printf("Factorial of %d is %d\n", num, result);
            return 0;
        }
        
        // Recursive Function Definition
        int factorial(int n) {
            if (n == 0 || n == 1)  // Base Case
                return 1;
            else
                return n * factorial(n - 1);  // Recursive Case
        }
    </code></pre>
    <p>Output: <code>Factorial of 5 is 120</code></p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Recursion is used when a problem can be divided into smaller subproblems that are similar to the original problem.</li>
        <li>A base case is essential to stop the recursion and prevent infinite calls.</li>
        <li>Each recursive call reduces the problem size, bringing it closer to the base case.</li>
        <li>Recursive functions typically use more memory due to the call stack, so be mindful of stack overflow for large inputs.</li>
    </ul>
    
    <h3>Advantages of Recursion</h3>
    <ul>
        <li>Recursion simplifies the code for problems that can be naturally divided into smaller subproblems (e.g., tree traversal, factorial, Fibonacci sequence).</li>
        <li>It can lead to cleaner, more concise code, especially for problems that involve complex nested structures.</li>
    </ul>
    
    <h3>Disadvantages of Recursion</h3>
    <ul>
        <li>Recursion can use more memory and processing time due to the call stack.</li>
        <li>It may lead to stack overflow errors if the recursion depth is too deep (e.g., with large inputs or infinite recursion).</li>
        <li>For certain problems, iterative solutions may be more efficient in terms of performance.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Ensure that each recursive function has a base case to stop the recursion.</li>
        <li>Be cautious about deep recursion to avoid stack overflow. Consider iterative solutions for large inputs.</li>
        <li>Use recursion when it simplifies the problem, but switch to iteration if it improves performance.</li>
    </ul>
</div>

<div class="main" id="storage-classes">
    <!-- Topic: Storage Classes -->
    <h1>Storage Classes</h1>
    
    <h3>What Are Storage Classes?</h3>
    <p><strong>Storage classes</strong> define the scope, lifetime, and visibility of variables in a C program. They determine how and where variables are stored, and how long they remain in memory during the program's execution.</p>
    
    <h3>Types of Storage Classes</h3>
    <p>C provides four types of storage classes:</p>
    <ul>
        <li><strong>auto:</strong> The default storage class for local variables. These variables are automatically created when a function is called and destroyed when the function exits.</li>
        <li><strong>register:</strong> Used for variables that are frequently accessed. The compiler attempts to store them in CPU registers instead of RAM for faster access.</li>
        <li><strong>static:</strong> Used for variables that retain their values across function calls. These variables are initialized only once and retain their values until the program ends.</li>
        <li><strong>extern:</strong> Used to declare global variables or functions that are defined outside the current file. This allows you to access variables or functions from other files.</li>
    </ul>
    
    <h3>Examples of Storage Classes</h3>
    
    <h4>auto</h4>
    <p>The <code>auto</code> storage class is the default for local variables. It is rarely explicitly used because local variables are auto by default.</p>
    <pre><code>
        #include <stdio.h>
        
        void function() {
            auto int x = 10;  // auto is default
            printf("x = %d\n", x);
        }
        
        int main() {
            function();
            return 0;
        }
    </code></pre>
    
    <h4>register</h4>
    <p>The <code>register</code> storage class is used for variables that are frequently used in operations. It suggests that the variable should be stored in a register for faster access.</p>
    <pre><code>
        #include <stdio.h>
        
        void function() {
            register int i;
            for (i = 0; i < 5; i++) {
                printf("%d ", i);
            }
        }
        
        int main() {
            function();
            return 0;
        }
    </code></pre>
    
    <h4>static</h4>
    <p>The <code>static</code> storage class allows a variable to retain its value between function calls. It initializes the variable only once and keeps its value throughout the program's execution.</p>
    <pre><code>
        #include <stdio.h>
        
        void function() {
            static int count = 0;  // Static variable retains its value
            count++;
            printf("count = %d\n", count);
        }
        
        int main() {
            function();
            function();
            function();
            return 0;
        }
    </code></pre>
    <p>Output: <code>count = 1</code>, <code>count = 2</code>, <code>count = 3</code></p>
    
    <h4>extern</h4>
    <p>The <code>extern</code> storage class is used to declare global variables or functions that are defined in another file. It tells the compiler that the variable or function exists but is defined elsewhere.</p>
    <pre><code>
// file1.c
        #include <stdio.h>
        int x = 10;  // Global variable
        
        void function() {
            printf("x = %d\n", x);
        }

// file2.c
        extern int x;  // Declaration of variable from file1.c
        
        int main() {
            function();
            return 0;
        }
    </code></pre>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>The <code>auto</code> storage class is the default for local variables.</li>
        <li>The <code>register</code> storage class suggests that the variable should be stored in a CPU register for quicker access.</li>
        <li>The <code>static</code> storage class retains the value of a variable between function calls.</li>
        <li>The <code>extern</code> storage class allows variables or functions to be shared across multiple files in a program.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Use the <code>static</code> storage class when you need to retain the value of a variable between function calls.</li>
        <li>Use the <code>register</code> storage class for variables that are used frequently in loops or arithmetic operations to improve performance.</li>
        <li>Use the <code>extern</code> storage class to access global variables or functions across multiple files in a program.</li>
    </ul>
</div>

<div class="main" id="arrays">
    <!-- Topic: Introduction to Arrays -->
    <h1>Introduction to Arrays</h1>
    
    <h3>What is an Array?</h3>
    <p>An <strong>array</strong> in C is a collection of elements of the same data type, stored in contiguous memory locations. Arrays allow you to store multiple values in a single variable, making it easier to manage and manipulate data.</p>
    
    <h3>Array Declaration and Initialization</h3>
    <p>To declare an array in C, you need to specify the data type, array name, and the number of elements. Here's the basic syntax:</p>
    <pre><code>
        data_type array_name[size];
    </code></pre>
    <p>For example, to declare an integer array of size 5:</p>
    <pre><code>
        int arr[5];  // Array with 5 elements
    </code></pre>
    <p>Arrays can also be initialized at the time of declaration:</p>
    <pre><code>
        int arr[5] = {1, 2, 3, 4, 5};
    </code></pre>
    
    <h3>Accessing Array Elements</h3>
    <p>To access or modify an element in the array, you can use the index. Array indices in C start from 0. For example, <code>arr[0]</code> will give the first element of the array.</p>
    <pre><code>
        #include <stdio.h>
        
        int main() {
            int arr[5] = {1, 2, 3, 4, 5};
            printf("First element: %d\n", arr[0]);  // Accessing the first element
            arr[0] = 10;  // Modifying the first element
            printf("Modified first element: %d\n", arr[0]);
            return 0;
        }
    </code></pre>
    <p>Output: <code>First element: 1</code>, <code>Modified first element: 10</code></p>
    
    <h3>Multi-Dimensional Arrays</h3>
    <p>An array with more than one dimension is called a multi-dimensional array. The most common multi-dimensional array is a 2D array (a matrix), but you can also have higher dimensions.</p>
    <p>Syntax for a 2D array:</p>
    <pre><code>
        data_type array_name[rows][columns];
    </code></pre>
    <p>Example of a 2D array:</p>
    <pre><code>
        int arr[3][3] = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
    </code></pre>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Arrays store multiple values of the same data type.</li>
        <li>Array indices start from 0, so the first element is accessed using index 0.</li>
        <li>The size of an array is fixed at the time of declaration and cannot be changed dynamically.</li>
        <li>Multi-dimensional arrays allow you to store data in multiple dimensions (e.g., matrices). The dimensions must be declared when the array is defined.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Ensure you don't exceed the bounds of an array, as accessing out-of-bounds elements can cause memory corruption and undefined behavior.</li>
        <li>Use a constant or variable to define the array size to make your code more maintainable and flexible.</li>
        <li>For large arrays, consider using dynamic memory allocation (using pointers and <code>malloc()</code>) to avoid stack overflow issues.</li>
    </ul>
</div>

<div class="main" id="multi-dimensional-arrays">
    <!-- Topic: Multi-Dimensional Arrays -->
    <h1>Multi-Dimensional Arrays</h1>
    
    <h3>What is a Multi-Dimensional Array?</h3>
    <p>A <strong>multi-dimensional array</strong> is an array of arrays. It is a collection of data elements organized in more than one dimension. The most common multi-dimensional array is a 2D array (a matrix), but you can also have arrays with 3 or more dimensions.</p>
    <p>In C, arrays are static, meaning that the size of the array must be specified when declared. For a multi-dimensional array, you need to define the number of rows and columns (or higher dimensions).</p>
    
    <h3>Declaring Multi-Dimensional Arrays</h3>
    <p>The syntax for declaring a multi-dimensional array is:</p>
    <pre><code>
        data_type array_name[rows][columns];
    </code></pre>
    <p>For example, a 2D array with 3 rows and 3 columns:</p>
    <pre><code>
        int arr[3][3];
    </code></pre>
    
    <h3>Initializing Multi-Dimensional Arrays</h3>
    <p>You can initialize a multi-dimensional array at the time of declaration:</p>
    <pre><code>
        int arr[3][3] = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
    </code></pre>
    <p>Each row of the array is enclosed in curly braces, and the rows are separated by commas.</p>
    
    <h3>Accessing Multi-Dimensional Arrays</h3>
    <p>Accessing elements in a multi-dimensional array is similar to accessing elements in a single-dimensional array, but you need to specify both the row and column indices.</p>
    <pre><code>
        #include <stdio.h>
        
        int main() {
            int arr[3][3] = {
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9}
            };
            
            printf("Element at arr[1][1]: %d\n", arr[1][1]);  // Accessing element at row 1, column 1
            return 0;
        }
    </code></pre>
    <p>Output: <code>Element at arr[1][1]: 5</code></p>
    
    <h3>Multi-Dimensional Arrays with More Than Two Dimensions</h3>
    <p>You can define arrays with more than two dimensions, though it's less common. For example, a 3D array can be declared as:</p>
    <pre><code>
        int arr[3][3][3];  // 3D array with 3 layers, each having 3 rows and 3 columns
    </code></pre>
    <p>Initialization for a 3D array looks like this:</p>
    <pre><code>
        int arr[2][2][2] = {
            {
                {1, 2},
                {3, 4}
            },
            {
                {5, 6},
                {7, 8}
            }
        };
    </code></pre>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Multi-dimensional arrays are essentially arrays of arrays, allowing you to store data in multiple dimensions (e.g., rows and columns for 2D arrays, layers, rows, and columns for 3D arrays).</li>
        <li>Array indices start from 0, and you need to specify both row and column (or multiple dimensions) to access elements in the array.</li>
        <li>For arrays with more than two dimensions, you can use additional square brackets to represent the extra dimensions.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Be mindful of array bounds and ensure that you don’t access elements outside of the array’s dimensions to avoid memory corruption.</li>
        <li>Use constant values or #define for array sizes to make the code more readable and maintainable.</li>
        <li>For large multi-dimensional arrays, consider using dynamic memory allocation to avoid exceeding stack size limits.</li>
    </ul>
</div>

<div class="main" id="strings">
    <!-- Topic: Strings in C -->
    <h1>Strings in C</h1>
    
    <h3>What is a String?</h3>
    <p>A <strong>string</strong> in C is an array of characters terminated by a null character (<code>'\0'</code>). It is used to represent text in a program. Unlike some other programming languages, C does not have a dedicated string data type. Instead, strings are handled using arrays of characters.</p>
    
    <h3>Declaring and Initializing Strings</h3>
    <p>The syntax for declaring and initializing a string is:</p>
    <pre><code>
        char str[size];  // Declaring a string (array of characters)
    </code></pre>
    <p>Alternatively, you can initialize a string at the time of declaration:</p>
    <pre><code>
        char str[] = "Hello, World!";
    </code></pre>
    <p>The compiler automatically determines the size of the string based on the number of characters (including the null terminator).</p>
    
    <h3>Accessing String Elements</h3>
    <p>You can access individual characters in a string using array indexing, just like with any other array:</p>
    <pre><code>
        #include <stdio.h>
        
        int main() {
            char str[] = "Hello, World!";
            printf("First character: %c\n", str[0]);  // Accessing first character of the string
            printf("Fifth character: %c\n", str[4]);  // Accessing fifth character
            return 0;
        }
    </code></pre>
    <p>Output: <code>First character: H</code>, <code>Fifth character: o</code></p>
    
    <h3>String Length</h3>
    <p>The length of a string can be determined using the <code>strlen()</code> function from the <code>string.h</code> library:</p>
    <pre><code>
        #include <stdio.h>
        #include <string.h>  // Include the string.h library
        
        int main() {
            char str[] = "Hello, World!";
            printf("Length of the string: %lu\n", strlen(str));
            return 0;
        }
    </code></pre>
    <p>Output: <code>Length of the string: 13</code></p>
    
    <h3>String Comparison</h3>
    <p>The <code>strcmp()</code> function is used to compare two strings. It returns:</p>
    <ul>
        <li><code>0</code> if the strings are equal,</li>
        <li>a negative value if the first string is less than the second,</li>
        <li>a positive value if the first string is greater than the second.</li>
    </ul>
    <pre><code>
        #include <stdio.h>
        #include <string.h>
        
        int main() {
            char str1[] = "Hello";
            char str2[] = "World";
            int result = strcmp(str1, str2);
            if (result == 0) {
                printf("The strings are equal.\n");
            } else {
                printf("The strings are not equal.\n");
            }
            return 0;
        }
    </code></pre>
    <p>Output: <code>The strings are not equal.</code></p>
    
    <h3>String Functions</h3>
    <p>C provides several functions in the <code>string.h</code> library to manipulate strings:</p>
    <ul>
        <li><code>strcpy()</code>: Copies one string to another.</li>
        <li><code>strcat()</code>: Concatenates two strings.</li>
        <li><code>strchr()</code>: Finds the first occurrence of a character in a string.</li>
        <li><code>strstr()</code>: Finds the first occurrence of a substring in a string.</li>
    </ul>
    
    <h3>Example of String Functions</h3>
    <pre><code>
        #include <stdio.h>
        #include <string.h>
        
        int main() {
            char str1[20] = "Hello";
            char str2[] = " World";
            strcpy(str1, "Hello, C");  // Copy "Hello, C" to str1
            printf("str1: %s\n", str1);
            strcat(str1, str2);  // Concatenate " World" to str1
            printf("str1 after strcat: %s\n", str1);
            return 0;
        }
    </code></pre>
    <p>Output: <code>str1: Hello, C</code>, <code>str1 after strcat: Hello, C World</code></p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Strings in C are arrays of characters with a null character (<code>'\0'</code>) at the end to mark the end of the string.</li>
        <li>You can use array indexing to access individual characters in a string.</li>
        <li>Functions from the <code>string.h</code> library are commonly used to manipulate strings, such as copying, concatenating, comparing, and finding substrings.</li>
        <li>Always remember that strings in C are not automatically resized. Make sure you manage memory correctly when dealing with string buffers.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Always ensure that strings are null-terminated to avoid undefined behavior.</li>
        <li>When manipulating strings, always check the size of the buffer to avoid overflow.</li>
        <li>Use functions like <code>strncpy()</code> and <code>strncat()</code> instead of <code>strcpy()</code> and <code>strcat()</code> to prevent buffer overflow.</li>
    </ul>
</div>

<div class="main" id="string-functions">
    <!-- Topic: String Functions -->
    <h1>String Functions in C</h1>
    
    <h3>Introduction</h3>
    <p>C provides several built-in functions for manipulating strings. These functions are part of the <code>string.h</code> library, which makes string handling more efficient and less error-prone.</p>
    
    <h3>Common String Functions</h3>
    <ul>
        <li><code>strlen()</code> – Returns the length of a string (excluding the null terminator).</li>
        <li><code>strcpy()</code> – Copies one string to another.</li>
        <li><code>strncpy()</code> – Copies a specified number of characters from one string to another.</li>
        <li><code>strcat()</code> – Appends one string to the end of another string.</li>
        <li><code>strncat()</code> – Appends a specified number of characters from one string to another.</li>
        <li><code>strcmp()</code> – Compares two strings lexicographically.</li>
        <li><code>strncmp()</code> – Compares a specified number of characters from two strings lexicographically.</li>
        <li><code>strchr()</code> – Searches for the first occurrence of a character in a string.</li>
        <li><code>strstr()</code> – Searches for the first occurrence of a substring in a string.</li>
        <li><code>strtok()</code> – Tokenizes a string based on delimiters.</li>
    </ul>

    <h3>Using String Functions</h3>
    <h4>Example 1: Using <code>strlen()</code></h4>
    <p>The <code>strlen()</code> function returns the length of the string:</p>
    <pre><code>
        #include <stdio.h>
        #include <string.h>
        
        int main() {
            char str[] = "Hello, C programming!";
            printf("Length of the string: %lu\n", strlen(str));
            return 0;
        }
    </code></pre>
    <p>Output: <code>Length of the string: 22</code></p>
    
    <h4>Example 2: Using <code>strcpy()</code></h4>
    <p>The <code>strcpy()</code> function copies one string into another:</p>
    <pre><code>
        #include <stdio.h>
        #include <string.h>
        
        int main() {
            char source[] = "Hello";
            char destination[20];
            strcpy(destination, source);
            printf("Destination string: %s\n", destination);
            return 0;
        }
    </code></pre>
    <p>Output: <code>Destination string: Hello</code></p>
    
    <h4>Example 3: Using <code>strcat()</code></h4>
    <p>The <code>strcat()</code> function appends one string to another:</p>
    <pre><code>
        #include <stdio.h>
        #include <string.h>
        
        int main() {
            char str1[20] = "Hello, ";
            char str2[] = "World!";
            strcat(str1, str2);
            printf("Concatenated string: %s\n", str1);
            return 0;
        }
    </code></pre>
    <p>Output: <code>Concatenated string: Hello, World!</code></p>
    
    <h4>Example 4: Using <code>strcmp()</code></h4>
    <p>The <code>strcmp()</code> function compares two strings:</p>
    <pre><code>
        #include <stdio.h>
        #include <string.h>
        
        int main() {
            char str1[] = "Hello";
            char str2[] = "World";
            int result = strcmp(str1, str2);
            if (result == 0) {
                printf("The strings are equal.\n");
            } else {
                printf("The strings are not equal.\n");
            }
            return 0;
        }
    </code></pre>
    <p>Output: <code>The strings are not equal.</code></p>
    
    <h3>Using <code>strtok()</code> for Tokenization</h3>
    <p>The <code>strtok()</code> function is used to split a string into tokens based on delimiters. It is often used for parsing data:</p>
    <pre><code>
        #include <stdio.h>
        #include <string.h>
        
        int main() {
            char str[] = "apple,orange,banana";
            char* token = strtok(str, ",");  // Splitting by comma
            while (token != NULL) {
                printf("%s\n", token);
                token = strtok(NULL, ",");
            }
            return 0;
        }
    </code></pre>
    <p>Output:
        <code>apple</code><br>
        <code>orange</code><br>
        <code>banana</code>
    </p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Strings in C are handled as arrays of characters, with a null terminator (<code>'\0'</code>) indicating the end of the string.</li>
        <li>The <code>string.h</code> library provides a wide range of functions for string manipulation, including copying, concatenating, comparing, and searching for substrings.</li>
        <li>Always ensure that you allocate enough memory for strings, especially when using functions like <code>strcpy()</code> and <code>strcat()</code>, to avoid buffer overflow.</li>
        <li>The <code>strtok()</code> function is useful for parsing strings into tokens, which can be processed individually.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Be cautious when using functions like <code>strcpy()</code> and <code>strcat()</code> to avoid buffer overflows. Consider using their safer alternatives like <code>strncpy()</code> and <code>strncat()</code>.</li>
        <li>Always ensure that strings are null-terminated. A missing null terminator can lead to undefined behavior when manipulating or printing the string.</li>
        <li>For parsing user input or tokenizing strings, remember to properly handle delimiters and ensure the input is valid before processing.</li>
    </ul>
</div>

<div class="main" id="pointer-basics">
    <!-- Topic: Pointers Basics -->
    <h1>Pointers in C: Basics</h1>
    
    <h3>What is a Pointer?</h3>
    <p>A <strong>pointer</strong> is a variable that stores the memory address of another variable. Instead of holding a data value directly, a pointer holds the location of where the data is stored in memory.</p>
    <p>Pointers are essential in C for dynamic memory allocation, array handling, and passing large data structures to functions efficiently.</p>
    
    <h3>Pointer Declaration</h3>
    <p>The syntax for declaring a pointer is:</p>
    <pre><code>
        data_type *pointer_name;
    </code></pre>
    <p>Here, <code>data_type</code> is the type of variable the pointer will point to, and <code>*</code> denotes that the variable is a pointer.</p>
    
    <h4>Example: Declaring a Pointer</h4>
    <pre><code>
        int *ptr;  // Declaring a pointer to an integer
    </code></pre>
    
    <h3>Initializing a Pointer</h3>
    <p>A pointer must be initialized with a valid memory address. You can initialize a pointer by using the <code>&</code> (address-of) operator:</p>
    <pre><code>
        int num = 10;
        int *ptr = &num;  // ptr now holds the memory address of num
    </code></pre>
    <p>In the above example, the pointer <code>ptr</code> is initialized to the memory address of the variable <code>num</code>.</p>
    
    <h4>Dereferencing a Pointer</h4>
    <p>Dereferencing a pointer means accessing the value stored at the memory address the pointer is pointing to. This is done using the <code>*</code> operator:</p>
    <pre><code>
        int num = 10;
        int *ptr = &num;
        printf("Value at ptr: %d\n", *ptr);  // Dereferencing to get the value at ptr
    </code></pre>
    <p>Output: <code>Value at ptr: 10</code></p>
    
    <h3>Pointer to Pointer</h3>
    <p>A pointer can also point to another pointer. These are called <strong>pointer to pointer</strong> variables.</p>
    <pre><code>
        int num = 10;
        int *ptr = &num;
        int **ptr2 = &ptr;  // Pointer to pointer
        printf("Value at ptr2: %d\n", **ptr2);  // Dereferencing twice to get the value
    </code></pre>
    <p>Output: <code>Value at ptr2: 10</code></p>
    
    <h3>Null Pointer</h3>
    <p>A null pointer is a pointer that doesn't point to any valid memory location. It is often used to indicate that a pointer is not yet initialized or has been deliberately set to a non-valid state:</p>
    <pre><code>
        int *ptr = NULL;  // Null pointer initialization
    </code></pre>
    <p>It is important to check if a pointer is null before dereferencing it to avoid undefined behavior.</p>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Pointers store memory addresses of other variables.</li>
        <li>The <code>&</code> operator is used to get the address of a variable, and the <code>*</code> operator is used to dereference a pointer and access the value stored at the memory address.</li>
        <li>Pointer variables need to be initialized with a valid memory address to avoid undefined behavior.</li>
        <li>Null pointers are used to represent uninitialized or non-existing memory locations.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Always initialize pointers to a valid address (or NULL) to avoid using uninitialized pointers.</li>
        <li>Check for null pointers before dereferencing them to prevent runtime errors.</li>
        <li>Be cautious with pointer arithmetic and ensure pointers do not go beyond the bounds of the allocated memory.</li>
    </ul>
</div>

<div class="main" id="pointer-arithmetic">
    <!-- Topic: Pointer Arithmetic -->
    <h1>Pointer Arithmetic in C</h1>
    
    <h3>What is Pointer Arithmetic?</h3>
    <p><strong>Pointer arithmetic</strong> refers to performing operations (such as addition, subtraction) on pointers. These operations allow you to navigate through memory addresses that pointers hold. Pointer arithmetic is particularly useful when working with arrays or dynamically allocated memory.</p>
    
    <h3>Pointer Arithmetic Operations</h3>
    <p>You can perform the following arithmetic operations on pointers:</p>
    <ul>
        <li><strong>Incrementing (++)</strong> – Move the pointer to the next memory location of its data type.</li>
        <li><strong>Decrementing (--)</strong> – Move the pointer to the previous memory location.</li>
        <li><strong>Adding an integer (+)</strong> – Move the pointer forward by a specified number of elements in the array.</li>
        <li><strong>Subtracting an integer (-)</strong> – Move the pointer backward by a specified number of elements in the array.</li>
        <li><strong>Subtracting two pointers</strong> – Calculate the difference (number of elements) between two pointers that point to the same array.</li>
    </ul>
    
    <h3>Pointer Increment and Decrement</h3>
    <p>When you increment a pointer, it doesn't just increase by 1. It increases by the size of the data type it is pointing to. Similarly, decrementing a pointer reduces its value by the size of the data type.</p>
    
    <h4>Example: Pointer Increment</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            int arr[] = {10, 20, 30};
            int *ptr = arr;

            printf("Pointer points to: %d\n", *ptr);  // Output: 10
            ptr++;  // Increment pointer
            printf("Pointer points to: %d\n", *ptr);  // Output: 20
            return 0;
        }
    </code></pre>
    
    <h4>Example: Pointer Decrement</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            int arr[] = {10, 20, 30};
            int *ptr = &arr[2];

            printf("Pointer points to: %d\n", *ptr);  // Output: 30
            ptr--;  // Decrement pointer
            printf("Pointer points to: %d\n", *ptr);  // Output: 20
            return 0;
        }
    </code></pre>
    
    <h3>Adding an Integer to a Pointer</h3>
    <p>Adding an integer to a pointer moves the pointer forward by the number of elements specified. The pointer will move by the size of the data type the pointer is pointing to.</p>
    
    <h4>Example: Adding an Integer to a Pointer</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            int arr[] = {10, 20, 30};
            int *ptr = arr;

            ptr = ptr + 2;  // Move pointer 2 elements forward
            printf("Pointer points to: %d\n", *ptr);  // Output: 30
            return 0;
        }
    </code></pre>
    
    <h3>Subtracting Two Pointers</h3>
    <p>If two pointers point to elements within the same array, you can subtract one pointer from another. This operation gives the number of elements between them.</p>
    
    <h4>Example: Subtracting Two Pointers</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            int arr[] = {10, 20, 30};
            int *ptr1 = arr;
            int *ptr2 = &arr[2];

            int difference = ptr2 - ptr1;  // Difference in elements
            printf("Difference between pointers: %d\n", difference);  // Output: 2
            return 0;
        }
    </code></pre>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Pointer arithmetic operates based on the size of the data type the pointer points to.</li>
        <li>Incrementing or decrementing a pointer moves it by the size of the data type, not by 1 byte.</li>
        <li>Adding an integer to a pointer moves the pointer forward by that many elements of the data type.</li>
        <li>Subtracting two pointers returns the number of elements between them, assuming they point to the same array.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>When using pointer arithmetic, ensure that the pointers point to valid memory locations, especially when dealing with dynamically allocated memory or arrays.</li>
        <li>Avoid going beyond the bounds of arrays when performing pointer arithmetic to prevent undefined behavior.</li>
        <li>Pointer arithmetic is commonly used with arrays, but it can be risky if not managed carefully—always perform bounds checking when possible.</li>
    </ul>
</div>

<div class="main" id="pointers-and-arrays">
    <!-- Topic: Pointers and Arrays -->
    <h1>Pointers and Arrays in C</h1>
    
    <h3>What Are Arrays?</h3>
    <p>An <strong>array</strong> is a collection of elements of the same type, stored in contiguous memory locations. Arrays are used to store multiple values in a single variable, instead of declaring individual variables for each value.</p>
    <p>For example, an array of integers can store multiple integer values in a single variable.</p>
    
    <h3>How Pointers Work with Arrays</h3>
    <p>In C, an array name is essentially a pointer to the first element of the array. Therefore, you can use pointers to access array elements, and pointer arithmetic is often used to navigate through array elements.</p>
    <p>The key concept is that the array name itself represents the memory address of the first element. This means that the array can be treated as a pointer in most contexts.</p>
    
    <h4>Example: Using a Pointer to Access Array Elements</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            int arr[] = {10, 20, 30};
            int *ptr = arr;  // Pointer points to the first element of the array

            printf("First element: %d\n", *ptr);  // Output: 10
            printf("Second element: %d\n", *(ptr + 1));  // Output: 20
            printf("Third element: %d\n", *(ptr + 2));  // Output: 30
            return 0;
        }
    </code></pre>
    
    <h3>Accessing Array Elements with Pointer Arithmetic</h3>
    <p>Pointer arithmetic can be used to access array elements by incrementing or decrementing the pointer, or by adding an index to the pointer.</p>
    
    <h4>Example: Accessing Array Elements Using Pointer Arithmetic</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            int arr[] = {10, 20, 30};
            int *ptr = arr;

            // Access array elements using pointer arithmetic
            printf("First element: %d\n", *ptr);  // Output: 10
            printf("Second element: %d\n", *(ptr + 1));  // Output: 20
            printf("Third element: %d\n", *(ptr + 2));  // Output: 30
            return 0;
        }
    </code></pre>
    
    <h3>Pointer to an Array</h3>
    <p>You can also declare a pointer that points to an entire array. This pointer stores the memory address of the entire array, and it can be used to access the array elements.</p>
    
    <h4>Example: Pointer to an Array</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            int arr[] = {10, 20, 30};
            int (*ptr)[3] = &arr;  // Pointer to an entire array of size 3

            printf("First element: %d\n", (*ptr)[0]);  // Output: 10
            printf("Second element: %d\n", (*ptr)[1]);  // Output: 20
            printf("Third element: %d\n", (*ptr)[2]);  // Output: 30
            return 0;
        }
    </code></pre>
    
    <h3>Passing Arrays to Functions Using Pointers</h3>
    <p>In C, arrays are always passed to functions as pointers. This means that when you pass an array to a function, you are actually passing the memory address of the first element of the array. As a result, changes made to the array inside the function will affect the original array.</p>
    
    <h4>Example: Passing an Array to a Function</h4>
    <pre><code>
        #include <stdio.h>

        void printArray(int *arr, int size) {
            for (int i = 0; i < size; i++) {
                printf("%d ", *(arr + i));  // Pointer arithmetic to access elements
            }
            printf("\n");
        }

        int main() {
            int arr[] = {10, 20, 30};
            printArray(arr, 3);  // Passing array to function
            return 0;
        }
    </code></pre>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>The name of an array is a pointer to its first element.</li>
        <li>Pointer arithmetic is used to access array elements by moving the pointer through memory addresses.</li>
        <li>You can declare a pointer to an entire array and access its elements using the pointer.</li>
        <li>When arrays are passed to functions, they are passed as pointers, meaning modifications inside the function will affect the original array.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Always ensure that the pointer you use to access an array points to a valid memory location to avoid undefined behavior.</li>
        <li>Use bounds checking when working with arrays and pointers to prevent accessing memory outside of the array bounds.</li>
        <li>When passing arrays to functions, specify the size of the array to avoid memory errors and ensure the function handles the array correctly.</li>
    </ul>
</div>

<div class="main" id="dynamic-memory">
    <!-- Topic: Dynamic Memory Allocation -->
    <h1>Dynamic Memory Allocation in C</h1>
    
    <h3>What is Dynamic Memory Allocation?</h3>
    <p><strong>Dynamic memory allocation</strong> in C allows you to allocate memory at runtime, rather than at compile time. This gives you flexibility to allocate memory for variables, arrays, or structures as needed during program execution. The memory is allocated on the heap and can be freed when it is no longer required, which helps manage memory efficiently.</p>
    <p>C provides several functions for dynamic memory allocation, including <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code>.</p>
    
    <h3>Dynamic Memory Allocation Functions</h3>
    <p>The following functions are used for dynamic memory allocation:</p>
    <ul>
        <li><strong><code>malloc()</code>:</strong> Allocates a specified number of bytes and returns a pointer to the allocated memory. The memory is not initialized.</li>
        <li><strong><code>calloc()</code>:</strong> Allocates memory for an array of elements and initializes all bytes to zero.</li>
        <li><strong><code>realloc()</code>:</strong> Resizes a previously allocated memory block to a new size.</li>
        <li><strong><code>free()</code>:</strong> Frees dynamically allocated memory, making it available for reuse.</li>
    </ul>
    
    <h3>Using malloc() for Memory Allocation</h3>
    <p>The <code>malloc()</code> function allocates a block of memory of the specified size and returns a pointer to the first byte of the allocated memory. If the memory cannot be allocated, it returns <code>NULL</code>.</p>
    
    <h4>Example: Using malloc() to Allocate Memory</h4>
    <pre><code>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
            int *ptr;
            int size = 5;

            // Allocating memory for an array of 5 integers
            ptr = (int *)malloc(size * sizeof(int));
            if (ptr == NULL) {
                printf("Memory allocation failed.\n");
                return 1;
            }

            // Assigning values to the allocated memory
            for (int i = 0; i < size; i++) {
                ptr[i] = i + 1;
            }

            // Printing the values
            for (int i = 0; i < size; i++) {
                printf("%d ", ptr[i]);
            }
            printf("\n");

            // Freeing the allocated memory
            free(ptr);
            return 0;
        }
    </code></pre>
    
    <h3>Using calloc() for Memory Allocation</h3>
    <p>The <code>calloc()</code> function is similar to <code>malloc()</code>, but it also initializes all the memory to zero. It takes two arguments: the number of elements to be allocated and the size of each element.</p>
    
    <h4>Example: Using calloc() to Allocate Memory</h4>
    <pre><code>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
            int *ptr;
            int size = 5;

            // Allocating memory for 5 integers and initializing them to zero
            ptr = (int *)calloc(size, sizeof(int));
            if (ptr == NULL) {
                printf("Memory allocation failed.\n");
                return 1;
            }

            // Printing the initialized values (should be zero)
            for (int i = 0; i < size; i++) {
                printf("%d ", ptr[i]);
            }
            printf("\n");

            // Freeing the allocated memory
            free(ptr);
            return 0;
        }
    </code></pre>
    
    <h3>Resizing Memory with realloc()</h3>
    <p>The <code>realloc()</code> function is used to resize a previously allocated memory block. It takes a pointer to the original memory block and the new size. If the new size is larger, the new memory is not initialized; if smaller, the excess memory is freed. If the memory cannot be resized, it returns <code>NULL</code>.</p>
    
    <h4>Example: Using realloc() to Resize Memory</h4>
    <pre><code>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
            int *ptr;
            int size = 5;

            // Allocating initial memory
            ptr = (int *)malloc(size * sizeof(int));
            if (ptr == NULL) {
                printf("Memory allocation failed.\n");
                return 1;
            }

            // Assigning values to the allocated memory
            for (int i = 0; i < size; i++) {
                ptr[i] = i + 1;
            }

            // Resizing memory
            size = 8;
            ptr = (int *)realloc(ptr, size * sizeof(int));
            if (ptr == NULL) {
                printf("Memory reallocation failed.\n");
                return 1;
            }

            // Printing the resized array
            for (int i = 0; i < size; i++) {
                printf("%d ", ptr[i]);
            }
            printf("\n");

            // Freeing the allocated memory
            free(ptr);
            return 0;
        }
    </code></pre>
    
    <h3>Freeing Dynamically Allocated Memory</h3>
    <p>Once you are done with dynamically allocated memory, you should always free it using the <code>free()</code> function. This prevents memory leaks and ensures that memory is properly managed by the operating system.</p>
    
    <h4>Example: Using free() to Deallocate Memory</h4>
    <pre><code>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
            int *ptr;
            int size = 5;

            // Allocating memory
            ptr = (int *)malloc(size * sizeof(int));
            if (ptr == NULL) {
                printf("Memory allocation failed.\n");
                return 1;
            }

            // Freeing the allocated memory
            free(ptr);
            return 0;
        }
    </code></pre>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>Always check if memory allocation functions return <code>NULL</code>, indicating that memory allocation failed.</li>
        <li>Use <code>malloc()</code> for uninitialized memory, <code>calloc()</code> for memory initialized to zero, and <code>realloc()</code> for resizing memory blocks.</li>
        <li>Always free dynamically allocated memory using <code>free()</code> to avoid memory leaks.</li>
        <li>After calling <code>free()</code>, the pointer becomes invalid and should not be used again until it is reinitialized.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Always verify the success of memory allocation and reallocation before using the allocated memory.</li>
        <li>Use <code>sizeof</code> when specifying memory size to ensure portability across different data types and systems.</li>
        <li>Ensure that you <strong>free</strong> the memory after use to avoid memory leaks, especially in long-running programs.</li>
    </ul>
</div>

<div class="main" id="function-pointers">
    <!-- Topic: Function Pointers -->
    <h1>Function Pointers in C</h1>
    
    <h3>What Are Function Pointers?</h3>
    <p>A <strong>function pointer</strong> in C is a pointer that points to a function instead of a variable. This allows you to pass functions as arguments to other functions, store functions in data structures, or invoke functions dynamically at runtime.</p>
    
    <h3>Syntax of Function Pointers</h3>
    <p>To declare a function pointer, you need to specify the return type of the function, followed by a pointer to the function's name, and the types of its arguments. The general syntax is:</p>
    <pre><code>
        return_type (*pointer_name)(argument_types);
    </code></pre>
    <p>Here, <code>return_type</code> is the return type of the function, <code>pointer_name</code> is the name of the function pointer, and <code>argument_types</code> are the types of the arguments the function takes.</p>

    <h4>Example: Declaring a Function Pointer</h4>
    <pre><code>
        #include <stdio.h>

        // Function that takes two integers and returns their sum
        int add(int a, int b) {
            return a + b;
        }

        int main() {
            // Declaring a function pointer
            int (*func_ptr)(int, int);
            
            // Assigning the address of the add function to the pointer
            func_ptr = &add;
            
            // Calling the function through the pointer
            int result = func_ptr(5, 3);
            printf("Result: %d\n", result);  // Output: Result: 8
            
            return 0;
        }
    </code></pre>
    
    <h3>Using Function Pointers as Arguments</h3>
    <p>Function pointers can be passed as arguments to other functions. This allows for dynamic function selection, making your code more flexible and extensible.</p>
    
    <h4>Example: Passing Function Pointers as Arguments</h4>
    <pre><code>
        #include <stdio.h>

        // Function that takes a function pointer as an argument
        void execute(int (*func_ptr)(int, int), int a, int b) {
            int result = func_ptr(a, b);
            printf("Result: %d\n", result);
        }

        // Function that adds two integers
        int add(int a, int b) {
            return a + b;
        }

        int main() {
            // Passing the add function as an argument to execute
            execute(add, 5, 3);  // Output: Result: 8
            
            return 0;
        }
    </code></pre>

    <h3>Returning Function Pointers</h3>
    <p>Functions can also return function pointers. This is useful when you need to return different functions dynamically based on certain conditions.</p>
    
    <h4>Example: Returning Function Pointers</h4>
    <pre><code>
        #include <stdio.h>

        // Function that returns a function pointer
        int (*getOperation(char op))(int, int) {
            if (op == '+') {
                return add;
            } else if (op == '-') {
                return subtract;
            } else {
                return NULL;
            }
        }

        // Function that adds two integers
        int add(int a, int b) {
            return a + b;
        }

        // Function that subtracts two integers
        int subtract(int a, int b) {
            return a - b;
        }

        int main() {
            // Get the function pointer for addition
            int (*operation)(int, int) = getOperation('+');
            if (operation) {
                int result = operation(5, 3);
                printf("Result: %d\n", result);  // Output: Result: 8
            }
            
            return 0;
        }
    </code></pre>

    <h3>Function Pointer Array</h3>
    <p>You can also store function pointers in an array, which is useful when you have multiple functions to call based on an index or condition.</p>
    
    <h4>Example: Function Pointer Array</h4>
    <pre><code>
        #include <stdio.h>

        // Functions to add and subtract
        int add(int a, int b) {
            return a + b;
        }

        int subtract(int a, int b) {
            return a - b;
        }

        int main() {
            // Array of function pointers
            int (*func_ptr[2])(int, int) = {add, subtract};
            
            // Calling the functions through the function pointer array
            printf("Addition: %d\n", func_ptr[0](5, 3));   // Output: Addition: 8
            printf("Subtraction: %d\n", func_ptr[1](5, 3));  // Output: Subtraction: 2
            
            return 0;
        }
    </code></pre>
    
    <h3>Key Points to Remember</h3>
    <ul>
        <li>A function pointer is a pointer that points to a function instead of a variable.</li>
        <li>You can pass function pointers as arguments to other functions or return them from functions.</li>
        <li>Function pointers allow dynamic function selection, enabling more flexible and reusable code.</li>
        <li>Function pointers can be stored in arrays for more efficient dynamic function calls.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Ensure that the function pointer is valid before calling it to avoid undefined behavior.</li>
        <li>Use function pointers when you need to implement callback functions or dynamically choose functions at runtime.</li>
        <li>Document function pointer usage clearly, as it can be confusing to beginners and hard to debug if used incorrectly.</li>
    </ul>
</div>

<div class="main" id="structures">
    <!-- Topic: Structures -->
    <h1>Structures in C</h1>
    
    <h3>What is a Structure?</h3>
    <p>A <strong>structure</strong> is a user-defined data type in C that groups different data types (such as int, float, char) together. Structures allow you to represent a collection of related information under a single name, making it easier to handle complex data in a program.</p>
    
    <h3>Declaring a Structure</h3>
    <p>The syntax for declaring a structure is:</p>
    <pre><code>
        struct structure_name {
            data_type member1;
            data_type member2;
            // More members
        };
    </code></pre>
    <p>Here, <code>structure_name</code> is the name of the structure, and the members are the variables that the structure will contain. The members can be of different types.</p>

    <h4>Example: Declaring and Using a Structure</h4>
    <pre><code>
        #include <stdio.h>
        
        // Declare a structure to represent a point in 2D space
        struct Point {
            int x;
            int y;
        };
        
        int main() {
            // Declare a structure variable
            struct Point p1;
            
            // Assign values to the structure members
            p1.x = 5;
            p1.y = 3;
            
            // Access and print the structure members
            printf("Point p1: (%d, %d)\n", p1.x, p1.y);
            
            return 0;
        }
    </code></pre>

    <h3>Accessing Structure Members</h3>
    <p>To access the members of a structure, you use the dot operator (<code>.</code>) along with the structure variable name and member name.</p>

    <h4>Example: Accessing Structure Members</h4>
    <pre><code>
        struct Point p1;
        p1.x = 10;
        p1.y = 20;
        printf("x: %d, y: %d\n", p1.x, p1.y); // Output: x: 10, y: 20
    </code></pre>

    <h3>Initializing a Structure</h3>
    <p>You can initialize a structure at the time of declaration by providing values for the members.</p>
    
    <h4>Example: Initializing a Structure</h4>
    <pre><code>
        struct Point p1 = {10, 20};
        printf("x: %d, y: %d\n", p1.x, p1.y);  // Output: x: 10, y: 20
    </code></pre>

    <h3>Nested Structures</h3>
    <p>A structure can also contain other structures as members. This is known as a nested structure.</p>

    <h4>Example: Nested Structures</h4>
    <pre><code>
        struct Address {
            char street[50];
            char city[50];
            int zipCode;
        };

        struct Person {
            char name[50];
            int age;
            struct Address address; // Nested structure
        };
        
        int main() {
            struct Person p1;
            p1.age = 30;
            strcpy(p1.name, "John Doe");
            strcpy(p1.address.street, "123 Main St");
            strcpy(p1.address.city, "New York");
            p1.address.zipCode = 10001;
            
            // Accessing members of nested structure
            printf("Name: %s, Age: %d\n", p1.name, p1.age);
            printf("Address: %s, %s, %d\n", p1.address.street, p1.address.city, p1.address.zipCode);
            
            return 0;
        }
    </code></pre>

    <h3>Passing Structures to Functions</h3>
    <p>You can pass structures to functions either by value or by reference (using pointers).</p>

    <h4>Example: Passing Structures to Functions</h4>
    <pre><code>
        // Function to print the structure details
        void printPerson(struct Person p) {
            printf("Name: %s, Age: %d\n", p.name, p.age);
            printf("Address: %s, %s, %d\n", p.address.street, p.address.city, p.address.zipCode);
        }

        int main() {
            struct Person p1 = {"John Doe", 30, {"123 Main St", "New York", 10001}};
            printPerson(p1);  // Pass by value
            
            return 0;
        }
    </code></pre>

    <h3>Key Points to Remember</h3>
    <ul>
        <li>Structures allow you to group different data types together under one name.</li>
        <li>You can declare, initialize, and access the members of a structure using the dot operator.</li>
        <li>Structures can be nested, meaning a structure can contain another structure as a member.</li>
        <li>Structures can be passed to functions by value or by reference (using pointers).</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Use structures when you need to group different types of data into a single entity.</li>
        <li>Ensure the structure members are properly named and documented for clarity.</li>
        <li>For larger structures, consider passing them by reference (using pointers) to avoid copying large amounts of data.</li>
    </ul>
</div>

<div class="main" id="unions">
    <!-- Topic: Unions -->
    <h1>Unions in C</h1>
    
    <h3>What is a Union?</h3>
    <p>A <strong>union</strong> is similar to a structure in C, but with a key difference: in a union, all members share the same memory location. This means that a union can hold only one member at a time, and the size of the union is determined by the size of its largest member.</p>
    <p>Unions are useful when you need to store different types of data in the same memory space, but you know that only one type of data will be used at a time.</p>
    
    <h3>Declaring a Union</h3>
    <p>The syntax for declaring a union is similar to declaring a structure, with the keyword <code>union</code> instead of <code>struct</code>:</p>
    <pre><code>
        union union_name {
            data_type member1;
            data_type member2;
            // More members
        };
    </code></pre>
    <p>Here, <code>union_name</code> is the name of the union, and the members can be of different types, but they will share the same memory space.</p>

    <h4>Example: Declaring and Using a Union</h4>
    <pre><code>
        #include <stdio.h>

        // Declare a union to store an integer or a float
        union Data {
            int i;
            float f;
        };

        int main() {
            // Declare a union variable
            union Data data;
            
            // Assign an integer value to the union member
            data.i = 42;
            printf("Data as integer: %d\n", data.i);
            
            // Assign a float value to the union member
            data.f = 3.14;
            printf("Data as float: %.2f\n", data.f);
            
            // Notice that the previous value is overwritten
            printf("Data as integer after float assignment: %d\n", data.i);
            
            return 0;
        }
    </code></pre>
    <p>In this example, when we assign a value to <code>data.f</code>, the previous value of <code>data.i</code> is overwritten, because both members share the same memory.</p>

    <h3>Size of a Union</h3>
    <p>The size of a union is determined by the size of its largest member. It will allocate enough memory to hold the largest member, but no more.</p>

    <h4>Example: Checking the Size of a Union</h4>
    <pre><code>
        #include <stdio.h>

        union Data {
            int i;
            float f;
            char c;
        };

        int main() {
            union Data data;
            printf("Size of union Data: %lu bytes\n", sizeof(data));
            
            return 0;
        }
    </code></pre>
    <p>In this example, the size of the union will be the size of the largest member, which is typically the size of a float (4 bytes on many systems).</p>

    <h3>When to Use Unions</h3>
    <p>Unions are useful when you need to store multiple types of data in the same memory space but only need to use one of them at any given time. This can be helpful in situations like:</p>
    <ul>
        <li>Storing different types of data that won't be used simultaneously, such as an integer or a float in the same memory.</li>
        <li>Reducing memory usage in memory-constrained environments.</li>
        <li>Implementing polymorphic data structures, where the same memory location can hold different data types.</li>
    </ul>

    <h3>Key Points to Remember</h3>
    <ul>
        <li>Unions allow you to store different data types in the same memory space.</li>
        <li>Unlike structures, where each member has its own memory location, a union's members share the same memory.</li>
        <li>The size of the union is the size of its largest member.</li>
        <li>You can only use one member of the union at a time, as writing to one member overwrites the previous value.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Use unions when you want to save memory by using different data types in the same memory space.</li>
        <li>Be careful when accessing members of a union, as modifying one member will overwrite the others.</li>
        <li>Consider using unions for situations that require dynamic data types, like when implementing a variant type in your program.</li>
    </ul>
</div>

<div class="main" id="typedef">
    <!-- Topic: Typedef and Enumerations -->
    <h1>Typedef and Enumerations in C</h1>
    
    <h3>What is Typedef?</h3>
    <p><strong>Typedef</strong> is a keyword in C that allows you to define new names (aliases) for existing data types. This can make the code more readable and easier to maintain, especially when dealing with complex data types like pointers or structures.</p>
    
    <h3>Declaring a Typedef</h3>
    <p>The syntax for using <code>typedef</code> is as follows:</p>
    <pre><code>
        typedef existing_type new_type_name;
    </code></pre>
    <p>Here, <code>existing_type</code> is the data type you want to create an alias for, and <code>new_type_name</code> is the new name you want to assign to that type.</p>

    <h4>Example: Using Typedef</h4>
    <pre><code>
        #include <stdio.h>

        // Define a new name for int using typedef
        typedef int Integer;
        
        int main() {
            Integer num = 10;  // Using the new alias Integer for int
            printf("Value of num: %d\n", num);
            return 0;
        }
    </code></pre>
    <p>In this example, we use <code>typedef</code> to create an alias <code>Integer</code> for the <code>int</code> type. The variable <code>num</code> is declared using the new alias.</p>

    <h3>Using Typedef with Structures</h3>
    <p>Typedef is often used with structures to make the code more concise. Without typedef, we would have to use the <code>struct</code> keyword every time we declare a variable of that structure type. With typedef, we can omit the <code>struct</code> keyword.</p>

    <h4>Example: Typedef with Structures</h4>
    <pre><code>
        #include <stdio.h>

        // Define a structure and create an alias using typedef
        typedef struct {
            int x;
            int y;
        } Point;

        int main() {
            Point p1;  // No need to use the struct keyword
            p1.x = 5;
            p1.y = 10;
            printf("Point p1: (%d, %d)\n", p1.x, p1.y);
            return 0;
        }
    </code></pre>

    <h3>What are Enumerations?</h3>
    <p><strong>Enumerations</strong> (or enums) in C are a user-defined data type that consists of a set of named integer constants. Enums provide a way to assign names to integral values, improving the readability and maintainability of the code.</p>
    
    <h3>Declaring an Enumeration</h3>
    <p>The syntax for declaring an enumeration is as follows:</p>
    <pre><code>
        enum enum_name { 
            constant1, 
            constant2, 
            constant3, 
            // More constants
        };
    </code></pre>
    <p>By default, the first constant in an enum is assigned the value 0, and each subsequent constant is assigned an incremented value (1, 2, etc.). You can also manually assign values to the constants.</p>

    <h4>Example: Using Enumerations</h4>
    <pre><code>
        #include <stdio.h>

        // Define an enumeration for days of the week
        enum Day { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday };

        int main() {
            enum Day today = Wednesday;
            printf("Day %d is Wednesday.\n", today);  // Output: 3 (because Wednesday is the 3rd constant)
            return 0;
        }
    </code></pre>
    
    <h3>Assigning Custom Values to Enumerations</h3>
    <p>You can assign specific integer values to the constants in an enumeration.</p>

    <h4>Example: Custom Values in Enums</h4>
    <pre><code>
        #include <stdio.h>

        // Define an enumeration with custom values
        enum Day { Sunday = 1, Monday = 2, Tuesday = 3, Wednesday = 4, Thursday = 5, Friday = 6, Saturday = 7 };

        int main() {
            enum Day today = Friday;
            printf("Day %d is Friday.\n", today);  // Output: 6
            return 0;
        }
    </code></pre>

    <h3>Enumerations with Typedef</h3>
    <p>You can also use <code>typedef</code> to create an alias for an enum, making it easier to declare variables of the enum type.</p>

    <h4>Example: Typedef with Enums</h4>
    <pre><code>
        #include <stdio.h>

        // Define an enumeration and create an alias using typedef
        typedef enum { Red, Green, Blue } Color;

        int main() {
            Color c = Green;
            printf("Selected color: %d\n", c);  // Output: 1 (because Green is the second constant)
            return 0;
        }
    </code></pre>

    <h3>Key Points to Remember</h3>
    <ul>
        <li>Typedef allows you to define new names for existing types, improving code readability.</li>
        <li>Enums provide a way to assign names to integer constants, making the code more meaningful and easier to understand.</li>
        <li>Both typedef and enums can be used with structures and other data types to improve code organization.</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li>Use typedef to create meaningful aliases for complex data types, like structures and pointers, to simplify the code.</li>
        <li>Use enums to represent a set of related constants, especially when the constants represent discrete choices or options.</li>
        <li>Ensure that enum values are distinct and clearly named for better maintainability.</li>
    </ul>
</div>

<div class="main" id="file-operations">
    <!-- Topic: File Operations -->
    <h1>File Operations in C</h1>

    <h3>What are File Operations?</h3>
    <p><strong>File operations</strong> in C involve interacting with files to read from or write to them. C provides a set of functions in the <code>stdio.h</code> library to handle file operations. These functions allow you to perform various tasks such as opening, reading, writing, and closing files.</p>
    
    <h3>Opening a File</h3>
    <p>To perform any file operation, the first step is to open the file using the <code>fopen()</code> function. This function takes two parameters: the file name and the mode in which you want to open the file.</p>
    <p>The syntax for <code>fopen()</code> is as follows:</p>
    <pre><code>
        FILE *fopen(const char *filename, const char *mode);
    </code></pre>
    <p>Here, <code>filename</code> is the name of the file you want to open, and <code>mode</code> specifies the access mode (read, write, append, etc.).</p>

    <h4>Modes of File Opening</h4>
    <ul>
        <li><code>"r"</code>: Opens the file for reading.</li>
        <li><code>"w"</code>: Opens the file for writing (creates a new file if it doesn't exist, or truncates it if it does).</li>
        <li><code>"a"</code>: Opens the file for appending (creates a new file if it doesn't exist).</li>
        <li><code>"rb"</code>: Opens the file for reading in binary mode.</li>
        <li><code>"wb"</code>: Opens the file for writing in binary mode.</li>
    </ul>

    <h4>Example: Opening a File</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("example.txt", "r");  // Open file in read mode
            if (file == NULL) {
                printf("Error opening the file.\n");
            } else {
                printf("File opened successfully.\n");
                fclose(file);  // Close the file
            }
            return 0;
        }
    </code></pre>
    <p>In this example, we open a file named <code>example.txt</code> in read mode. If the file is opened successfully, we proceed to close it using the <code>fclose()</code> function.</p>

    <h3>Closing a File</h3>
    <p>After performing the desired operations on the file, it is important to close it using the <code>fclose()</code> function. This ensures that any data is saved and the file is properly released.</p>
    <pre><code>
        int fclose(FILE *stream);
    </code></pre>
    <p>Here, <code>stream</code> is the file pointer returned by <code>fopen()</code>. It returns 0 if the file is closed successfully, and EOF if there is an error.</p>

    <h4>Example: Closing a File</h4>
    <pre><code>
        FILE *file = fopen("example.txt", "r");
        if (file != NULL) {
            // Perform file operations
            fclose(file);  // Close the file
        }
    </code></pre>

    <h3>File Operations Summary</h3>
    <ul>
        <li><strong>Opening a file:</strong> Use <code>fopen()</code> with the appropriate mode.</li>
        <li><strong>Closing a file:</strong> Use <code>fclose()</code> when done with the file.</li>
        <li><strong>Reading from a file:</strong> Use <code>fgetc()</code>, <code>fgets()</code>, or <code>fread()</code>.</li>
        <li><strong>Writing to a file:</strong> Use <code>fputc()</code>, <code>fputs()</code>, or <code>fwrite()</code>.</li>
    </ul>

</div>

<div class="main" id="reading-files">
    <!-- Topic: Reading from Files -->
    <h1>Reading from Files in C</h1>

    <h3>Introduction</h3>
    <p>In C, reading from files is done using functions like <code>fgetc()</code>, <code>fgets()</code>, and <code>fread()</code>, which allow you to read characters, lines, or blocks of data from a file. These functions are part of the <code>stdio.h</code> library.</p>

    <h3>Reading a Single Character: <code>fgetc()</code></h3>
    <p>The <code>fgetc()</code> function reads a single character from a file. It returns the character read as an <code>int</code> (or EOF if the end of the file is reached or an error occurs).</p>
    
    <pre><code>
        int fgetc(FILE *stream);
    </code></pre>
    <p>Here, <code>stream</code> is the file pointer returned by <code>fopen()</code>.</p>

    <h4>Example: Reading a Character from a File</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("example.txt", "r");
            if (file != NULL) {
                char ch = fgetc(file);  // Read a single character
                printf("Character read: %c\n", ch);
                fclose(file);
            } else {
                printf("Error opening file.\n");
            }
            return 0;
        }
    </code></pre>
    <p>This code opens the file <code>example.txt</code> and reads a single character using <code>fgetc()</code>.</p>

    <h3>Reading a Line: <code>fgets()</code></h3>
    <p>The <code>fgets()</code> function reads an entire line from a file, including spaces, until it encounters a newline character or the end of the file.</p>
    
    <pre><code>
        char *fgets(char *str, int n, FILE *stream);
    </code></pre>
    <p>Here, <code>str</code> is the buffer where the line is stored, <code>n</code> is the maximum number of characters to read (including the null terminator), and <code>stream</code> is the file pointer.</p>

    <h4>Example: Reading a Line from a File</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("example.txt", "r");
            if (file != NULL) {
                char line[100];
                fgets(line, sizeof(line), file);  // Read a line
                printf("Line read: %s\n", line);
                fclose(file);
            } else {
                printf("Error opening file.\n");
            }
            return 0;
        }
    </code></pre>
    <p>This code opens <code>example.txt</code> and reads a line into the <code>line</code> buffer using <code>fgets()</code>.</p>

    <h3>Reading Multiple Characters: <code>fread()</code></h3>
    <p>The <code>fread()</code> function is used to read multiple characters or blocks of data from a file. It is particularly useful for reading binary data.</p>

    <pre><code>
        size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
    </code></pre>
    <p>Here, <code>ptr</code> is a pointer to the buffer where the data will be stored, <code>size</code> is the size of each element to be read, <code>count</code> is the number of elements to read, and <code>stream</code> is the file pointer.</p>

    <h4>Example: Reading Multiple Characters from a File</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("example.txt", "r");
            if (file != NULL) {
                char buffer[100];
                size_t bytesRead = fread(buffer, sizeof(char), sizeof(buffer), file);  // Read multiple characters
                printf("Bytes read: %zu\n", bytesRead);
                printf("Data read: %s\n", buffer);
                fclose(file);
            } else {
                printf("Error opening file.\n");
            }
            return 0;
        }
    </code></pre>
    <p>This code opens <code>example.txt</code> and reads multiple characters into the <code>buffer</code> using <code>fread()</code>.</p>

    <h3>Key Points</h3>
    <ul>
        <li><code>fgetc()</code> reads a single character from a file.</li>
        <li><code>fgets()</code> reads a line from a file, including spaces.</li>
        <li><code>fread()</code> reads multiple characters or blocks of data from a file.</li>
        <li>All reading functions return <code>EOF</code> on error or the end of the file.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Always check if the file has been successfully opened before reading from it.</li>
        <li>Ensure that the buffer is large enough to hold the data being read.</li>
        <li>Handle end-of-file (EOF) and error conditions appropriately when reading from a file.</li>
    </ul>

</div>

<div class="main" id="writing-files">
    <!-- Topic: Writing to Files -->
    <h1>Writing to Files in C</h1>

    <h3>Introduction</h3>
    <p>In C, writing to files is done using functions like <code>fputc()</code>, <code>fputs()</code>, and <code>fwrite()</code>. These functions allow you to write data to a file in text or binary format.</p>

    <h3>Writing a Single Character: <code>fputc()</code></h3>
    <p>The <code>fputc()</code> function is used to write a single character to a file. It returns the character written as an <code>int</code> (or EOF if an error occurs).</p>
    
    <pre><code>
        int fputc(int char, FILE *stream);
    </code></pre>
    <p>Here, <code>char</code> is the character to be written, and <code>stream</code> is the file pointer returned by <code>fopen()</code>.</p>

    <h4>Example: Writing a Character to a File</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("output.txt", "w");
            if (file != NULL) {
                fputc('A', file);  // Write a character to the file
                fclose(file);
            } else {
                printf("Error opening file.\n");
            }
            return 0;
        }
    </code></pre>
    <p>This code opens <code>output.txt</code> in write mode and writes the character <code>'A'</code> using <code>fputc()</code>.</p>

    <h3>Writing a String: <code>fputs()</code></h3>
    <p>The <code>fputs()</code> function is used to write a string to a file. It does not append a newline character at the end of the string, unlike <code>printf()</code>.</p>
    
    <pre><code>
        int fputs(const char *str, FILE *stream);
    </code></pre>
    <p>Here, <code>str</code> is the string to be written, and <code>stream</code> is the file pointer.</p>

    <h4>Example: Writing a String to a File</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("output.txt", "w");
            if (file != NULL) {
                fputs("Hello, World!", file);  // Write a string to the file
                fclose(file);
            } else {
                printf("Error opening file.\n");
            }
            return 0;
        }
    </code></pre>
    <p>This code opens <code>output.txt</code> in write mode and writes the string "Hello, World!" using <code>fputs()</code>.</p>

    <h3>Writing Multiple Characters: <code>fwrite()</code></h3>
    <p>The <code>fwrite()</code> function is used to write blocks of data to a file. It is especially useful for writing binary data.</p>
    
    <pre><code>
        size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);
    </code></pre>
    <p>Here, <code>ptr</code> is a pointer to the data to be written, <code>size</code> is the size of each element, <code>count</code> is the number of elements to write, and <code>stream</code> is the file pointer.</p>

    <h4>Example: Writing Multiple Characters to a File</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("output.bin", "wb");
            if (file != NULL) {
                char data[] = "Binary data!";
                fwrite(data, sizeof(char), sizeof(data), file);  // Write binary data
                fclose(file);
            } else {
                printf("Error opening file.\n");
            }
            return 0;
        }
    </code></pre>
    <p>This code opens <code>output.bin</code> in binary write mode and writes the binary data "Binary data!" using <code>fwrite()</code>.</p>

    <h3>Key Points</h3>
    <ul>
        <li><code>fputc()</code> writes a single character to a file.</li>
        <li><code>fputs()</code> writes a string to a file.</li>
        <li><code>fwrite()</code> writes multiple characters or blocks of data to a file.</li>
        <li>Always check if the file has been successfully opened before writing to it.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Always check for successful file opening before writing.</li>
        <li>Ensure the file is in the correct mode for writing.</li>
        <li>Handle any potential errors or failures during the write operation.</li>
        <li>Close the file properly after writing to ensure all data is saved.</li>
    </ul>

</div>

<div class="main" id="error-handling">
    <!-- Topic: File Error Handling -->
    <h1>File Error Handling in C</h1>

    <h3>Introduction</h3>
    <p>In C, file operations may encounter errors such as attempting to open a non-existent file or running out of disk space. Proper error handling ensures that your program can gracefully recover from such issues and provide useful feedback to the user.</p>

    <h3>Checking for Errors with <code>fopen()</code></h3>
    <p>When you attempt to open a file using <code>fopen()</code>, it is essential to check if the file was successfully opened. If the file cannot be opened, <code>fopen()</code> returns <code>NULL</code>, indicating an error.</p>
    
    <pre><code>
        FILE *fopen(const char *filename, const char *mode);
    </code></pre>
    <p>If <code>fopen()</code> fails, you should print an error message using <code>perror()</code> or <code>strerror()</code> to get detailed information about the error.</p>

    <h4>Example: Checking for Errors in <code>fopen()</code></h4>
    <pre><code>
        #include <stdio.h>
        #include <errno.h>

        int main() {
            FILE *file = fopen("nonexistent.txt", "r");
            if (file == NULL) {
                perror("Error opening file");  // Print error message
            } else {
                fclose(file);
            }
            return 0;
        }
    </code></pre>
    <p>This code attempts to open a non-existent file and uses <code>perror()</code> to display an error message if the file cannot be opened.</p>

    <h3>Using <code>ferror()</code> to Detect Errors During File Operations</h3>
    <p>The <code>ferror()</code> function checks for errors that may occur during reading or writing operations. If an error occurs, <code>ferror()</code> returns a non-zero value; otherwise, it returns zero.</p>
    
    <pre><code>
        int ferror(FILE *stream);
    </code></pre>
    <p>It is often used after a file operation to verify that no errors occurred during the operation.</p>

    <h4>Example: Using <code>ferror()</code> to Detect Errors</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("example.txt", "w");
            if (file != NULL) {
                fputc('A', file);  // Write a character
                if (ferror(file)) {
                    printf("Error occurred during file write.\n");
                }
                fclose(file);
            } else {
                perror("Error opening file");
            }
            return 0;
        }
    </code></pre>
    <p>This code writes a character to the file and checks for errors using <code>ferror()</code>.</p>

    <h3>Clearing the Error Indicator with <code>clearerr()</code></h3>
    <p>If an error is detected in a file stream, you can use <code>clearerr()</code> to reset the error indicator, allowing subsequent operations to proceed.</p>
    
    <pre><code>
        void clearerr(FILE *stream);
    </code></pre>
    <p>This function clears both the error and EOF indicators associated with the given file stream.</p>

    <h4>Example: Using <code>clearerr()</code> to Reset Error State</h4>
    <pre><code>
        #include <stdio.h>

        int main() {
            FILE *file = fopen("example.txt", "r");
            if (file != NULL) {
                char ch = fgetc(file);  // Read a character
                if (ch == EOF && ferror(file)) {
                    printf("Error occurred, resetting...\n");
                    clearerr(file);  // Reset error state
                }
                fclose(file);
            } else {
                perror("Error opening file");
            }
            return 0;
        }
    </code></pre>
    <p>This code attempts to read from a file, detects an error, and resets the error state using <code>clearerr()</code>.</p>

    <h3>Best Practices for File Error Handling</h3>
    <ul>
        <li>Always check the result of <code>fopen()</code> to ensure the file was successfully opened.</li>
        <li>Use <code>perror()</code> or <code>strerror()</code> to provide detailed error messages for <code>fopen()</code> failures.</li>
        <li>After a file operation, use <code>ferror()</code> to check if any errors occurred during reading or writing.</li>
        <li>If an error occurs, use <code>clearerr()</code> to reset the file error state before continuing operations.</li>
    </ul>

</div>

<div class="main" id="macros">
    <!-- Topic: Macros and Constants -->
    <h1>Macros and Constants in C</h1>

    <h3>Introduction</h3>
    <p>In C, the preprocessor provides functionality to define macros and constants that are substituted in the source code before compilation. These are often used to make the code more readable, maintainable, and efficient.</p>

    <h3>What is a Macro?</h3>
    <p>A macro is a fragment of code which is given a name and can be invoked by name in the program. Macros are defined using the <code>#define</code> preprocessor directive.</p>
    
    <pre><code>
        #define MACRO_NAME replacement_code
    </code></pre>
    <p>When the preprocessor encounters a macro name in the code, it replaces it with the corresponding code defined by the macro.</p>

    <h4>Example: Defining and Using a Macro</h4>
    <pre><code>
        #include <stdio.h>
        
        #define PI 3.14159  // Define a macro for PI

        int main() {
            printf("Value of PI: %.5f\n", PI);  // PI will be replaced by 3.14159
            return 0;
        }
    </code></pre>
    <p>This code defines a macro called <code>PI</code> and uses it in the program to print the value of PI.</p>

    <h3>What is a Constant?</h3>
    <p>Constants are similar to macros but are used to define values that cannot be modified. Constants in C can be defined using the <code>const</code> keyword or the <code>#define</code> preprocessor directive.</p>

    <h4>Example: Defining and Using Constants</h4>
    <pre><code>
        #include <stdio.h>

        #define MAX_SIZE 100  // Define a constant using #define
        const int NUM_DAYS = 7;  // Define a constant using const keyword

        int main() {
            printf("Max size: %d\n", MAX_SIZE);  // MAX_SIZE will be replaced by 100
            printf("Number of days: %d\n", NUM_DAYS);  // NUM_DAYS cannot be changed
            return 0;
        }
    </code></pre>
    <p>This code defines two constants: <code>MAX_SIZE</code> using the <code>#define</code> directive and <code>NUM_DAYS</code> using the <code>const</code> keyword. Constants cannot be changed once defined.</p>

    <h3>Macros with Arguments</h3>
    <p>Macros can also take arguments. These types of macros are known as function-like macros. The syntax for defining such macros is similar to functions, but they are expanded inline during preprocessing.</p>
    
    <pre><code>
        #define SQUARE(x) ((x) * (x))
    </code></pre>
    <p>This macro calculates the square of a number by taking an argument <code>x</code>.</p>

    <h4>Example: Using Macros with Arguments</h4>
    <pre><code>
        #include <stdio.h>

        #define SQUARE(x) ((x) * (x))

        int main() {
            int number = 5;
            printf("Square of %d is: %d\n", number, SQUARE(number));  // Macro expanded inline
            return 0;
        }
    </code></pre>
    <p>This code defines a function-like macro <code>SQUARE</code> that calculates the square of a number. It is invoked with an argument, and the macro is expanded inline during preprocessing.</p>

    <h3>Common Pitfalls with Macros</h3>
    <ul>
        <li>Macros do not perform type checking, which can lead to unexpected results if used improperly.</li>
        <li>Always enclose macro arguments in parentheses to avoid unintended operator precedence issues.</li>
        <li>Macros can cause issues with debugging because the source code contains the expanded version of the macro, making it harder to trace errors.</li>
    </ul>

    <h3>Best Practices for Using Macros</h3>
    <ul>
        <li>Use macros for constants and simple expressions that are unlikely to change.</li>
        <li>Prefer <code>const</code> variables over macros for type safety and easier debugging.</li>
        <li>Use parentheses around macro arguments to avoid precedence problems.</li>
        <li>When defining function-like macros, ensure the argument expressions are properly enclosed to handle operator precedence.</li>
    </ul>

</div>

<div class="main" id="file-inclusion">
    <!-- Topic: File Inclusion -->
    <h1>File Inclusion in C</h1>

    <h3>Introduction</h3>
    <p>File inclusion allows you to include external files in your C program. This can be helpful to modularize code, reuse functions, and share data across multiple files. C provides the <code>#include</code> directive to include header files and source files in your program.</p>

    <h3>Including Header Files</h3>
    <p>Header files typically contain function declarations, macros, and constants that can be shared across multiple source files. You can include standard library headers or custom headers using <code>#include</code>.</p>

    <h4>Syntax for Including Standard Library Header</h4>
    <pre><code>
        #include <stdio.h>  // Includes the standard input/output library
    </code></pre>
    <p>The angle brackets <code>&lt;&gt;</code> are used for including system or library headers that are located in standard directories.</p>

    <h4>Syntax for Including Custom Header Files</h4>
    <pre><code>
        #include "myheader.h"  // Includes a custom header file
    </code></pre>
    <p>The double quotes <code>" "</code> are used for including user-defined header files that are typically located in the same directory as the source file or a user-specified directory.</p>

    <h3>Why Use File Inclusion?</h3>
    <ul>
        <li><strong>Code Reusability:</strong> Common functionality can be separated into header files and reused across multiple source files.</li>
        <li><strong>Modularity:</strong> Large programs can be split into smaller, more manageable files, which makes them easier to maintain and understand.</li>
        <li><strong>Separation of Interface and Implementation:</strong> Header files define the interface (function prototypes, macros), while source files implement the functionality.</li>
    </ul>

    <h3>Example: Using File Inclusion</h3>
    <p>Suppose you have a custom header file <code>math_operations.h</code> that contains function prototypes, and a corresponding <code>math_operations.c</code> file that implements these functions.</p>

    <h4>Header File: <code>math_operations.h</code></h4>
    <pre><code>
        #ifndef MATH_OPERATIONS_H
        #define MATH_OPERATIONS_H

        int add(int a, int b);
        int subtract(int a, int b);

        #endif
    </code></pre>
    <p>This header file defines function prototypes for <code>add()</code> and <code>subtract()</code>. The <code>#ifndef</code> and <code>#define</code> directives are used to ensure the header file is included only once to prevent redefinition errors.</p>

    <h4>Source File: <code>math_operations.c</code></h4>
    <pre><code>
        #include "math_operations.h"

        int add(int a, int b) {
            return a + b;
        }

        int subtract(int a, int b) {
            return a - b;
        }
    </code></pre>
    <p>This source file implements the functions declared in the header file.</p>

    <h4>Main File: <code>main.c</code></h4>
    <pre><code>
        #include <stdio.h>
        #include "math_operations.h"  // Include custom header file

        int main() {
            int result1 = add(10, 5);
            int result2 = subtract(10, 5);

            printf("Addition: %d\n", result1);
            printf("Subtraction: %d\n", result2);

            return 0;
        }
    </code></pre>
    <p>This main file includes the header file <code>math_operations.h</code> and calls the functions <code>add()</code> and <code>subtract()</code>.</p>

    <h3>Guarding Header Files with <code>#ifndef</code>, <code>#define</code>, and <code>#endif</code></h3>
    <p>To prevent multiple inclusions of the same header file, you should use include guards. These preprocessor directives ensure that the content of the header file is only included once per translation unit (source file).</p>

    <pre><code>
        #ifndef HEADER_FILE_NAME_H
        #define HEADER_FILE_NAME_H

        // Header file content

        #endif
    </code></pre>
    <p>This ensures that the content of the header file is included only once in a given source file.</p>

    <h3>Best Practices for File Inclusion</h3>
    <ul>
        <li>Always use include guards to prevent multiple inclusions of the same header file.</li>
        <li>Use <code>#include</code> to include header files, not source files, as source files should be compiled separately.</li>
        <li>Keep your header files minimal, including only necessary declarations and function prototypes.</li>
        <li>Organize header files and source files based on functionality for better code management.</li>
    </ul>

</div>

<div class="main" id="conditional-compilation">
    <!-- Topic: Conditional Compilation -->
    <h1>Conditional Compilation in C</h1>

    <h3>Introduction</h3>
    <p>Conditional compilation allows you to include or exclude parts of the code during the pre-compilation phase based on certain conditions. This is useful when you need to compile different code for different platforms, compilers, or configurations.</p>

    <h3>Preprocessor Directives for Conditional Compilation</h3>
    <p>C provides the following preprocessor directives for conditional compilation:</p>
    <ul>
        <li><code>#if</code>: Begins a conditional block.</li>
        <li><code>#else</code>: Specifies the alternative block if the condition is false.</li>
        <li><code>#elif</code>: Specifies another condition if the first one fails.</li>
        <li><code>#endif</code>: Marks the end of the conditional block.</li>
        <li><code>#ifdef</code>: Checks if a macro is defined.</li>
        <li><code>#ifndef</code>: Checks if a macro is not defined.</li>
    </ul>

    <h3>Syntax for Conditional Compilation</h3>
    <pre><code>
        #if condition
            // Code to compile if condition is true
        #elif another_condition
            // Code to compile if the second condition is true
        #else
            // Code to compile if all conditions fail
        #endif
    </code></pre>

    <h3>Example: Using <code>#if</code> and <code>#else</code></h3>
    <pre><code>
        #include <stdio.h>

        #define DEBUG_MODE 1  // Set this to 1 or 0 to enable or disable debugging code

        int main() {
            #if DEBUG_MODE
                printf("Debugging is enabled.\n");
            #else
                printf("Debugging is disabled.\n");
            #endif
            return 0;
        }
    </code></pre>
    <p>This code demonstrates conditional compilation. The message printed depends on whether <code>DEBUG_MODE</code> is set to 1 or 0. If <code>DEBUG_MODE</code> is defined as 1, the debug message is printed; otherwise, the alternate message is printed.</p>

    <h3>Example: Using <code>#ifdef</code> and <code>#ifndef</code></h3>
    <pre><code>
        #include <stdio.h>

        #define ENABLE_FEATURE 1  // Feature flag

        int main() {
            #ifdef ENABLE_FEATURE
                printf("Feature is enabled.\n");
            #else
                printf("Feature is not enabled.\n");
            #endif

            #ifndef DISABLE_FEATURE
                printf("Feature is not disabled.\n");
            #endif

            return 0;
        }
    </code></pre>
    <p>This code uses <code>#ifdef</code> to check if <code>ENABLE_FEATURE</code> is defined, and <code>#ifndef</code> to check if <code>DISABLE_FEATURE</code> is not defined. The output will depend on whether these macros are defined or not.</p>

    <h3>Conditional Compilation for Multiple Platforms</h3>
    <p>Conditional compilation is particularly useful when writing code that should behave differently on various platforms. For example, you can write platform-specific code like this:</p>
    <pre><code>
        #ifdef _WIN32
            // Windows-specific code
        #elif defined(__linux__)
            // Linux-specific code
        #else
            // Other platform-specific code
        #endif
    </code></pre>
    <p>Here, the code will be compiled based on whether the program is running on a Windows or Linux system, or another platform.</p>

    <h3>Best Practices for Conditional Compilation</h3>
    <ul>
        <li>Use conditional compilation to handle platform-specific code or debugging code but avoid overusing it in production code.</li>
        <li>Ensure that conditional compilation does not lead to code duplication or unnecessary complexity.</li>
        <li>Define meaningful and consistent macro names for conditional compilation.</li>
        <li>Group related preprocessor conditions together for clarity and maintainability.</li>
    </ul>

</div>

<div class="main" id="debugging-techniques">
    <!-- Topic: Debugging Techniques -->
    <h1>Debugging Techniques in C</h1>

    <h3>Introduction</h3>
    <p>Debugging is the process of identifying and fixing errors in your program. C programming can have various types of errors, including syntax errors, runtime errors, and logical errors. Debugging techniques help you systematically find and resolve these issues.</p>

    <h3>Common Debugging Methods</h3>
    <ul>
        <li><strong>Print-based Debugging:</strong> One of the simplest and most common techniques is to add <code>printf</code> statements at various points in your code to check the values of variables, the flow of execution, and the results of expressions.</li>
        <li><strong>Using a Debugger:</strong> A debugger is a powerful tool that allows you to pause your program at specific points, step through your code line by line, and inspect variables. Some popular debuggers are <code>gdb</code> (GNU Debugger) and integrated debugging tools in IDEs like Code::Blocks, Dev-C++, and Visual Studio.</li>
        <li><strong>Code Reviews:</strong> Having someone else review your code can often reveal errors or logical issues that you may have missed. Peer reviews are a great way to ensure code quality.</li>
    </ul>

    <h3>Using a Debugger: Example with gdb</h3>
    <p><code>gdb</code> (GNU Debugger) is a powerful tool for debugging C programs. Below is an example of how to use gdb to debug a C program.</p>
    <h4>Steps to Use gdb</h4>
    <ol>
        <li>Compile your C program with debugging information by using the <code>-g</code> flag:
            <pre><code>gcc -g program.c -o program</code></pre>
        </li>
        <li>Start gdb with your compiled program:
            <pre><code>gdb ./program</code></pre>
        </li>
        <li>Set a breakpoint at a specific line where you want to stop and inspect the program:
            <pre><code>break 10</code></pre>
            This sets a breakpoint at line 10 of your program.</li>
        <li>Run the program inside gdb:
            <pre><code>run</code></pre>
        </li>
        <li>Step through the program line by line using:
            <pre><code>step</code></pre>
        </li>
        <li>Check the values of variables:
            <pre><code>print variable_name</code></pre>
        </li>
        <li>Continue execution after pausing:
            <pre><code>continue</code></pre>
        </li>
        <li>Exit gdb:
            <pre><code>quit</code></pre>
        </li>
    </ol>

    <h3>Other Debugging Tools</h3>
    <ul>
        <li><strong>Valgrind:</strong> A tool to detect memory leaks, memory access errors, and undefined memory usage in C programs. It helps find memory-related issues that might not be apparent during regular debugging.</li>
        <li><strong>Static Analysis Tools:</strong> Tools like <code>cppcheck</code> and <code>Clang Static Analyzer</code> can be used to analyze code for potential bugs and issues without actually running the program.</li>
        <li><strong>Logging:</strong> Instead of using <code>printf</code> statements for debugging, logging frameworks provide a more controlled way to log and track the program's execution and errors.</li>
    </ul>

    <h3>Best Practices for Debugging</h3>
    <ul>
        <li><strong>Understand the Error:</strong> Carefully read error messages, stack traces, and logs to understand the source of the problem. This will help you narrow down where to start your debugging process.</li>
        <li><strong>Isolate the Problem:</strong> Try to reduce your code to the smallest possible snippet that still produces the error. This will make it easier to identify the root cause.</li>
        <li><strong>Check Assumptions:</strong> If you have made assumptions about the behavior of the code or external systems, recheck them. Incorrect assumptions often lead to bugs.</li>
        <li><strong>Use Debugging Tools:</strong> Use debuggers and other debugging tools as mentioned above to step through your program and inspect variable values.</li>
        <li><strong>Stay Calm and Methodical:</strong> Debugging can sometimes be frustrating, but stay calm, and avoid rushing. Break down the problem and tackle it step by step.</li>
    </ul>

    <h3>Example: Debugging a Simple C Program</h3>
    <pre><code>
        #include <stdio.h>

        int add(int a, int b) {
            // Intentional bug: Incorrect addition
            return a - b;  // Bug: should be a + b
        }

        int main() {
            int result = add(5, 3);
            printf("Result: %d\n", result);  // Output will be incorrect
            return 0;
        }
    </code></pre>
    <p>This simple C program has a bug in the <code>add()</code> function. The addition operation is mistakenly written as subtraction. You can use debugging techniques to identify and fix this issue.</p>
</div>

<div class="main" id="common-errors">
    <!-- Topic: Common Errors in C -->
    <h1>Common Errors in C</h1>

    <h3>Introduction</h3>
    <p>When programming in C, errors are inevitable, and understanding common types of errors will help you quickly identify and fix them. Errors in C can be broadly classified into three categories: syntax errors, runtime errors, and logical errors.</p>

    <h3>1. Syntax Errors</h3>
    <p>Syntax errors occur when the program violates the language rules of C. These are usually detected during compilation and prevent the program from being compiled into an executable. Common syntax errors include:</p>
    <ul>
        <li><strong>Missing semicolons:</strong> A missing semicolon at the end of a statement can cause a syntax error.</li>
        <li><strong>Unmatched parentheses or braces:</strong> An opening parenthesis or brace without a closing counterpart will result in an error.</li>
        <li><strong>Typo in keywords:</strong> Misspelling language keywords like <code>int</code>, <code>return</code>, or <code>void</code> will lead to errors.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        int main() {
            printf("Hello, World!")  // Missing semicolon
            return 0;
        }
    </code></pre>
    <p>The missing semicolon at the end of the <code>printf</code> statement will cause a syntax error.</p>

    <h3>2. Runtime Errors</h3>
    <p>Runtime errors occur during the execution of the program. These errors are often caused by issues like invalid memory access, division by zero, or invalid input. Runtime errors usually result in the program crashing or producing incorrect results.</p>
    <ul>
        <li><strong>Division by zero:</strong> Attempting to divide a number by zero causes a runtime error.</li>
        <li><strong>Null pointer dereferencing:</strong> Dereferencing a null pointer leads to unpredictable behavior and crashes.</li>
        <li><strong>Out of bounds array access:</strong> Accessing an element outside the bounds of an array can lead to memory corruption and crashes.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        int main() {
            int a = 10, b = 0;
            int result = a / b;  // Division by zero
            return 0;
        }
    </code></pre>
    <p>Attempting to divide by zero will cause a runtime error and can lead to program termination.</p>

    <h3>3. Logical Errors</h3>
    <p>Logical errors occur when the program runs without crashing but produces incorrect output. These are the hardest errors to identify since the code runs as expected but doesn't produce the correct results. Common logical errors include:</p>
    <ul>
        <li><strong>Incorrect mathematical calculations:</strong> Performing incorrect operations, such as adding when you should multiply, leads to logical errors.</li>
        <li><strong>Wrong order of operations:</strong> Misordering operations can change the result, leading to incorrect output.</li>
        <li><strong>Uninitialized variables:</strong> Using uninitialized variables in calculations can lead to undefined behavior and incorrect results.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        int main() {
            int a = 5, b = 3;
            int result = a - b * 2;  // Logical error, expected result is 1 but gives 1 due to operator precedence
            printf("Result: %d\n", result);
            return 0;
        }
    </code></pre>
    <p>The result is incorrect because of operator precedence. The multiplication should be performed first, but due to the subtraction operator, the result is not what was expected.</p>

    <h3>4. Memory-related Errors</h3>
    <p>Memory management errors are common in C and can lead to undefined behavior, crashes, or data corruption. The most frequent memory-related errors are:</p>
    <ul>
        <li><strong>Memory leaks:</strong> Failing to free dynamically allocated memory leads to memory leaks, causing the program to use more and more memory over time.</li>
        <li><strong>Buffer overflow:</strong> Writing beyond the allocated space for an array can corrupt memory and cause crashes.</li>
        <li><strong>Dangling pointers:</strong> Accessing a pointer after the memory it points to has been freed results in undefined behavior.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        int main() {
            int *ptr = malloc(sizeof(int) * 10);  // Dynamically allocated memory
            free(ptr);  // Memory is freed
            printf("%d\n", *ptr);  // Dangling pointer, accessing freed memory
            return 0;
        }
    </code></pre>
    <p>Accessing a pointer after it has been freed causes undefined behavior. This is a common issue when dealing with dynamic memory allocation.</p>

    <h3>How to Avoid Common Errors</h3>
    <ul>
        <li><strong>Use a debugger:</strong> A debugger like <code>gdb</code> helps identify runtime errors and track the values of variables at runtime.</li>
        <li><strong>Validate inputs:</strong> Always validate user inputs and ensure the program handles unexpected values or edge cases.</li>
        <li><strong>Check bounds:</strong> Ensure you never access an array index outside its bounds. Always check the size of arrays before accessing elements.</li>
        <li><strong>Initialize variables:</strong> Always initialize your variables before use to avoid undefined behavior.</li>
        <li><strong>Check memory allocation:</strong> Always check the result of <code>malloc</code> or <code>calloc</code> to ensure that memory allocation was successful.</li>
    </ul>

</div>

<div class="main" id="best-practices">
    <!-- Topic: Best Practices -->
    <h1>Best Practices</h1>

    <h3>Introduction</h3>
    <p>Best practices are guidelines that developers follow to write clean, efficient, and maintainable code. In C programming, following best practices helps to avoid common mistakes, improve code readability, and enhance performance.</p>

    <h3>1. Code Readability</h3>
    <p>Writing readable code is essential for collaboration and long-term maintenance. A few tips for improving code readability include:</p>
    <ul>
        <li><strong>Use meaningful variable names:</strong> Choose descriptive names for variables, functions, and constants. Avoid single-letter names unless they are universally recognized (e.g., <code>i</code> for loop indices).</li>
        <li><strong>Consistent indentation:</strong> Use consistent indentation and whitespace to make the structure of the code clear. The general practice is to use 4 spaces or a tab for indentation.</li>
        <li><strong>Comment your code:</strong> Add comments to explain complex or non-obvious code. However, avoid over-commenting obvious code. Comments should clarify the intention behind the code.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        // Function to calculate factorial
        int factorial(int n) {
            int result = 1;
            for (int i = 1; i <= n; i++) {
                result *= i;  // Multiply result by i
            }
            return result;
        }
    </code></pre>

    <h3>2. Memory Management</h3>
    <p>Proper memory management is crucial in C programming to avoid memory leaks, segmentation faults, and performance issues. Best practices for memory management include:</p>
    <ul>
        <li><strong>Always free dynamically allocated memory:</strong> After allocating memory using <code>malloc</code>, <code>calloc</code>, or <code>realloc</code>, remember to free the memory using <code>free</code> when it is no longer needed.</li>
        <li><strong>Avoid memory leaks:</strong> Always ensure that every memory allocation is paired with a corresponding <code>free</code> to avoid memory leaks.</li>
        <li><strong>Use <code>NULL</code> pointers:</strong> After freeing memory, set the pointer to <code>NULL</code> to avoid using a dangling pointer.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        int* arr = malloc(sizeof(int) * 100);  // Allocate memory for 100 integers
        if (arr != NULL) {
            // Use arr for some operations
            free(arr);  // Free memory when done
            arr = NULL;  // Avoid dangling pointer
        }
    </code></pre>

    <h3>3. Error Handling</h3>
    <p>Robust error handling is essential for writing reliable and stable programs. Best practices for error handling include:</p>
    <ul>
        <li><strong>Check function return values:</strong> Always check the return values of functions, especially when dealing with file I/O, memory allocation, and system calls. Handle errors appropriately if a function fails.</li>
        <li><strong>Use <code>errno</code> for system calls:</strong> When working with system calls that may fail, check the global variable <code>errno</code> for more information about the error.</li>
        <li><strong>Return meaningful error codes:</strong> When writing functions, consider returning error codes or messages that provide useful information to the caller.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        FILE *file = fopen("data.txt", "r");
        if (file == NULL) {
            perror("Error opening file");  // Print error message
            return 1;  // Exit with error code
        }
        fclose(file);  // Close file when done
    </code></pre>

    <h3>4. Optimize Code for Performance</h3>
    <p>Optimizing code for performance is important, especially when working with resource-constrained environments. Some practices for optimizing performance include:</p>
    <ul>
        <li><strong>Minimize function calls:</strong> Frequent function calls can slow down the program. Use inline functions where possible to avoid the overhead of function calls.</li>
        <li><strong>Use efficient algorithms:</strong> Choose the most efficient algorithms and data structures for your problem. Avoid brute force solutions where more optimized algorithms are available.</li>
        <li><strong>Minimize memory access:</strong> Try to minimize memory accesses and cache misses, as they can slow down the program.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
        inline int square(int x) {
            return x * x;  // Inline function to avoid function call overhead
        }
    </code></pre>

    <h3>5. Modular Code</h3>
    <p>Writing modular and reusable code is a best practice that improves code maintainability. Breaking your program into smaller, self-contained functions or modules makes it easier to test, debug, and extend.</p>
    <ul>
        <li><strong>Write small functions:</strong> Functions should ideally perform a single task. If a function does too much, consider breaking it into smaller functions.</li>
        <li><strong>Use header files:</strong> For larger programs, use header files to declare function prototypes, constants, and data types. This helps in organizing and separating code.</li>
    </ul>
    <h4>Example:</h4>
    <pre><code>
// file1.c
    #include "header.h"
    void print_hello() {
        printf("Hello, World!\n");
    }

// header.h
    #ifndef HEADER_H
    #define HEADER_H
    void print_hello();
    #endif
    </code></pre>

    <h3>6. Code Review and Collaboration</h3>
    <p>Code reviews are a key part of writing high-quality software. Collaborating with other developers ensures that your code is tested, optimized, and aligned with project goals. Best practices for code review and collaboration include:</p>
    <ul>
        <li><strong>Write unit tests:</strong> Always write tests for your code to ensure it works as expected and to catch bugs early.</li>
        <li><strong>Peer reviews:</strong> Encourage team members to review each other's code for potential improvements and error detection.</li>
        <li><strong>Follow coding standards:</strong> Establish coding standards for your team and project to ensure consistency in naming conventions, formatting, and code style.</li>
    </ul>

</div>

<div class="main" id="bitwise-operations">
    <!-- Topic: Bitwise Operations -->
    <h1>Bitwise Operations</h1>

    <h3>Introduction</h3>
    <p>Bitwise operations are operations that directly manipulate bits of data. These operations are often used in low-level programming, such as embedded systems and device drivers, where manipulating individual bits is required for efficiency and performance.</p>

    <h3>Bitwise Operators in C</h3>
    <p>C provides several bitwise operators to perform operations on individual bits of integer data types. These operators are:</p>
    <ul>
        <li><strong>AND (&):</strong> Performs a bitwise AND operation. Both bits must be 1 for the result to be 1.</li>
        <li><strong>OR (|):</strong> Performs a bitwise OR operation. At least one bit must be 1 for the result to be 1.</li>
        <li><strong>XOR (^):</strong> Performs a bitwise XOR operation. The result is 1 if the bits are different.</li>
        <li><strong>NOT (~):</strong> Performs a bitwise NOT operation. It inverts the bits (changes 1 to 0 and vice versa).</li>
        <li><strong>Left Shift (<<):</strong> Shifts bits to the left by a specified number of positions, adding zeros to the right.</li>
        <li><strong>Right Shift (>>):</strong> Shifts bits to the right by a specified number of positions, discarding bits on the right.</li>
    </ul>

    <h3>Bitwise AND (&) Example</h3>
    <p>The bitwise AND operation compares each corresponding bit of two numbers. If both bits are 1, the result is 1. Otherwise, the result is 0.</p>
    <pre><code>
        int a = 5;   // 0101 in binary
        int b = 3;   // 0011 in binary
        int result = a & b; // Result: 0001 (1 in decimal)
        printf("a & b = %d\n", result);
    </code></pre>
    <p>Output: <code>a & b = 1</code></p>

    <h3>Bitwise OR (|) Example</h3>
    <p>The bitwise OR operation compares each corresponding bit of two numbers. If at least one bit is 1, the result is 1. Otherwise, the result is 0.</p>
    <pre><code>
        int a = 5;   // 0101 in binary
        int b = 3;   // 0011 in binary
        int result = a | b; // Result: 0111 (7 in decimal)
        printf("a | b = %d\n", result);
    </code></pre>
    <p>Output: <code>a | b = 7</code></p>

    <h3>Bitwise XOR (^) Example</h3>
    <p>The bitwise XOR operation compares each corresponding bit of two numbers. If the bits are different, the result is 1. If they are the same, the result is 0.</p>
    <pre><code>
        int a = 5;   // 0101 in binary
        int b = 3;   // 0011 in binary
        int result = a ^ b; // Result: 0110 (6 in decimal)
        printf("a ^ b = %d\n", result);
    </code></pre>
    <p>Output: <code>a ^ b = 6</code></p>

    <h3>Bitwise NOT (~) Example</h3>
    <p>The bitwise NOT operation inverts all the bits of a number. All 0s become 1s, and all 1s become 0s.</p>
    <pre><code>
        int a = 5;   // 0101 in binary
        int result = ~a; // Result: 1010 (in decimal, -6 in 2's complement representation)
        printf("~a = %d\n", result);
    </code></pre>
    <p>Output: <code>~a = -6</code></p>

    <h3>Left Shift (<<) Example</h3>
    <p>The left shift operation shifts all the bits in a number to the left by a specified number of positions, adding zeros to the right.</p>
    <pre><code>
        int a = 5;   // 0101 in binary
        int result = a << 1; // Result: 1010 (10 in decimal)
        printf("a << 1 = %d\n", result);
    </code></pre>
    <p>Output: <code>a << 1 = 10</code></p>

    <h3>Right Shift (>>) Example</h3>
    <p>The right shift operation shifts all the bits in a number to the right by a specified number of positions, discarding bits on the right.</p>
    <pre><code>
        int a = 5;   // 0101 in binary
        int result = a >> 1; // Result: 0010 (2 in decimal)
        printf("a >> 1 = %d\n", result);
    </code></pre>
    <p>Output: <code>a >> 1 = 2</code></p>

    <h3>Applications of Bitwise Operations</h3>
    <p>Bitwise operations are commonly used in various applications, such as:</p>
    <ul>
        <li><strong>Efficient arithmetic:</strong> Bitwise operations can be used to perform multiplication and division by powers of 2 more efficiently.</li>
        <li><strong>Flag manipulation:</strong> Bitwise operations are often used to set, clear, or toggle individual bits in a status flag.</li>
        <li><strong>Cryptography:</strong> Bitwise operations are used in encryption and decryption algorithms to manipulate data at the bit level.</li>
        <li><strong>Network programming:</strong> Bitwise operations are useful for tasks like working with IP addresses and subnet masks.</li>
    </ul>
</div>

<div class="main" id="memory-management">
    <!-- Topic: Advanced Memory Management -->
    <h1>Advanced Memory Management</h1>

    <h3>Introduction to Memory Management</h3>
    <p>Memory management is a crucial concept in C programming, as it involves allocating, accessing, and freeing memory during the program's execution. Efficient memory management can lead to optimized performance and prevent memory-related errors like memory leaks and buffer overflows.</p>

    <h3>Dynamic Memory Allocation</h3>
    <p>Dynamic memory allocation in C allows you to allocate memory during the program's runtime using functions such as <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code>.</p>

    <h4>1. malloc()</h4>
    <p>The <code>malloc()</code> function is used to allocate a block of memory of a specified size.</p>
    <pre><code>
        int* ptr;
        ptr = (int*) malloc(5 * sizeof(int)); // Allocates memory for 5 integers
        if (ptr == NULL) {
            printf("Memory allocation failed\n");
        }
    </code></pre>

    <h4>2. calloc()</h4>
    <p>The <code>calloc()</code> function allocates memory for an array of elements and initializes them to zero.</p>
    <pre><code>
        int* ptr;
        ptr = (int*) calloc(5, sizeof(int)); // Allocates memory for 5 integers and initializes them to zero
        if (ptr == NULL) {
            printf("Memory allocation failed\n");
        }
    </code></pre>

    <h4>3. realloc()</h4>
    <p>The <code>realloc()</code> function is used to resize previously allocated memory blocks.</p>
    <pre><code>
        int* ptr;
        ptr = (int*) malloc(5 * sizeof(int));
        ptr = (int*) realloc(ptr, 10 * sizeof(int)); // Resize memory to store 10 integers
        if (ptr == NULL) {
            printf("Memory reallocation failed\n");
        }
    </code></pre>

    <h4>4. free()</h4>
    <p>The <code>free()</code> function is used to release previously allocated memory, freeing it for future use.</p>
    <pre><code>
        free(ptr); // Releases the dynamically allocated memory
    </code></pre>

    <h3>Memory Leaks</h3>
    <p>A memory leak occurs when dynamically allocated memory is not freed. This can lead to inefficient memory usage, eventually causing the program to run out of memory.</p>
    <p>To prevent memory leaks, always ensure that every dynamically allocated memory block is freed using <code>free()</code> when it's no longer needed.</p>

    <h3>Memory Corruption</h3>
    <p>Memory corruption occurs when a program writes to memory locations it shouldn't, often causing unexpected behavior or crashes. This can happen if you:</p>
    <ul>
        <li>Access memory after it has been freed.</li>
        <li>Write outside the bounds of an allocated memory block (e.g., array out-of-bounds).</li>
    </ul>
    <p>To avoid memory corruption, ensure that memory is used within valid bounds and that freed memory is not accessed afterward.</p>

    <h3>Pointers and Memory Management</h3>
    <p>Pointers are essential for memory management, as they store the addresses of dynamically allocated memory. However, improper use of pointers can lead to serious issues, such as:</p>
    <ul>
        <li><strong>Dangling Pointers:</strong> Pointers that still point to freed memory. Always set pointers to NULL after freeing them.</li>
        <li><strong>Wild Pointers:</strong> Pointers that are not initialized before use. Always initialize pointers when declaring them.</li>
    </ul>

    <h3>Garbage Collection in C</h3>
    <p>C does not have built-in garbage collection like some higher-level languages (e.g., Java). As a result, it is the programmer's responsibility to manage memory allocation and deallocation carefully to avoid memory-related issues.</p>

    <h3>Best Practices for Memory Management</h3>
    <ul>
        <li>Always check if memory allocation was successful by verifying that the pointer is not NULL.</li>
        <li>Ensure that every allocated memory block is eventually freed using <code>free()</code>.</li>
        <li>Use memory management tools like <strong>Valgrind</strong> to detect memory leaks and errors in your programs.</li>
        <li>Be cautious when using pointers and always initialize them before use.</li>
    </ul>
</div>

<div class="main" id="data-structures">
    <!-- Topic: Data Structures (Linked Lists, Stacks, Queues) -->
    <h1>Data Structures (Linked Lists, Stacks, Queues)</h1>

    <h3>Introduction to Data Structures</h3>
    <p>Data structures are ways of organizing and storing data to allow efficient access and modification. Understanding fundamental data structures is crucial for solving problems efficiently in C programming.</p>

    <h3>Linked Lists</h3>
    <p>A linked list is a linear collection of elements called nodes, where each node contains a data element and a reference (or link) to the next node in the sequence.</p>
    
    <h4>Structure of a Node</h4>
    <pre><code>
        struct Node {
            int data;
            struct Node* next;
        };
    </code></pre>

    <h4>Types of Linked Lists</h4>
    <ul>
        <li><strong>Single Linked List:</strong> Each node points to the next node, and the last node points to NULL.</li>
        <li><strong>Doubly Linked List:</strong> Each node contains two pointers: one to the next node and another to the previous node.</li>
        <li><strong>Circular Linked List:</strong> The last node points back to the first node, creating a circular structure.</li>
    </ul>

    <h4>Basic Operations on Linked Lists</h4>
    <ul>
        <li><strong>Insertion:</strong> Add a new node at the beginning, middle, or end of the list.</li>
        <li><strong>Deletion:</strong> Remove a node from the list.</li>
        <li><strong>Traversal:</strong> Visit each node to perform operations on it.</li>
        <li><strong>Search:</strong> Find a node with a specific value.</li>
    </ul>
    
    <h3>Stacks</h3>
    <p>A stack is a linear data structure that follows the Last In, First Out (LIFO) principle. The last element added to the stack is the first one to be removed.</p>

    <h4>Operations on Stacks</h4>
    <ul>
        <li><strong>Push:</strong> Add an element to the top of the stack.</li>
        <li><strong>Pop:</strong> Remove the element from the top of the stack.</li>
        <li><strong>Peek:</strong> View the top element without removing it.</li>
        <li><strong>IsEmpty:</strong> Check if the stack is empty.</li>
    </ul>

    <h4>Implementation of a Stack</h4>
    <pre><code>
        struct Stack {
            int data[100];
            int top;
        };
        
        void push(struct Stack* stack, int value) {
            stack->data[++stack->top] = value;
        }
        
        int pop(struct Stack* stack) {
            return stack->data[stack->top--];
        }
    </code></pre>

    <h3>Queues</h3>
    <p>A queue is a linear data structure that follows the First In, First Out (FIFO) principle. The first element added to the queue is the first one to be removed.</p>

    <h4>Operations on Queues</h4>
    <ul>
        <li><strong>Enqueue:</strong> Add an element to the end of the queue.</li>
        <li><strong>Dequeue:</strong> Remove the element from the front of the queue.</li>
        <li><strong>Front:</strong> View the front element without removing it.</li>
        <li><strong>IsEmpty:</strong> Check if the queue is empty.</li>
    </ul>

    <h4>Implementation of a Queue</h4>
    <pre><code>
        struct Queue {
            int data[100];
            int front;
            int rear;
        };
        
        void enqueue(struct Queue* queue, int value) {
            queue->data[++queue->rear] = value;
        }
        
        int dequeue(struct Queue* queue) {
            return queue->data[queue->front++];
        }
    </code></pre>

    <h3>Applications of Data Structures</h3>
    <ul>
        <li><strong>Linked Lists:</strong> Used in dynamic memory allocation, implementation of queues and stacks, and manipulation of large data sets.</li>
        <li><strong>Stacks:</strong> Used in function calls (call stack), expression evaluation, and undo operations in software.</li>
        <li><strong>Queues:</strong> Used in scheduling tasks, handling asynchronous data, and implementing breadth-first search in graph algorithms.</li>
    </ul>

    <h3>Best Practices</h3>
    <ul>
        <li>Ensure proper memory management for dynamic structures (e.g., freeing memory when no longer needed).</li>
        <li>Be aware of stack overflow errors when working with large data sets or recursive functions.</li>
        <li>Optimize queue and stack operations to minimize time complexity, especially in real-time applications.</li>
    </ul>
</div>

<div class="main" id="advanced-pointers">
    <!-- Topic: Advanced Pointer Concepts -->
    <h1>Advanced Pointer Concepts</h1>

    <h3>Introduction to Advanced Pointers</h3>
    <p>Pointers are a powerful feature in C, allowing direct memory access and manipulation. Advanced pointer concepts enable more complex memory operations and dynamic behaviors. Understanding advanced pointer topics is crucial for developing efficient, memory-intensive programs.</p>

    <h3>Pointer to Pointer (Pointer of Pointers)</h3>
    <p>A pointer to a pointer is a pointer that holds the address of another pointer. This concept is useful when working with multi-dimensional arrays or dynamic memory allocations.</p>

    <h4>Example: Pointer to Pointer</h4>
    <pre><code>
        int x = 10;
        int* ptr = &x;
        int** ptr_to_ptr = &ptr;
        printf("Value of x: %d\n", **ptr_to_ptr); // Dereferencing twice gives the value of x
    </code></pre>

    <h3>Arrays and Pointers</h3>
    <p>Arrays and pointers are closely related in C. The name of an array is a pointer to its first element. This relationship allows us to perform operations on arrays using pointer arithmetic.</p>

    <h4>Accessing Array Elements Using Pointers</h4>
    <pre><code>
        int arr[5] = {1, 2, 3, 4, 5};
        int* ptr = arr;
        printf("First element: %d\n", *ptr); // Accessing the first element using pointer dereferencing
        printf("Second element: %d\n", *(ptr + 1)); // Accessing the second element using pointer arithmetic
    </code></pre>

    <h3>Function Pointers</h3>
    <p>Function pointers allow us to store the address of a function in a pointer, enabling dynamic function calls and callbacks. They are useful in implementing polymorphism, event handling, and other dynamic behaviors in C.</p>

    <h4>Example: Function Pointer</h4>
    <pre><code>
        #include <stdio.h>
        
        void greet() {
            printf("Hello, World!\n");
        }

        int main() {
            void (*func_ptr)() = greet; // Function pointer pointing to greet()
            func_ptr(); // Calling the function through the pointer
            return 0;
        }
    </code></pre>

    <h3>Pointer Arithmetic</h3>
    <p>Pointer arithmetic involves manipulating pointers by adding or subtracting integer values. This is commonly used for iterating over arrays or dynamically allocated memory.</p>

    <h4>Pointer Arithmetic Example</h4>
    <pre><code>
        int arr[3] = {10, 20, 30};
        int* ptr = arr;

        printf("First element: %d\n", *ptr);
        printf("Second element: %d\n", *(ptr + 1)); // Pointer arithmetic to access next element
        printf("Third element: %d\n", *(ptr + 2));
    </code></pre>

    <h3>Dynamic Memory Allocation and Pointers</h3>
    <p>Dynamic memory allocation in C is managed using pointers. Functions like <code>malloc()</code>, <code>calloc()</code>, and <code>realloc()</code> return pointers to dynamically allocated memory blocks. Proper management of these pointers is critical to avoid memory leaks and segmentation faults.</p>

    <h4>Example: Dynamic Memory Allocation</h4>
    <pre><code>
        int* ptr;
        ptr = (int*) malloc(5 * sizeof(int)); // Allocating memory for 5 integers
        if (ptr != NULL) {
            for (int i = 0; i < 5; i++) {
                ptr[i] = i + 1;
                printf("%d ", ptr[i]);
            }
            free(ptr); // Freeing allocated memory
        } else {
            printf("Memory allocation failed\n");
        }
    </code></pre>

    <h3>Dangling Pointers</h3>
    <p>A dangling pointer is a pointer that points to a memory location that has been freed or deallocated. Accessing or dereferencing a dangling pointer can cause undefined behavior or crashes. Always set pointers to NULL after freeing memory to avoid dangling pointers.</p>

    <h3>Wild Pointers</h3>
    <p>A wild pointer is a pointer that has not been initialized. Using wild pointers leads to unpredictable behavior and crashes. Always initialize pointers when declaring them.</p>

    <h4>Example: Wild Pointer</h4>
    <pre><code>
        int* ptr; // Wild pointer, uninitialized
        printf("%d\n", *ptr); // Dereferencing a wild pointer leads to undefined behavior
    </code></pre>

    <h3>Best Practices for Working with Pointers</h3>
    <ul>
        <li><strong>Always initialize pointers:</strong> Before using pointers, ensure they are initialized to a valid memory address or NULL.</li>
        <li><strong>Avoid dereferencing NULL pointers:</strong> Always check if a pointer is NULL before dereferencing it.</li>
        <li><strong>Free dynamically allocated memory:</strong> Ensure that memory allocated with <code>malloc()</code> or <code>calloc()</code> is freed using <code>free()</code> to prevent memory leaks.</li>
        <li><strong>Avoid dangling pointers:</strong> Set pointers to NULL after freeing memory to prevent accessing deallocated memory.</li>
        <li><strong>Use pointer arithmetic carefully:</strong> Be cautious when using pointer arithmetic to avoid accessing out-of-bounds memory.</li>
    </ul>

</div>
 



    
</div>

        
<script src="script1.js"></script>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        const menuBtn = document.getElementById("menuBtn");
        const sidebar = document.getElementById("sidebar");

        menuBtn.addEventListener("click", () => {
            sidebar.classList.toggle("active");
        });

        const sidebarLinks = document.querySelectorAll(".sidebar ul li a");
        const contentSections = document.querySelectorAll(".content .content");

        sidebarLinks.forEach(link => {
            link.addEventListener("click", (e) => {
                e.preventDefault();
                const targetId = link.getAttribute("href").substring(1);

                // Hide all content sections and reset sidebar links
                contentSections.forEach(section => {
                    section.classList.remove("active");
                });

                // Show the selected content section
                document.getElementById(targetId).classList.add("active");

                // Set active background on sidebar links
                sidebarLinks.forEach(link => {
                    link.parentElement.classList.remove("active-bg");
                });

                link.parentElement.classList.add("active-bg");
            });
        });

        // Initialize the first section as active
        if (contentSections.length > 0) {
            contentSections[0].classList.add("active");
            sidebarLinks[0].parentElement.classList.add("active-bg");
        }
    });



    document.querySelector('.menu-btn2').addEventListener('click', function () {
        const topicButtons = document.querySelector('.topic-buttons');
        // Toggle the menu visibility by moving it on and off the screen
        if (topicButtons.style.right === '0px') {
            topicButtons.style.right = '-250px'; // Slide out
        } else {
            topicButtons.style.right = '0px'; // Slide in
        }
    });







</script>

</body>

</html>
